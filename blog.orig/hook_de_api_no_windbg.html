<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Blogue do Caloni</title>
<meta name="author" content="Caloni" />
<meta name="generator" content="https://github.com/caloni/journal">
<meta property="og:title" content="Blogue do Caloni"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="http://www.caloni.com.br"/>
<meta property="og:image" content="/blog/img/about-brand.png"/>
<meta property="og:description" content="Write for computers, people and food."/>
<link href="/blog/index.xml" rel="feed" type="application/rss+xml" title="Blogue do Caloni"/>
<link rel="stylesheet" type="text/css" href="/blog/css/custom.css"/>
<link rel="stylesheet" type="text/css" href="/blog/css/jquery-ui.css"/>
<script src="/blog/js/jquery-1.12.4.js"></script>
<script src="/blog/js/jquery-ui.js"></script>
<script src="/blog/js/copy_clipboard.js"></script>
<script src="/blog/js/list.js"></script>
<link rel="icon" href="/blog/img/favicon.ico"/>
</head>
<body style="min-height:100vh;display:flex;flex-direction:column">
<nav class="navbar has-shadow is-white"
role="navigation" aria-label="main navigation">
<div class="container">
<div class="navbar-brand">
&nbsp;
<a class="navbar-item" href="index.html">
<div class="is-4"><b>Blogue do Caloni</b></div>
</a>
</div>
</div>
</nav>
<div class="container">
<div class="column">
<div style="min-height:56vh">
<div style="padding-bottom: 1em;"></div>
<span id="hook_de_api_no_windbg" title="Hook de API no WinDbg"/></span>
<section id="section_hook_de_api_no_windbg">
<p class="title">Hook de API no WinDbg</p>
<span class="title-heading">Caloni, 2007-08-29 computer blog</span>

<p>Basicamente existem duas maneiras de um executável obter o endereço de uma função API do Windows: ou ele usa uma lib de interface com a DLL (o chamado "link estático") ou ele chama a função GetProcAddress explicitamente (1).</p>

<p>Para conseguir saber as funções das quais um executável obtém o endereço através da primeira técnica podemos utilizar o mundialmente famoso Dependency Walker. Ele nos mostrará quais DLLs ele utiliza e quais funções por DLL ele quer o endereço. Ele também nos avisa sobre as DLLs que estão utilizando delay load, uma técnica inventada no Visual Studio para que os executáveis não dependam estaticamente de APIs muito novas que podem não existir em versões do Windows mais antigas. Com o (carinhosamente chamado) Depends também é possível fazer hook de chamadas de API utilizando a opção profiling (F7), mas não costuma funcionar muito bem com trojans, pois eles capotam antes que alguma coisa interessante ocorra.</p>

<blockquote>Update 2026-01-29: a última versão disponível é de 2006, então talvez não seja uma boa ideia usá-lo agora; prefira o dumpbin das ferramentas do Visual Studio.</blockquote>
<p>O importante do Dependency Walker para o WinDbg é que com um editor é possível copiar todas as funções exibidas em sua interface para um editor, usar um pouco de regular expressions e criar uma batelada de breakpoints:</p>

<pre>
   ...
   bp user32!GetDC &quot;.echo GetDC; g&quot;
   bp user32!GetDesktopWindow &quot;.echo GetDesktopWindow; g&quot;
   bp user32!GetDlgCtrlID &quot;.echo GetDlgCtrlID; g&quot;
   bp user32!GetDlgItem &quot;.echo GetDlgItem; g&quot;
   bp user32!GetDlgItemTextW &quot;.echo GetDlgItemTextW; g&quot;
   bp user32!GetFocus &quot;.echo GetFocus; g&quot;
   ...
</pre>
<p>O comando "bp" cria um breakpoint no endereço requisitado. O que está entre aspas são os comandos que você deseja executar quando o breakpoint for disparado. No caso, para todas as funções será impresso o seu nome (comando ".echo") e a execução irá continuar (comando "g"). Ao rodar o programa, as chamadas das funções são mostradas na saída do depurador:</p>

<pre>
   ...
   GetDesktopWindow
   GetDC
   GetFocus
   GetDlgItem
   GetDC
   GetDlgItem
   GetDC
   GetDlgItem
   GetDC
   GetDlgItemTextW
   ...
</pre>
<p>Lindo, não? Porém ainda podem estar sendo chamadas as funções obtidas pela segunda técnica, a do GetProcAddress. Para esse caso devemos ir um pouquinho mais fundo e rodar o executável duas vezes. Na primeira, coletamos as funções que são obtidas por essa técnica através do seguinte comando:</p>

<pre>
   bp kernel32!GetProcAddress &quot;da poi(esp + 8); g&quot;
</pre>
<p>O comando "da" exibe o conteúdo de uma string em C (caracteres ANSI e terminada em zero) na memória. A memória no caso é o "apontado do valor contido no segundo parâmetro da pilha". Complicado? Nem tanto: lembre-se que o ESP aponta sempre pro endereço de retorno da função chamadora e os parâmetros são sempre empilhados na ordem inversa da declaração em C. Logo, se o protótipo de GetProcAddress é:</p>

<pre>
   FARPROC GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
</pre>
<p>O último parâmetro empilhado (ESP+4) é o hModule, e o penúltimo (ESP+8) é o lpProcName, que é o lugar onde é passado o nome da função.</p>

<p>Devemos lembrar de colocar esse breakpoint bem no início da execução e rodar o executável uma vez. Com isso coletamos o conjunto de nomes de funções usadas para chamar GetProcAddress:</p>

<pre>
   ...
   746e29f8  &quot;ImmReleaseContext&quot;
   746e2a30  &quot;ImmNotifyIME&quot;
   746e2934  &quot;CtfImmEnterCoInitCountSkipMode&quot;
   746e2978  &quot;CtfImmLeaveCoInitCountSkipMode&quot;
   746e29bc  &quot;ImmGetDefaultIMEWnd&quot;
   746e2a64  &quot;ImmSetConversionStatus&quot;
   746e2aa0  &quot;ImmGetConversionStatus&quot;
   746e2adc  &quot;ImmGetProperty&quot;
   746e2b10  &quot;ImmGetOpenStatus&quot;
   ...
</pre>
<p>Daí é só organizar a lista obtida em ordem alfabética, acabar com duplicidades e criar o mesmo tipo de breakpoint que foi usado para as funções estáticas (pode ser sem o nome da DLL porque, embora não recomendado, o WinDbg se vira para encontrar os símbolos). Depois de criados os comandos, rodamos novamente o executável e, logo no início, já colocamos todos os breakpoints das funções coletadas.</p>

<p>Essa é uma maneira rústica, porém eficaz e rápida de obter a lista de execução da API utilizada por um programa (2).</p>

<p>(1) Uma variação do método GetProcAddress é a técnica de delay load usado pelo Visual C++. Porém, como o Dependency Walker nos mostra também as DLLs que estão linkadas usando essa técnica se torna dispensável um tratamento ad hoc.</p>

<p>(2) Essa técnica nem sempre funciona com todas as chamadas API, pois o aplicativo ainda pode utilizar outras maneiras de obter o endereço de uma função e chamá-la. A solução definitiva seria escrever diretamente um assembly esperto no começo da função, o que pode gerar mais problemas que soluções. Do jeito que está, conseguimos resolver 90% dos nossos problemas com análise de chamadas API. O resto nós podemos resolver em futuros artigos.</p>

</section>

<span style="float: left;">
 <a href="barata_eletrica_e_o_hacker_de_antigamente.html">[barata_eletrica_e_o_hacker_de_antigamente]</a>
 <a href="antidebug_ocupando_a_debugport.html">[antidebug_ocupando_a_debugport]</a>
</span>
</div>
</div>
</section>
<footer class="footer">
<div class="container">
</div>
<div class="intentionally-blank"></div>
</footer>
</body>
</html>
