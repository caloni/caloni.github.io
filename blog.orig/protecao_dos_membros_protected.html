<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Blogue do Caloni</title>
<meta name="author" content="Caloni" />
<meta name="generator" content="https://github.com/caloni/journal">
<meta property="og:title" content="Blogue do Caloni"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="http://www.caloni.com.br"/>
<meta property="og:image" content="/blog/img/about-brand.png"/>
<meta property="og:description" content="Write for computers, people and food."/>
<link href="/blog/index.xml" rel="feed" type="application/rss+xml" title="Blogue do Caloni"/>
<link rel="stylesheet" type="text/css" href="/blog/css/custom.css"/>
<link rel="stylesheet" type="text/css" href="/blog/css/jquery-ui.css"/>
<script src="/blog/js/jquery-1.12.4.js"></script>
<script src="/blog/js/jquery-ui.js"></script>
<script src="/blog/js/copy_clipboard.js"></script>
<script src="/blog/js/list.js"></script>
<link rel="icon" href="/blog/img/favicon.ico"/>
</head>
<body style="min-height:100vh;display:flex;flex-direction:column">
<nav class="navbar has-shadow is-white"
role="navigation" aria-label="main navigation">
<div class="container">
<div class="navbar-brand">
&nbsp;
<a class="navbar-item" href="index.html">
<div class="is-4"><b>Blogue do Caloni</b></div>
</a>
</div>
</div>
</nav>
<div class="container">
<div class="column">
<div style="min-height:56vh">
<div style="padding-bottom: 1em;"></div>
<span id="protecao_dos_membros_protected" title="Proteção dos membros protected"/></span>
<section id="section_protecao_dos_membros_protected">
<p class="title">Proteção dos membros protected</p>
<span class="title-heading">Caloni, 2007-10-26 computer ccpp blog</span>

<p>Quando queremos que um membro de nossa classe seja visível apenas dentro dos métodos da classe e dentro dos métodos das classes derivadas dessa classe usamos o nível de proteção protected. Isso, é claro, não quer dizer que uma classe derivada vá ter acesso aos membros protegidos de outra:</p>

<pre>
   #include &lt;iostream&gt;
   using namespace std;
   class Base
   {
   protected:
   	int m_protected;
   };
   class Deriv : public Base
   {
   public:
   	int GetProtectedFromBase();
   	int GetProtectedFromDeriv2();
   };
   class Deriv2 : public Base
   {
   };
   int Deriv::GetProtectedFromBase()
   {
   	return m_protected;
   }
   int Deriv::GetProtectedFromDeriv2()
   {
   	Deriv2 deriv2;
     // error C2248: 'Base::m_protected' : cannot
     // access protected member
     // declared in class 'Base'
   	return deriv2.m_protected;
   }
   int main()
   {
   	Deriv deriv;
   	deriv.GetProtectedFromBase();
   	deriv.GetProtectedFromDeriv2();
   }
</pre>
<p>Esse é o motivo fundamental do porquê não podermos fazer isso:</p>

<pre>
   int Deriv::GetProtectedFromBase()
   {
     Base base;
     return base.m_protected;
   } 
</pre>
<p>Ao acessar membros protegidos é importante o tipo da expressão que está do lado esquerdo do "." ou "-&gt;". Afinal, o nível de proteção se baseia no escopo, e as classes são um escopo. É por isso que consigo acessar os membros protegidos de um outro objeto de minha classe, mesmo sendo outro objeto:</p>

<pre>
   int Deriv::GetProtectedFromDeriv2()
   {
     Deriv deriv;
     assert(typeid(deriv) == typeid(*this));
     return deriv.m_protected; // OK
   }
</pre>
<p>A definição do escopo é tudo o que o compilador dispõe para saber se acessa ou não acessa um membro. Podemos ter acesso a m_protected enquanto somos do tipo Deriv, mas não quando o mesmo objeto é usado como Base:</p>

<pre>
   int Deriv::GetProtectedFromBase()
   {
     Base&amp; base = *this;
     assert(typeid(base) != typeid(*this));
     return base.m_protected; // ERROR
   }
</pre>
<p>Essa proteção parece desnecessária e até mesmo incoerente quando lidamos com o mesmo objeto que acessa. Afinal, somos nós mesmos! Só que o compilador não sabe disso, e ele deve desconfiar de tudo e de todos para evitar esse tipo de "ataque":</p>

<pre>
   int Deriv::GetProtectedFromDeriv2()
   {
     Deriv2 deriv2;
     Base&amp; base = deriv2;
     assert(typeid(deriv2) != typeid(*this));
     return base.m_protected; // ERROR
   }
</pre>
<p>Agora a proteção do compilador faz sentido. Parece um detalhe frívolo, mas já vi programadores de respeito se debatendo pela "burrice" do compilador. Imaginei que talvez houvesse mais pessoas com a mesma dúvida de se existe ou não um "bug na linguagem".</p>

</section>

<span style="float: left;">
 <a href="alterando_mensagem_de_erro_no_notepad.html">[alterando_mensagem_de_erro_no_notepad]</a>
 <a href="typeid_e_os_perigos_do_nao_polimorfismo.html">[typeid_e_os_perigos_do_nao_polimorfismo]</a>
</span>
</div>
</div>
</section>
<footer class="footer">
<div class="container">
</div>
<div class="intentionally-blank"></div>
</footer>
</body>
</html>
