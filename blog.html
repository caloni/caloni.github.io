<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Jornal do Caloni</title>
<meta name="author" content="Caloni" />
<meta name="generator" content="https://github.com/caloni/journal">
<meta property="og:title" content="Jornal do Caloni"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="http://www.caloni.com.br"/>
<meta property="og:image" content="/img/about-brand.png"/>
<meta property="og:description" content="Write for computers, people and food."/>
<link href="/index.xml" rel="feed" type="application/rss+xml" title="Jornal do Caloni"/>
<link rel="stylesheet" type="text/css" href="/css/custom.css"/>
<link rel="stylesheet" type="text/css" href="/css/jquery-ui.css"/>
<script src="/js/jquery-1.12.4.js"></script>
<script src="/js/jquery-ui.js"></script>
<script src="/js/copy_clipboard.js"></script>
<script>
var quick_search_posts = [ 
 ]; 
</script>
<script src="/js/quick_search.js"></script>
<script src="/js/list.js"></script>
<link rel="icon" href="/img/favicon.ico"/>
</head>
<body style="min-height:100vh;display:flex;flex-direction:column">
<nav class="navbar has-shadow is-white"
role="navigation" aria-label="main navigation">
<div class="container">
<div class="navbar-brand">
&nbsp;
<a class="navbar-item" href="index.html">
<div class="is-4"><b>caloni::blog</b></div>
</a>
</div>
</div>
</nav>
<div class="container">
<div class="column">
<div style="min-height:56vh">
<div style="padding-bottom: 1em;"></div>
<input type="text" name="filter" value="" id="filter" placeholder="enter to select" style="width: 100%; font-size: 1.5rem; margin-top: 1em; margin-bottom: 0.5em;" title=""/></br>
<button id="filterbutton" style="font-size: 1rem;" onclick="ApplyFilter($('#filter').val());">select</button>
<button id="removebutton" style="font-size: 1rem;" onclick="ApplyNotFilter($('#filter').val());">remove</button>
<button id="randombutton" style="font-size: 1rem;" onclick="window.location = randomPost;">random</button>
<div><big><b><span style="visibility: hidden; padding: 5px;" name="results" id="results">...</span></b></big></div>
<table class="sortable" style="width: 100%;">
<tr><td>
<b><a href="2011-05.html#comparando_strings_no_windbg">Comparando strings no WinDbg</a></b>
<small><i>2011-05-22 blog computer  O WinDbg fornece aos programadores diversos meios (muitos redundantes) de comparar valores inteiros em quaquer lugar da memória, em qualquer tamanho (8, 16, 32, 64 bits). Porém, quando precisamos comparar strings, que todos sabem ser uma sequência de bytes de tamanho arbitrário (se for em C, até o zero terminador).</small></i>
</td></tr>
<tr><td>
<img src="img/vtable_vtable2.png"/>
<b><a href="2011-03.html#vtable">VTable</a></b>
<small><i>2011-03-01 blog computer  Acho que na breve história desse blogue nunca contei a história do vtable. No máximo fizemos um [hookzinho nos métodos de um componente COM]. Mas só. Não encontro uma analogia simples, assim, de cabeça. Então vou contar no cru, mesmo. Talvez seja até mais divertido.</small></i>
</td></tr>
<tr><td>
<b><a href="2010-11.html#patch_de_emergencia_2">Patch de emergência 2</a></b>
<small><i>2010-11-09 blog computer  No [artigo anterior] fizemos um patch rapidinho na memória se aproveitando de um Sleep nojento que o código nos forneceu. E se não houvesse Sleep? As chances de estarmos escrevendo no momento em que a função está sendo executada são tremendas, de forma que não poderíamos sobrescrevê-la sem correr o risco de um crash.</small></i>
</td></tr>
<tr><td>
<img src="img/patch_de_emergencia_bMI63Ka.png"/>
<b><a href="2010-11.html#patch_de_emergencia">Patch de emergência</a></b>
<small><i>2010-11-08 blog computer  Após um projeto muito bem sucedido, entregue no prazo e homologado em tempo recorde, você e sua equipe estão aproveitando suas devidas férias nas Bahamas, tomando água de coco na sombra de uma palmeira e apreciando a beleza natural da região. Ambas as belezas. =)</small></i>
</td></tr>
<tr><td>
<img src="img/gerando_dumps_automatizados_finddump.png"/>
<b><a href="2010-08.html#gerando_dumps_automatizados">Gerando dumps automatizados</a></b>
<small><i>2010-08-26 blog computer  Agora que a temporada das telas azuis passou estou às voltas com o nosso sistema de detecção de crashes, além de alguns dumps e logs pra relaxar de vez em quando. Fiquei impressionado com a simplicidade com que podemos capturar qualquer exceção que ocorra em um programa, independente da thread, e gravar um minidump com o contexto exato em que o problema ocorreu. O uso da função API [SetUnhandledExceptionFilter] aliado com a já citada na palestra [MiniDumpWriteDump] pode agilizar muito a correção de crashes triviais como Access Violation.</small></i>
</td></tr>
<tr><td>
<img src="img/como_achar_o_codigo_fonte_sem_simbolos_gUfPM5Q.jpg"/>
<b><a href="2010-08.html#como_achar_o_codigofonte_sem_simbolos">Como achar o código-fonte sem símbolos</a></b>
<small><i>2010-08-03 blog computer  Continuo escovando bits. Dessa vez de forma mais nervosa. Se trata de um serviço que trava durante seu stop. Um colega muito esperto do suporte gerou um dump para mim, tornando as coisas mais fáceis. O problema era que não havia símbolos nem código-fonte que batessem exatamente com aquela compilação de 2004. Solução? Analisar as pilhas das threads restantes.</small></i>
</td></tr>
<tr><td>
<b><a href="2010-05.html#modificadores_e_qualificadores_de_tipo">Modificadores e qualificadores de tipo</a></b>
<small><i>2010-05-28 blog computer  "@caloni poderia pensar em fazer um artigo sobre os modificadores de tipo em c? os mais complexo, acho eu: volatile, enum, union, extern, etc" Uma coisa de cada vez: existem **modificadores** (ou qualificadores) de tipo e **especificadores** de tipo. _Volatile_ e _extern_ se encaixam na primeira categoria, _enum_ e _union_ na segunda. Veremos um pouco desses dois lados da linguagem em doses paliativas.</small></i>
</td></tr>
<tr><td>
<img src="img/por_que_long_pointer_getting_lost_on_streets.png"/>
<b><a href="2010-04.html#por_que_long_pointer">Por que Long Pointer</a></b>
<small><i>2010-04-21 blog computer  Esse artigo continua a explicação sobre [os typedefs arcaicos], já que ainda falta explicar por que diabos os ponteiros da Microsoft começam com LP. Tentei explicar para [minha pupila] que, por ser código dos anos 80, as pessoas usavam LP para tudo, pois os CDs ainda não estavam tão difundidos.</small></i>
</td></tr>
<tr><td>
<img src="img/typedef_arcaico_gFNalqB.png"/>
<b><a href="2010-04.html#typedef_arcaico">Typedef arcaico</a></b>
<small><i>2010-04-20 blog computer  A [API do Windows] geralmente prima pela excelência em maus exemplos. A [Notação Húngara] e o Typedef Arcaico são duas técnicas que, por motivos históricos, são usados a torto e a direito pelos códigos de exemplo.</small></i>
</td></tr>
<tr><td>
<b><a href="2010-04.html#houaiss_para_babylon">Houaiss Para Babylon!</a></b>
<small><i>2010-04-08 blog projects  Os últimos comentários de Henrique Esteves (quando havia seção de comentários no blogue) sobre o HouaissParaBabylon me fizeram dar mais uma fuçada nele e ver se tento deixá-lo compatível com o Houaiss 3. Foram apenas algumas horas e acho que resolvi os probleminhas relacionados com a troca do registro de instalação e o nome dos arquivos que armazenam os verbetes.</small></i>
</td></tr>
<tr><td>
<img src="img/importando_tipos_de_outros_projetos_l4oLJHR.png"/>
<b><a href="2010-01.html#importando_tipos_de_outros_projetos">Importando tipos de outros projetos</a></b>
<small><i>2010-01-11 blog computer  A engenharia reversa das entranhas do kernel não tem limites se você sabe o que está fazendo. No entanto, algumas facilidades do depurador podem ajudar a minimizar o tempo que gastamos para analisar uma simples estrutura. Por exemplo, o [Process Environment Block] de um processo específico.</small></i>
</td></tr>
<tr><td>
<b><a href="2009-12.html#o_boot_no_windows_kernel">O boot no Windows: Kernel</a></b>
<small><i>2009-12-04 blog computer  Finalmente chegamos em um ponto onde podemos usar o WinDbg. Podemos espetar o depurador e fazê-lo parar assim que conectado. Se estiver rodando antes do próprio sistema operacional, teremos um sistema sem processos e sem threads, pois ele irá parar assim que o executivo puder enviar o sinal de início pela porta serial, após carregar na memória os módulos básicos.</small></i>
</td></tr>
<tr><td>
<img src="img/o_boot_no_windows_ntldr_2ewkFhs.png"/>
<b><a href="2009-11.html#o_boot_no_windows_ntldr">O boot no Windows: NTLDR</a></b>
<small><i>2009-11-26 blog computer  Minhas análises estão demorando muito para ser feitas. Talvez seja a hora de revelar o pouco que sei (e pesquisei) sobre o próximo processo de boot do Windows: o NTLDR. ![Galinha Preta](o_boot_no_windows_ntldr_galinha_preta.jpg)</small></i>
</td></tr>
<tr><td>
<img src="img/o_boot_no_windows_pre_ntldr_7dZZZag.png"/>
<b><a href="2009-09.html#o_boot_no_windows_prentldr">O boot no Windows: pré-NTLDR</a></b>
<small><i>2009-09-09 blog computer  Conforme fui estudando para recordar os momentos sublimes do boot do Windows me deparei com o artigo mais "espetaculoso" de todos os tempos sobre esse assunto, parte integrante do livro [Windows Internals] e escrito pelo nada mais nada menos Mark Russinovich: **Boot Process**, no capítulo 5, "Startup and Shutdown".</small></i>
</td></tr>
<tr><td>
<b><a href="2009-08.html#o_boot_no_windows_sem_windows">O boot no Windows: sem Windows</a></b>
<small><i>2009-08-18 blog computer  Desde quando o usuário liga o computador até o momento em que ele vê a barra de tarefas e aqueles fundos lindos de papel de parede existem diversas coisas sendo feitas por debaixo do pano. Essa série de artigos irá explicar essas diversas coisas, ou seja, como funciona e quais as fases do boot de uma máquina que possui Windows instalado (plataforma NT).</small></i>
</td></tr>
<tr><td>
<b><a href="2009-07.html#static_polymorphism">Static Polymorphism</a></b>
<small><i>2009-07-10 blog english computer  To explain the polymorphism nothing is better than see how stuff used to be. If you were a twenty old C programmer in the past and created the following functions: int soma(int x, int y); double soma(double x, double y);</small></i>
</td></tr>
<tr><td>
<b><a href="2009-07.html#polimorfismo_estatico">Polimorfismo estático</a></b>
<small><i>2009-07-10 blog computer  Para explicar polimorfismo, nada como ver as coisas como elas eram. Se você fosse um programador C de vinte anos atrás e criasse as seguintes funções: int soma(int x, int y); double soma(double x, double y);</small></i>
</td></tr>
<tr><td>
<b><a href="2009-06.html#programadores_de_verdade_nao_usam_java">Programadores de verdade não usam Java</a></b>
<small><i>2009-06-18 blogging blog  Quando era um newbie (e um wanna-be) gostava de ler o "Real Programmers Don't Use Pascal", um texto humorístico que mais me influenciou e encorajou a caminho da iluminação C/C++ do que o livro de K&R. A partir dele, supunha eu, ser um "programador de verdade" era ser tudo. Ser um Quiche Eater (Comedor de Torta) não era nada. Programadores de verdade é que resolvem os problemas de verdade! Quiche Eaters são os losers que estudam os conceitos acadêmicos da ciência da computação e nunca fazem um maldito programa que preste (conhece alguém assim?).</small></i>
</td></tr>
<tr><td>
<b><a href="2009-06.html#bugs_dificeis_de_achar">Bugs Difíceis de Achar</a></b>
<small><i>2009-06-18 blog computer  Saiu um artigo na Wired News sobre [os piores bugs da história]. Entre eles estão a explosão de um oleoduto soviético em plena guerra-fria (como se não bastasse chernobyl), o primeiro worm da Internet (que se aproveita de um buffer overflow da função gets) e o famoso erro de divisão em ponto flutuante do Pentium; um erro de cálculo de cerca de 0,006% que causou um prejuízo de 457 milhões de dólares para a Intel.</small></i>
</td></tr>
<tr><td>
<b><a href="2009-04.html#a_sala_da_fila_das_threads">A sala da fila das threads</a></b>
<small><i>2009-04-17 blog computer  Quando falei sobre [a fila das threads], e como cada thread espera pacientemente em uma fila até chegar sua vez de ser atendida no guichê das CPUs, também vimos como é fácil fazer caquinhas em um programa que roda paralelamente duas threads ou mais.</small></i>
</td></tr>
<tr><td>
<b><a href="2009-04.html#a_fila_das_threads">A fila das threads</a></b>
<small><i>2009-04-07 blog computer  Em um ambiente multithreading diversas threads disputam "a tapas" a atenção do processador (CPU). Certo? Podemos dizer que, em um ambiente com muito processamento a realizar, de certa forma é isso que acontece. São threads e mais threads rodando um pedacinho de código cada vez que passam pelo processador.</small></i>
</td></tr>
<tr><td>
<b><a href="2009-03.html#depurando_ate_o_ultimo_segundo">Depurando até o último segundo</a></b>
<small><i>2009-03-31 blog computer  Como depurar um programa que dá pau logo no final do desligamento de uma máquina? No cenário em que isso se passa não existem usuários logados no momento, o que significa a impossibilidade de rodar qualquer programa em uma sessão prévia e mantê-lo no ar após o logoff. A não ser que se trate de um serviço.</small></i>
</td></tr>
<tr><td>
<img src="img/basico_do_basico_assembly_wZ6kKs8.jpg"/>
<b><a href="2009-01.html#basico_do_basico_assembly">Básico do básico: assembly</a></b>
<small><i>2009-01-26 blog computer  É lógico que não poderia faltar no cinto de utilidades de todo bom programador C conhecimentos **básicos** da linguagem assembly, sua mãe espiritual. São tantos conceitos em comum que, uma vez aprendido seu funcionamento, fica difícil não pensar no código-assembly gerado pelo compilador C. E é nesse ponto que as coisas começam a ficar mais claras.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-12.html#houaissparababylon_versao_11">HouaissParaBabylon versão 1.1</a></b>
<small><i>2008-12-30 blog projects  Saindo mais um do forno. Essa nova versão do conversor do dicionário Houaiss para Babylon corrige o problema de não encontrar o Houaiss 1.0. O problema ocorria porque o conversor se baseava na localização do desinstalador para encontrar o dicionário. Na primeira versão do dicionário o desinstalador fica na pasta c:\Windows, onde obviamente não estava o dicionário.</small></i>
</td></tr>
<tr><td>
<img src="img/basico_do_basico_binario_jQTGnH6.gif"/>
<b><a href="2008-12.html#basico_do_basico_binario">Básico do básico: binário</a></b>
<small><i>2008-12-18 blog computer  Apesar do tema binário, o assunto de hoje no fundo remete-nos a todo e qualquer tipo de **representação**. É o faz-de-conta um pouco mais intenso, vindo das profundezas da matemática e dominado com maestria pela nossa mente e sua capacidade lógica de abstrair.</small></i>
</td></tr>
<tr><td>
<img src="img/basico_do_basico_tipos_interpretacao_de_memoria_texto_e_numeros.png"/>
<b><a href="2008-12.html#basico_do_basico_tipos">Básico do básico: tipos</a></b>
<small><i>2008-12-12 blog computer  Um tipo nada mais é que do que uma forma (ô) de bolo, que **molda a memória** como acharmos melhor moldá-la. Bom, para isso fazer sentido é necessário explicar memória, que é um conceito **mais básico ainda**.</small></i>
</td></tr>
<tr><td>
<img src="img/basico_do_basico_ponteiros_draft_pointers_strings_arrays.jpg"/>
<b><a href="2008-12.html#basico_do_basico_ponteiros">Básico do básico: ponteiros</a></b>
<small><i>2008-12-06 blog computer  Nessas últimas semanas tenho gastado meu tempo junto da mais nova pupila da SCUA, aspirante a programadora em C e Install Shield Script. Minha tarefa? Explicar tudo, desde o mais simples, como **variáveis**, até as coisas não tão triviais, como **símbolos de depuração**.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-11.html#houaissparababylon_versao_beta">HouaissParaBabylon versão beta</a></b>
<small><i>2008-11-15 blog projects  Depois de muitos fins-de-semana divididos em horas picadinhas de programação de lazer, está disponível em vosso saite a primeira versão para usuários do conversor do dicionário Houaiss para o aplicativo Babylon.</small></i>
</td></tr>
<tr><td>
<img src="img/como_funciona_o_psexec_vBGHXoC.png"/>
<b><a href="2008-10.html#como_funciona_o_psexec">Como funciona o PsExec</a></b>
<small><i>2008-10-29 blog computer  Semana passada precisei reproduzir o comportamento da ferramenta PsExec em um projeto, o que me fez sentir alguma nostalgia dos tempos em que eu fazia [engenharia reversa] todo dia. Este breve relato (espero) reproduz os passos que segui para descobrir o que esse programa tão útil quanto perigoso faz.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-10.html#a_alca_dentro_do_fio_gerou_um_bloqueio_da_morte">A Alça Dentro do Fio Gerou um Bloqueio da Morte</a></b>
<small><i>2008-10-21 blog computer  Estava folheando um livro fenomenal que meu amigo havia pedido emprestado para ler quando me deparei com algumas traduções no mínimo curiosas. O exemplar em questão era o primeiro Windows Internals, publicado após o lançamento da primeira versão do Windows NT, uma plataforma escrita (quase) inteiramente do zero para suplantar as versões 9x (Windows 95 e 98), que herdaram do DOS algumas partes indesejáveis em sistemas operacionais modernos.</small></i>
</td></tr>
<tr><td>
<img src="img/windows_jobs_com_completion_port_job.gif"/>
<b><a href="2008-09.html#windows_jobs_com_completion_port">Windows Jobs com Completion Port</a></b>
<small><i>2008-09-23 blog computer  Ou "Como esperar o término de todos os processos-filho criados a partir de um conjunto de processos". Dessa vez confesso que esperava um pouco mais de documentação do MSDN, ou pelo menos um sistema de referências cruzadas eficiente. Outro dia demorei cerca de duas horas para conseguir [criar um _**job**_], anexar o processo desejado e, a pior parte, esperar que todos os processos (o principal e seus filhos e netos) terminassem.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-08.html#processleaker">ProcessLeaker</a></b>
<small><i>2008-08-21 blog computer  O artigo anterior mostrava como detectar o leak de um processo gerado pela retenção e não-liberação de handles para o Windows Explorer. O problema fora causado por um serviço malcriado. No entanto, a título de demonstração, criei um pequeno programinha sem-vergonha para fazer as coisas parecerem difíceis. No entanto o programa é bem fácil:</small></i>
</td></tr>
<tr><td>
<b><a href="2008-08.html#os_processosfantasma">Os processos-fantasma</a></b>
<small><i>2008-08-20 blog computer  Estava eu outro belo dia tentando achar um problema em um driver que controla criação de processos quando, por acaso, listo os processos na máquina pelo depurador de kernel, após ter dado alguns logons e logoffs, quando me vem a seguinte lista de processos do Windows Explorer:</small></i>
</td></tr>
<tr><td>
<img src="img/antidebugging_during_the_process_attach_espertinho.png"/>
<b><a href="2008-08.html#antidebugging_during_the_process_attach">Antidebugging during the process attach</a></b>
<small><i>2008-08-05 blog antidebug english projects computer  Today was a great day for reverse engineering and protection analysis. I've found two great programs to to these things: a API call monitor (update: does not exist anymore) and a COM call monitor (update: either). Besides that, in the first program site - from a enthusiastic of the good for all Win32 Assembly - I've found the source code for one more antidebugging technique, what bring us back to our series of antidebugging techniques.</small></i>
</td></tr>
<tr><td>
<img src="img/antidebugging_using_the_debugport_debug_port2.gif"/>
<b><a href="2008-08.html#antidebugging_using_the_debugport">Antidebugging using the DebugPort</a></b>
<small><i>2008-08-01 blog antidebug english projects computer  When a debugger starts a process to be debugged or, the article case, connects to a already created process, the communication between these processes is made through an internal resource inside Windows called LPC (Local Procedure Call). The system creates a "magic" communication port for debugging and the debugging events pass throw it.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-07.html#antidebugging_using_exceptions_part_two">Antidebugging using exceptions (part two)</a></b>
<small><i>2008-07-30 blog antidebug english projects computer  In the first article we saw how it's possible to spoof the debugger through exceptions and let the attacker lose some considerable time trying to unbind the program from the fake breakpoints. However, we saw also that this is a difficult solution to keep in the source code, besides its main weakness to be easily bypassed if discovered. Now it's time to put things easier to support and at the same time to guarantee tough times even if the attacker discover what is going on.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-07.html#antidebugging_using_exceptions_part_one">Antidebugging using exceptions (part one)</a></b>
<small><i>2008-07-28 blog antidebug english projects computer  A debugger puts breakpoints to stop for a moment the debuggee execution. In order to do this it makes use of a well known instruction: int 3. This instruction throws an exception - the breakpoint exception - that is caught by the operating system and bypassed to the handling code for this exception. For debuggee processes this code is inside the debugger. For free processes this code normally doesn't exist and the application simply crashs.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-07.html#o_conhecido_unresolved_external">O conhecido unresolved external</a></b>
<small><i>2008-07-18 blog computer  O artigo anterior mostrou que nem sempre as coisas são simples de resolver, mas que sempre existe um caminho a seguir e que, eventualmente, todos os problemas se solucionarão. Porém, resolver um problema por si só não basta: é preciso rapidez. E como conseguimos rapidez para resolver problemas? Um jeito que eu, meu cérebro e o Dmitry Vostokov conhecem é montando padrões.</small></i>
</td></tr>
<tr><td>
<img src="img/o_caso_da_funcao_de_delay_load_desaparecida_delayimpprocmon.png"/>
<b><a href="2008-07.html#o_caso_da_funcao_de_delay_load_desaparecida">O caso da função de Delay Load desaparecida</a></b>
<small><i>2008-07-16 blog computer  Todos os projetos do Visual Studio 6 estavam compilando normalmente com a nova modificação do código-fonte, uma singela chamada a uma função da DLL iphlpapi.dll. No entanto, ainda restava a compilação para Windows 95, um legado que não era permitido esquecer devido ao parque antigo de máquinas e sistemas operacionais de nossos clientes.</small></i>
</td></tr>
<tr><td>
<img src="img/segunda_versao_do_houaiss2babylon_houaiss2babylonerror.png"/>
<b><a href="2008-07.html#segunda_versao_do_houaiss2babylon">Segunda versão do Houaiss2Babylon</a></b>
<small><i>2008-07-14 blog projects computer  Depois de vários comentários de pessoas tendo problemas em converter seus dicionários Houaiss para o formato Babylon, resolvi criar vergonha na cara e dar uma pequena melhora na versão beta do conversor.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-06.html#reflexao_em_c">Reflexão em C++</a></b>
<small><i>2008-06-30 blog computer  O termo e conceito de reflection, muito usado em linguagens modernas, é a capacidade de um programa de observar e até de alterar sua própria estrutura. Bom, isso você pode ler na Wikipédia. O interessante é o que podemos usar desse conceito na linguagem C++.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-06.html#e_possivel_carregar_duas_dlls_gemeas_no_mesmo_processo">É possível carregar duas DLLs gêmeas no mesmo processo?</a></b>
<small><i>2008-06-21 blog computer  Um [dos últimos artigos] de Dmitry Vostokov, e tenho que falar assim porque o cara escreve muito em pouco tempo, fala sobre os perigos de termos uma mesma DLL carregada duas vezes em um único processo, muitas vezes em versões diferentes. Para os observadores atentos como Dmitry esse é um perigo que muitas vezes temos que estar preparados. Para os espertinhos de plantão, a resposta padrão seria: "não vou me preocupar, porque o contador de instâncias cuida disso".</small></i>
</td></tr>
<tr><td>
<b><a href="2008-06.html#alinhamento_de_memoria_portavel">Alinhamento de Memória Portável</a></b>
<small><i>2008-06-18 blog computer  Como vimos durante o seminário CCPP, o alinhamento de memória pode ser problemático durante momentos críticos, como migração de plataforma (16 para 32 bits) e de ambiente (compilador novo). A forma como a memória é alinhada influi diretamente em algoritmos de criptografia ou de rede, para citar dois exemplos bem comuns, fazendo com que o que funcionava antes não funcione mais sem mexer uma única linha de código. Eu já vi isso. E isso não é bom.</small></i>
</td></tr>
<tr><td>
<img src="img/declaracao_x_definicao_cdepends.gif"/>
<b><a href="2008-06.html#declaracao_x_definicao">Declaração x definição</a></b>
<small><i>2008-06-06 blog computer  Uma diferença que eu considero crucial na linguagem C/C++ é a questão da declaração/definição (em inglês, declaration/definition). É a diferença entre esses dois conceitos que permite, por exemplo, que sejam criadas estruturas prontas para serem conectadas a listas ligadas:</small></i>
</td></tr>
<tr><td>
<b><a href="2008-05.html#aquele_do_while_engracado">Aquele do-while engraçado</a></b>
<small><i>2008-05-15 blog ccpp computer  Nesses últimos dias andei conversando com um amigo que está estudando sistemas operacionais na faculdade. Melhor ainda, vendo o código real de um sistema operacional em funcionamento. A conseqüência é que, além de aprender um bocado de como as coisas funcionam de verdade debaixo dos panos, acaba-se aprendendo alguns truquezinhos básicos e tradicionais da linguagem C.</small></i>
</td></tr>
<tr><td>
<img src="img/kernel_mode_user_mode_windbg_user_kernel2.png"/>
<b><a href="2008-05.html#kernel_mode_user_mode">Kernel Mode &gt;&gt; User Mode, ou Como Fazer Debug de User Mode pelo Kernel Mode</a></b>
<small><i>2008-05-13 blog windbg computer  Existem algumas situações onde um depurador WYSIWYG é artigo de luxo. Imagine o seguinte: temos um serviço que inicia automagicamente antes do login do Windows, e possivelmente antes mesmo do ambiente gráfico. Esse serviço tem algum problema que impede que ele funcione sob as circunstâncias de inicialização do sistema. O que fazer?  Atachar o WinDbg no processo?</small></i>
</td></tr>
<tr><td>
<b><a href="2008-05.html#acessando_memoria_fisica_no_windbg">Acessando memória física no WinDbg</a></b>
<small><i>2008-05-01 blog computer  Como muitos devem saber, acessar memória virtual no WinDbg é coisa de criança, assim como em todo depurador decente. Se estamos falando de kernel mode então, nem se fala! A memória virtual é parte integrante do sistema operacional. Podemos saber mais sobre isso na apresentação do Strauss sobre [gerenciamento de memória no Windows].</small></i>
</td></tr>
<tr><td>
<img src="img/aprendendo_assembly_com_o_depurador_windbgxnotepad.png"/>
<b><a href="2008-04.html#aprendendo_assembly_com_o_depurador">Aprendendo assembly com o depurador</a></b>
<small><i>2008-04-11 blog computer  Além de servir para corrigir alguns [bugs escabrosos] o nosso bom e fiel amigo depurador também possui uma utilidade inusitada: ensinar assembly! A pessoa interessada em aprender alguns conceitos básicos da arquitetura do 8086 pode se exercitar na frente de um depurador 16 ou 32 bits sem ter medo de ser feliz.</small></i>
</td></tr>
<tr><td>
<img src="img/conversor_de_houaiss_para_babylon_parte_2_houaiss_babylon.png"/>
<b><a href="2008-04.html#conversor_de_houaiss_para_babylon_parte_2">Conversor de Houaiss para Babylon - parte 2</a></b>
<small><i>2008-04-08 blog projects computer  Após algumas semanas de suspense, chegamos finalmente à nossa segunda e última parte da saga do dicionário Houaiss. Como devem [estar lembrados], a primeira parte se dispôs a desmontar a ofuscação usada nos arquivos do dicionário para permitir nossa posterior análise, com o simples e justo objetivo de importá-lo para o Babylon, cujas funcionalidades de busca são bem superiores.</small></i>
</td></tr>
<tr><td>
<img src="img/windbg_a_distancia_windbg_remote2.gif"/>
<b><a href="2008-03.html#windbg_a_distancia">WinDbg a distância</a></b>
<small><i>2008-03-26 blog computer  Acho que o que mais me impressionou até hoje a respeito do WinDbg é a sua capacidade de depuração remota. Não há nada como depurar problemas sentado confortavelmente na sua cadeira de programador em frente à sua mesa de programador.</small></i>
</td></tr>
<tr><td>
<img src="img/depuracao_da_mbr_debug_debug.png"/>
<b><a href="2008-03.html#depuracao_da_mbr">Depuração da MBR</a></b>
<small><i>2008-03-24 blog computer  Dando continuidade a um artigo bem antigo sobre [depuração da BIOS usando SoftIce], como já vimos, podemos igualmente depurar a MBR após a chamada da INT13. Porém, devo atentar para o fato que, em algumas VMs, e sob determinadas condições do tempo e quantidade de ectoplasma na atmosfera, é possível que a máquina trave após o hot boot iniciado pelo depurador. Isso provavelmente tem cura usando o espaço de endereçamento alto da memória com a ajuda de aplicativos como LH e UMB.</small></i>
</td></tr>
<tr><td>
<img src="img/o_misterio_das_pilhas_diferentes_windbg_nerd.gif"/>
<b><a href="2008-03.html#o_misterio_das_pilhas_diferentes">O mistério das pilhas diferentes</a></b>
<small><i>2008-03-12 blog computer  Mal comecei a leitura do meu mais novo ["mother-fucker" livro] e já encontrei a solução para nunca mais viver o terror que vivi quando tive que testar minha engenharia reversa do artigo sobre o Houaiss. Se trata de uma simples questão que não sei por que não sigo todas as vezes religiosamente: configure seus símbolos corretamente.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-03.html#iteradores_nao_sao_constantes">Iteradores não são constantes</a></b>
<small><i>2008-03-04 blog computer  Um bug que já encontrei uma dúzia de vezes entre os novatos da STL é a utilização de iteradores como se eles não fossem mudar nunca. Porém, a verdade é bem diferente: iteradores se tornam inválidos sim, e com muito mais freqüência do que normalmente se imagina. Entre as situações em que iteradores podem mudar estão as seguintes:</small></i>
</td></tr>
<tr><td>
<b><a href="2008-02.html#quando_o_ponteiro_nulo_nao_e_invalido">Quando o ponteiro nulo não é inválido</a></b>
<small><i>2008-02-29 blog computer  Existe coisa mais prazerosa do que admitir um erro que foi cometido na mesma semana? Existe: quando você sabia que estava certo, mas resolveu usar o senso comum por falta de provas. Pois bem. O mesmo amigo que me recomendou que escrevesse sobre o assunto do ponteiro nulo achou um livro sobre [armadilhas em C] com um exemplo que demonstra exatamente o contrário: dependendo da plataforma, ponteiros nulos são sim válidos.</small></i>
</td></tr>
<tr><td>
<img src="img/conversor_de_houaiss_para_babylon_parte_1_cmd.gif"/>
<b><a href="2008-02.html#conversor_de_houaiss_para_babylon_parte_1">Conversor de Houaiss para Babylon - parte 1</a></b>
<small><i>2008-02-27 blog projects computer  Este artigo é sobre desmontar e montar novamente. Iremos descobrir como as entradas do dicionário Houaiss eletrônico estão gravadas em um primeiro momento, para depois remontarmos essa informação de maneira que ela possa ser usada em outro dicionário de uso mais flexível, o Babylon. Ou seja, este não é um guia de vandalismo. Estava apenas querendo usar um dicionário de qualidade excelente em outro dicionário cuja interface é muito boa.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-02.html#codigos_de_entrevista_o_ponteiro_nulo">Códigos de entrevista - o ponteiro nulo</a></b>
<small><i>2008-02-25 blog computer  Bom, parece que o "mother-fucker" wordpress ferrou com meu artigo sobre o Houaiss. Enquanto eu choro as pitangas aqui vai um outro artigo um pouco mais simples, mas igualmente interessante. > "Wanderley, tenho umas sugestões para teu blog.</small></i>
</td></tr>
<tr><td>
<img src="img/os_diferentes_erros_na_linguagem_c_linker.gif"/>
<b><a href="2008-02.html#os_diferentes_erros_na_linguagem_c">Os diferentes erros na linguagem C</a></b>
<small><i>2008-02-15 blog ccpp computer  Uma coisa que me espanta de vez em quando é o total desconhecimento por programadores mais ou menos experientes dos níveis de erros que podem ocorrer em um fonte escrito em C ou C++. Desconheço o motivo, mas desconfio que o fato de outras linguagens não terem essa divisão de processos pode causar alguma nivelação entre as linguagens e fazer pensar que o processo de compilação em C é como em qualquer outra linguagem.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-02.html#funky_dowhile">Funky do-while</a></b>
<small><i>2008-02-13 blog english computer  It's a known habit to use do-while constructions when there's a need to define a macro that has more than one command instead of using the { simple multicommand brackets }. What was never clear is why this is so.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-02.html#desconstruindo_ioccc">Desconstruindo IOCCC</a></b>
<small><i>2008-02-11 blog computer  Como alguns devem saber, e outros não (ou não deveriam), existe uma competição internacional para escolher quem escreve o código em C mais ofuscado. Isso mesmo. O evento se chama [The International Obfuscated C Code Contest] (IOCCC resumidamente) e costuma premiar anualmente os melhores "do ramo" com a chamada "menção desonrosa".</small></i>
</td></tr>
<tr><td>
<img src="img/process_monitor_e_o_monopolio_malcriado_monopoly_procmon_find2.png"/>
<b><a href="2008-02.html#process_monitor_e_o_monopolio_malcriado">Process Monitor e o monopólio malcriado</a></b>
<small><i>2008-02-05 blog computer  Uma das primeiras regras que aprendemos para manter a integridade do Windows é utilizá-lo somente com a conta de usuários restritos, o que evitaria, por exemplo, que um programa mal-intencionado instale um serviço ou driver, que teriam acesso às partes íntimas do sistema operacional.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-01.html#rmthread_rode_codigo_em_processo_vizinho">RmThread: rode código em processo vizinho</a></b>
<small><i>2008-01-28 blog computer  Aproveitando que utilizei a mesma técnica semana passada para desenvolver um vírus para Ethical Hacking, republico aqui este [artigo que já está mofando no Code Projet], mas que espero que sirva de ajuda pra muita gente que gosta de fuçar nos internals do sistema. Boa leitura!</small></i>
</td></tr>
<tr><td>
<b><a href="2008-01.html#otimizacao_em_funcoes_recursivas">Otimização em funções recursivas</a></b>
<small><i>2008-01-18 blog computer  O livro que estou lendo, Dominando Algoritmo com C, como o próprio nome diz, fala sobre algoritmos em C. Os primeiros capítulos são praticamente uma revisão para quem já programou em C, pois tratam de coisas que programadores com mais de cinco anos de casa devem ter na memória cachê (listas, pilhas, recursão, etc). Porém, tive uma agradável surpresa de achar um truque muito sabido que não conhecia, chamado de [tail recursion]. Fiz questão de testar nos dois compiladores mais conhecidos e eis o resultado.</small></i>
</td></tr>
<tr><td>
<img src="img/encontrando_as_respostas_do_flash_pops_flash_pops.gif"/>
<b><a href="2008-01.html#encontrando_as_respostas_do_flash_pops">Encontrando as respostas do Flash Pops</a></b>
<small><i>2008-01-16 blog computer  Existia uma série de jogos no sítio da UOL chamado Flash Pops onde você deve acertar o nome de filmes, programas de televisão, entre outros, que vão da década de 40 até a atualidade. É divertido e viciante fazer pesquisa na internet para encontrar os resultados, ainda mais quando já se é viciado em cinema. Ficamos jogando, eu e minha namorada, por semanas a fio. Quase chegamos a preencher tudo, e por um bom tempo ficamos travados para terminar. Então começamos a apelar para o Google e o IMDB até os limites do razoável. Nesse fim de semana, por exemplo, chegamos a assistir um filme de madrugada onde tocou rapidamente um trecho de uma das músicas que faltava no jogo sobre televisão. No dia seguinte procuramos a trilha sonora do filme, ouvimos faixa a faixa e procuramos o nome da música no Google, para finalmente encontrar o resultado.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-01.html#analisando_dumps_com_windbg_e_ida">Analisando Dumps com WinDbg e IDA</a></b>
<small><i>2008-01-10 blog computer  Apesar de ser recomendado que 100% dos componentes de um software esteja configurado corretamente para gerar símbolos na versão release, possibilitando assim a visualização do nome das funções internas através de um arquivo de dump (despejo) gerado na ocorrência de um crash, essa verdade só ocorre em 80% das vezes. Quis Murphy que dessa vez a única parte não "simbolizada" fosse a que gerou a tela azul em um Intel Quad Core que estou analisando esses dias.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-12.html#curiosidades_inuteis_o_operador_de_subscrito_em_c">Curiosidades inúteis: o operador de subscrito em C++</a></b>
<small><i>2007-12-27 blog computer  Este artigo é uma reedição de meu blogue antigo, guardado para ser republicado durante minhas miniférias. Esteja à vontade para sugerir outros temas obscuros sobre a linguagem C ou C++ de sua preferência. Boa leitura!</small></i>
</td></tr>
<tr><td>
<b><a href="2007-12.html#o_que_acontece_quando_o_contador_estoura">O que acontece quando o contador estoura</a></b>
<small><i>2007-12-25 blog computer  Dois conceitos de programação relacionados a limites computacionais são bem conhecidos do programador: o famigerado overflow e o não-tão-famoso underflow (embora seja fácil imaginar que ele é o oposto do primeiro). O primeiro ocorre quando somamos a uma variável inteira não-nula um valor cujo resultado não consegue ser representado pelo tamanho de memória usado para armazenar esse tipo inteiro (que pode ser um caractere, um inteiro curto, inteiro longo e por aí vai). O underflow, por outro lado (outro lado mesmo), é o resultado de uma subtração que não pode ser representado pelo número de bits do seu tipo inteiro.</small></i>
</td></tr>
<tr><td>
<img src="img/banco_de_dados_no_c_builder_cppb_dbgrid.png"/>
<b><a href="2007-12.html#banco_de_dados_no_c++_builder">Banco de dados no C++ Builder</a></b>
<small><i>2007-12-21 blog cppbuilder computer  Um banco de dados é qualquer lugar onde podemos ler e escrever informação geralmente persistente. Pode ser um arquivo INI, uma estrutura binária ou uma plantação de servidores para fazer busca na internet. O uso de banco de dados em programação é mais que essencial, pois permite que armazenemos os resultados de um processamento e utilizemos esses mesmos resultados em futuras execuções.</small></i>
</td></tr>
<tr><td>
<img src="img/drag_and_drop_no_c_builder_trocatroca.gif"/>
<b><a href="2007-12.html#drag_and_drop_no_c++_builder">Drag and drop no C++ Builder</a></b>
<small><i>2007-12-19 blog computer  O sistema de drag and drop do C++ Builder é muito fácil de usar, integrado que está com o sistema de classes e objetos do framework. Tanto para o objeto de drag quanto para o objeto de drop tudo que temos que fazer é definirmos a propriedade DragMode para dmAutomatic como mostra a figura. Isso fará com que toda a troca de mensagens seja manipulada automaticamente pela VCL.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-12.html#sizeof_de_novo">Sizeof (de novo)</a></b>
<small><i>2007-12-17 blog computer  Algumas coisas em C parecem tão simples na programação do dia-a-dia que em alguns momentos podem existir situações confusas e misteriosas. O uso obscuro do operador sizeof, por exemplo, pode dar margem a interpretações erradas a respeito do que está acontecendo por debaixo dos panos. Apesar do padrão ter sido elaborado para tentar tornar a linguagem uma coisa intuitiva e de fácil dedução, isso não acontece todas as vezes.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-12.html#debug_remoto_no_c_builder">Debug remoto no C++ Builder</a></b>
<small><i>2007-12-13 blog debugging cppbuilder computer  Esse é um detalhe que pode passar despercebido da maioria da população Borland, mas o Builder, assim como o Visual Studio, possui sua suíte para depuração remota. E tudo o que você precisa fazer é instalar um pacote no cliente.</small></i>
</td></tr>
<tr><td>
<img src="img/gerenciamento_de_janelas_em_c_builder_spyxx_window_search_result.png"/>
<b><a href="2007-12.html#gerenciamento_de_janelas_em_c++_builder">Gerenciamento de janelas em C++ Builder</a></b>
<small><i>2007-12-11 blog cppbuilder computer  As janelas criadas no C++ Builder são equivalentes às janelas criadas pela API, com o detalhe que a VCL gerencia tudo automaticamente. Isso não quer dizer que não podemos tomar controle de tudo. Quer dizer que não precisamos.</small></i>
</td></tr>
<tr><td>
<img src="img/interacao_entre_controles_no_c_builder_listadecompras.gif"/>
<b><a href="2007-12.html#interacao_entre_controles_no_c++_builder">Interação entre controles no C++ Builder</a></b>
<small><i>2007-12-05 blog cppbuilder computer  Como próxima lição da nossa jornada Borland, vamos aprender a fazer os controles de um form interagirem entre si com a força do pensamento. Para essa proeza precisaremos de:  - Dois TButtons  - Um TEdit</small></i>
</td></tr>
<tr><td>
<b><a href="2007-12.html#conceitos_basicos_na_programacao_com_c++_builder">Conceitos básicos na programação com C++ Builder</a></b>
<small><i>2007-12-03 blog cppbuilder computer  No projeto que é criado quando iniciamos a IDE três arquivos-fonte são gerados: Project1.cpp, Unit1.cpp e Unit1.h. Desses três, vamos analisar o primeiro:     #include <vcl.h>          WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int)</small></i>
</td></tr>
<tr><td>
<img src="img/desenhando_em_c_builder_amobuilder.gif"/>
<b><a href="2007-11.html#desenhando_em_c++_builder">Desenhando em C++ Builder</a></b>
<small><i>2007-11-29 blog cppbuilder computer  Uma das partes mais fáceis e divertidas de se mexer no C++ Builder é a que lida com gráficos. A abstração da VCL toma conta da alocação e liberação dos objetos gráficos da GDI e nos fornece uma interface para desenhar linhas e figuras geométricas, mexer com bitmaps, usar fontes etc. Concomitantemente, temos acesso ao handles "crus" da Win32 API para que possamos chamar alguma função esotérica necessária para o seu programa, o que nos garante flexibilidade suficiente.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-11.html#carregando_dlls_arbitrarias_pelo_windbg_parte_2">Carregando DLLs arbitrárias pelo WinDbg ou como escrever script para WinDbg</a></b>
<small><i>2007-11-27 blog computer  Como pudemos ver no [artigo anterior] o processo para carregar uma DLL pelo WinDbg é muito extenso, enfadonho e sujeito a erros. Além de desatualizado (com comandos de assembly 32 bits). Por esse motivo, e para tornar as coisas mais divertidas, resolvi transformar tudo aquilo em um simples script que pode ser executado digitando apenas uma linha. Tenha em mente que este artigo continua desatualizado usando assembly 32 bits e hoje é uma mera curiosidade para aprendizado do passado. E se trata do meu primeiro script grande para o WinDbg, por isso, peço que tenham dó de mim =).</small></i>
</td></tr>
<tr><td>
<b><a href="2007-11.html#carregando_dlls_arbitrarias_pelo_windbg">Carregando DLLs arbitrárias pelo WinDbg</a></b>
<small><i>2007-11-23 blog computer  Durante meus testes para a correção de um bug me deparei com a necessidade de carregar uma DLL desenvolvida por mim no processo depurado. O detalhe é que o processo depurado é de terceiros e não possuo o fonte. Portanto, as opções para mim mais simples são:</small></i>
</td></tr>
<tr><td>
<img src="img/historia_do_windows_parte_51_windows_client_server.gif"/>
<b><a href="2007-11.html#historia_do_windows_parte_51">História do Windows - parte 5.1</a></b>
<small><i>2007-11-19 blog computer  Chega às lojas no dia 25 de outubro de 2001 a unificação entre as plataformas de uso doméstico e corporativo do sistema. O Windows XP, de Windows eXPerience, usa o kernel de 32 bits de seus antecessores Windows NT e Windows 2000. É vendido em duas edições: Home e Professional Edition. O design do sistema foi totalmente remodulado para suportar ao mesmo tempo a facilidade de uso do usuário doméstico e a robustez e confiabilidade dos clientes corporativos. Essa é minha versão favorita da [História do Windows] e junto do Windows 7 uma das edições mais robustas já feitas.</small></i>
</td></tr>
<tr><td>
<img src="img/detectando_hooks_globais_no_windbg_codigo_malicioso.gif"/>
<b><a href="2007-11.html#detectando_hooks_globais_no_windbg">Detectando hooks globais no WinDbg (SetWindowsHookEx)</a></b>
<small><i>2007-11-09 blog computer  Nada como um comando prático para aprender rapidamente uma técnica. Nesse caso, tive que usar o seguinte comando para localizar o momento em que um executável instala um hook global: bp user32!SetWindowsHookExA "j poi(esp+4*4) 'g' ; '.echo *** GLOBAL HOOK ***; g'".</small></i>
</td></tr>
<tr><td>
<img src="img/ponteiro_de_metodo_qual_this_e_usado_fuzzycall.gif"/>
<b><a href="2007-11.html#ponteiro_de_metodo_qual_this_e_usado">Ponteiro de método: qual this é usado?</a></b>
<small><i>2007-11-07 blog computer  Depois de publicado o artigo anterior sobre ponteiros de métodos surgiu uma dúvida muito pertinente do autor do blogue [CodeBehind], um escovador de bits disfarçado de programador .NET: qual objeto que vale na hora de chamar um método pelo ponteiro?</small></i>
</td></tr>
<tr><td>
<b><a href="2007-11.html#ponteiros_de_metodo_conceito_fundamental">Ponteiros de método: conceito fundamental</a></b>
<small><i>2007-11-05 blog computer  Diferente de ponteiros de função globais ou estáticas, que são a grosso modo ponteiros como qualquer um, os ponteiros de método possuem uma semântica toda especial que costuma intimidar até quem está acostumado com a aritmética de ponteiros avançada. Não é pra menos: é praticamente uma definição à parte, com algumas limitações e que deixa a desejar os quase sempre criativos programadores da linguagem, que vira e mexe estão pedindo mudanças no C++0x.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-10.html#protecao_dos_membros_protected">Proteção dos membros protected</a></b>
<small><i>2007-10-26 blog ccpp computer  Quando queremos que um membro de nossa classe seja visível apenas dentro dos métodos da classe e dentro dos métodos das classes derivadas dessa classe usamos o nível de proteção protected. Isso, é claro, não quer dizer que uma classe derivada vá ter acesso aos membros protegidos de outra:</small></i>
</td></tr>
<tr><td>
<b><a href="2007-10.html#typeid_e_os_perigos_do_nao_polimorfismo">Typeid e os perigos do não-polimorfismo</a></b>
<small><i>2007-10-24 blog ccpp computer  Quando usamos o operador typeid geralmente desejamos conhecer informações sobre o tipo exato do objeto que temos em mãos, independente da hierarquia de herança a qual seu tipo pertença. Só que por ignorar, assim como o [sizeof], que esse operador possui duas caras, às vezes damos com os burros n'água e compramos gato por lebre. Não é pra menos. Uma sutil diferença entre classes polimórficas e estáticas pode dar aquele susto que só C++ pode proporcionar.</small></i>
</td></tr>
<tr><td>
<img src="img/guia_basico_para_programadores_de_primeiro_breakpoint_debug.png"/>
<b><a href="2007-10.html#guia_basico_para_programadores_de_primeiro_breakpoint">Guia básico para programadores de primeiro breakpoint</a></b>
<small><i>2007-10-22 blog computer  Aproveitando um dos últimos artigos que fala sobre [conceitos básicos de programação], lembro que, tão importante quanto programar é possuir habilidades básicas de depuração, uma arte por muitos programadores ignorada.</small></i>
</td></tr>
<tr><td>
<img src="img/por_que_minha_dll_travou_loader_lock.gif"/>
<b><a href="2007-10.html#por_que_minha_dll_travou">Por que minha DLL travou?</a></b>
<small><i>2007-10-18 blog computer  O resumo da ópera é que o código do Windows chamador do DllMain das DLLs carregadas/descarregadas utiliza um objeto de acesso exclusivo (leia "mutex") para sincronizar as chamadas. O resultado é que, em um processo, apenas um DllMain é chamado em um dado momento. Esse objeto é chamado de loader lock na documentação da Microsoft.</small></i>
</td></tr>
<tr><td>
<img src="img/guia_basico_para_programadores_de_primeiro_int_main_for.gif"/>
<b><a href="2007-10.html#guia_basico_para_programadores_de_primeiro_int_main">Guia básico para programadores de primeiro int main</a></b>
<small><i>2007-10-16 blog computer  > Vou aproveitar que meu amigo DQ publicou um artigo muito bom sobre [como fazer programas fáceis de manter] (merece ser lido!) e vou republicar um artigo do blogue antigo sobre o básico do básico para quem deseja entender como os programas funcionam. Não é nada sofisticado, apenas alguns conceitos comuns que, se você deseja ser programador, deveria procurar saber.</small></i>
</td></tr>
<tr><td>
<img src="img/the_c_programming_language_binary_tree.gif"/>
<b><a href="2007-10.html#the_c_programming_language">A Linguagem de Programação C: O Livro</a></b>
<small><i>2007-10-12 blog computer books ccpp  O clássico de Ritchie e Kernighan, criadores da linguagem C, não foi meu primeiro livro de programação. E nem deveria ser. Não o recomendo para iniciantes, pois é necessário possuir algum conhecimento e prática para realmente aproveitar os conceitos desse livro.</small></i>
</td></tr>
<tr><td>
<img src="img/historia_do_windows_parte_50_windows_architecture.png"/>
<b><a href="2007-10.html#historia_do_windows_parte_50">História do Windows - parte 5.0</a></b>
<small><i>2007-10-08 blog computer  Em novembro de 1998 (apenas para parceiros Microsoft) é lançada a versão 5.0 do Windows NT, conhecida como Windows 2000. Melhorias significativas foram feitas no acesso à internet, intranet e extranet. Aplicações de gerenciamento se integram fortemente e a grande novidade em termos de estruturação de dados é o Active Directory, uma tecnologia compatível com o conceito de Distributed File System, que viabiliza uma nova forma das empresas organizarem seus dados de maneira mais transparente à rede. Assim começou a [História do Windows] para redes de gente grande.</small></i>
</td></tr>
<tr><td>
<img src="img/debug_da_bios_com_o_softice_16_bits_myos_start.png"/>
<b><a href="2007-10.html#debug_da_bios_com_o_softice_16_bits">Debug da BIOS com o SoftIce 16 bits</a></b>
<small><i>2007-10-02 blog computer  Para quem acha que ainda não desceu demais o nível existe um [ótimo artigo] no Code Project de S. Z. Keller (aka ShalomZ) sobre como construir seu próprio sistema operacional. É simples, direta e empolgante a maneira com que ele explica e trata os detalhes básicos, desde quando o computador é ligado até quando o boot loader carrega e entrega o controle de execução. Eu mesmo fiz o teste com a imagem que foi disponibilizada para download e funcionou direitinho. Agora esse meu artigo se dispõe a explicar como você pode fazer para depurar o processo de load do seu primeiro sistema operacional.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-09.html#why_is_my_dll_locked">Why is my DLL locked?</a></b>
<small><i>2007-09-24 blog english computer  The Windows code responsible to call DllMain for each loaded and unloaded DLLs uses an exclusive access object, the so-called mutex, to synchronize its calls. The result is that inside a process just one DllMain can be called at a given moment. This object-mutex is called "loader lock" into the Microsoft documentation.</small></i>
</td></tr>
<tr><td>
<img src="img/hook_de_com_no_windbg_iunknown_breakpoint.png"/>
<b><a href="2007-09.html#hook_de_com_no_windbg">Hook de COM no WinDbg</a></b>
<small><i>2007-09-18 blog computer  Continuando com o tema hooks no WinDbg vamos aqui "hookear" e analisar as chamadas de métodos de um objeto COM. O que será feito aqui é o mesmo experimento feito para uma palestra de engenharia reversa que apresentei há um tempo atrás, mas com as opções de pause, rewind, replay e câmera lenta habilitadas.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-09.html#aquisicao_de_recurso_e_inicializacao">Aquisição de recurso é inicialização</a></b>
<small><i>2007-09-14 blog ccpp computer  O título desse artigo é uma técnica presente no paradigma da programação em C++, razão pela qual não temos o operador finally. A idéia por trás dessa técnica é conseguirmos usar recursos representados por objetos locais de maneira que ao final da função esses objetos sejam destruídos e, junto com eles, os recursos que foram alocados. Podemos chamar de recursos aquele arquivo que necessita ser aberto para escrita, o bitmap que é exibido na tela, o ponteiro de uma interface COM, etc. O nosso exemplo é sobre arquivos:</small></i>
</td></tr>
<tr><td>
<b><a href="2007-09.html#antidebug_detectando_attach">Antidebug: Detectando Attach</a></b>
<small><i>2007-09-10 blog closed antidebug projects computer  Hoje foi um belo dia para engenharia reversa e análise de proteções. Dois ótimos programas vieram ao meu conhecimento: um [monitor de chamadas de API] e um [monitor de chamadas de COM] (complementando o primeiro, que não monitora funções depois que CoCreateInstance foi chamado). Além de que no site do primeiro programa - de algum entusiasta do bom e velho Assembly Win32, diga-se de passagem - encontrei o código-fonte para mais uma técnica antidebugging, o que nos leva de volta para a já consagrada série de técnicas antidepuração.</small></i>
</td></tr>
<tr><td>
<img src="img/historia_do_windows_parte_40_threads_pwdbreaker_windows.png"/>
<b><a href="2007-09.html#historia_do_windows_parte_40">História do Windows - parte 4.0</a></b>
<small><i>2007-09-04 blog computer  Em meio a uma febre de consumismo, no dia 24 de agosto de 1995, foi lançado a revolução no sistema gráfico da Microsoft: a interface do Windows 95. Ela foi considerada muito mais amigável que suas versões anteriores. Ainda possuía a vantagem de não necessitar mais de uma instalação prévia do DOS, passou a suportar nomes de arquivos longos, incluir suporte a TCP/IP e dial-up networking integrados. Muitas mudanças foram feitas no sistema em si, como a passagem para 32 bits (como já vimos, parcial) e o novo conceito de threads, que é o que veremos com mais detalhes neste artigo.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-08.html#hook_de_api_no_windbg">Hook de API no WinDbg</a></b>
<small><i>2007-08-29 blog computer  Basicamente existem duas maneiras de um executável obter o endereço de uma função API do Windows: ou ele usa uma lib de interface com a DLL (o chamado "link estático") ou ele chama a função GetProcAddress explicitamente (1).</small></i>
</td></tr>
<tr><td>
<img src="img/antidebug_ocupando_a_debugport_debugport.gif"/>
<b><a href="2007-08.html#antidebug_ocupando_a_debugport">Antidebug: ocupando a DebugPort</a></b>
<small><i>2007-08-23 blog closed projects computer  Quando um depurador inicia um processo para ser depurado ou, o caso abordado por este artigo, se conecta em um processo já iniciado, as comunicações entre esses dois processos é feita através de um recurso interno do Windows chamado de LPC (Local Procedure Call). O sistema cria uma "porta mágica" de comunicação específica para a depuração e os eventos trafegam por meio dela.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-08.html#erro_de_compilacao_funcoes_muito_novas_na_win32_api">Erro de compilação: funções muito novas na Win32 API</a></b>
<small><i>2007-08-21 blog computer  Quando fala-se em depuração geralmente o pensamento que vem é de um código que já foi compilado e está rodando em alguma outra máquina e gerando problemas não detectados nos testes de desenvolvedor. Mas nem sempre é assim. Depuração pode envolver problemas durante a própria compilação. Afinal de contas, se não está compilando, ou foi compilado errado, é porque já existem problemas antes mesmo da execução começar.</small></i>
</td></tr>
<tr><td>
<img src="img/historia_da_linguagem_c_parte_2_kthompson_dritchie.jpg"/>
<b><a href="2007-08.html#historia_da_linguagem_c_parte_2">História da Linguagem C: Parte 2</a></b>
<small><i>2007-08-15 blog ccpp computer  No princípio... não, não, não. Antes do princípio, quando C era considerada a terceira letra do alfabeto e o que tínhamos eram linguagens experimentais para todos os lados, dois famigerados senhores dos Laboratórios Bell, K. Thompson e D. Ritchie, criaram uma linguagem chamada B. E B era bom.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-08.html#antidebug_interpretacao_baseada_em_excecao_parte_2">Antidebug: interpretação baseada em exceção (parte 2)</a></b>
<small><i>2007-08-09 blog closed projects computer  No [primeiro artigo] vimos como é possível "enganar" o depurador através de exceções e assim fazer o atacante perder um tempo considerável tentando se desvencilhar dos breakpoints de mentira. Porém, vimos também que essa é uma solução difícil de manter no código-fonte, além de possuir o ponto fraco de ser facilmente contornada se descoberta. Agora é a hora de tornar as coisas mais fáceis de manter e ao mesmo tempo garantir maior dificuldade mesmo que o atacante descubra o que está acontecendo debaixo do seu nariz.</small></i>
</td></tr>
<tr><td>
<img src="img/historia_do_windows_parte_351_windows_workstation.jpg"/>
<b><a href="2007-08.html#historia_do_windows_parte_351">História do Windows - parte 3.51</a></b>
<small><i>2007-08-07 blog computer  Bem-vindos. Esta é a série [História do Windows]. Nos anos 90, a relação IBM/Microsoft era muito próxima por causa do desenvolvimento do OS/2, o projeto de um novo sistema operacional. As empresas cooperavam entre si e tinham acesso uma ao código da outra. A Microsoft desejava avançar seu desenvolvimento no Windows, enquanto a IBM desejava que todo trabalho futuro fosse baseado em OS/2. Para resolver essa tensão as duas combinaram que a IBM iria desenvolver o OS/2 versão 2.0 para substituir o OS/2 versão 1.3 e o Windows v3.0, enquanto a Microsoft iria desenvolver um novo sistema operacional, o OS/2 versão 3.0 para depois suceder ao OS/2 anterior. Com tudo combinado entre as grandes corporações, é lógico que esse acordo foi por água abaixo.</small></i>
</td></tr>
<tr><td>
<img src="img/historia_do_windows_parte_30_windows_message_loop.gif"/>
<b><a href="2007-08.html#historia_do_windows_parte_30">História do Windows - parte 3.0</a></b>
<small><i>2007-08-03 blog computer  Em 22 de maio de 1990 a versão 3.0 do Windows foi lançada. Foi melhorado o gerenciador de programas e o sistema de ícones, além de um novo gerenciador de arquivos e suporte a 16 cores. Entre as mudanças internas podemos citar a velocidade e a confiabilidade. Como a partir dessa versão apareceram muitos desenvolvedores que passaram a suportar a plataforma, o número de programas disponíveis aumentou, o que conseqüentemente fez com que as vendas alavancassem. Três milhões de cópias foram vendidas apenas no primeiro ano, e assim o Windows se tornou padrão nos computadores domésticos. Quando a versão 3.1 foi lançada, em 6 de abril de 1992, mais três milhões de cópias foram vendidos em apenas dois meses.</small></i>
</td></tr>
<tr><td>
<img src="img/historia_da_linguagem_c_parte_1_ccpp_build_steps.gif"/>
<b><a href="2007-08.html#historia_da_linguagem_c_parte_1">História da Linguagem C: Parte 1</a></b>
<small><i>2007-08-01 blog ccpp computer  Confesso que adoro estudar sobre a história da linguagem C. Essa verdadeira adoração pela linguagem me fez estudar suas precursoras, como as linguagens BCPL e B. Posso dizer que todo esse conhecimento, no final das contas, valeu a pena. Hoje entendo muito melhor as decisões tomadas na criação da linguagem e, principalmente, a origem de algumas idiossincrasias e boas idéias que permaneceram até hoje.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-07.html#c_and_c++_operators_precedence_table">C and C++ Operators Precedence Table</a></b>
<small><i>2007-07-30 blog english ccpp computer  > Wanderley, your explanation about [why a program compiles in C++ and not in C] seems to me logic and correct, but gave me some doubts, because I always learned that the C and C++ operator precedence are the same thing. I checked out the Appendix A in the "C ++ - How To Program" (sixth edition) and the book table is equal to the C operators precedence table and it is different from the C++ precedence table presented by you in the article. I went to the internet and found out in two websites the table and both are equal to the book table:</small></i>
</td></tr>
<tr><td>
<b><a href="2007-07.html#antidebug_interpretacao_baseada_em_excecao_parte_1">Antidebug: interpretação baseada em exceção (parte 1)</a></b>
<small><i>2007-07-20 blog closed projects computer  Um depurador utiliza breakpoints para "paralisar" momentaneamente a execução do programa sendo depurado. Para isso ele se utiliza de uma bem conhecida instrução conhecida como int 3. Essa instrução gera uma exceção -- exceção de breakpoint -- que é capturada pelo sistema operacional e repassada para o código de tratamento dessa exceção. Em programas sendo depurados esse código está localizado no depurador. Em programas "livres" esse código normalmente não existe e ao acontecer essa exceção o aplicativo simplesmente "capota".</small></i>
</td></tr>
<tr><td>
<b><a href="2007-07.html#what_happens_inside_the_sizeof_operator">What happens inside the sizeof operator</a></b>
<small><i>2007-07-16 blog english ccpp computer  The question: how to get the size of a struct member without declaring it as a variable in memory? In pseudocode:     static const size_t FIELD_SIZE_MSGID = 15;          struct FEEDER_RECORD_HEADER     {</small></i>
</td></tr>
<tr><td>
<b><a href="2007-07.html#desejo_insano_de_programar_no_kernel">Desejo insano de programar no kernel</a></b>
<small><i>2007-07-12 blog essays  Muitas vezes meus amigos (um em particular) me perguntam por que não me interesso em programar em kernel mode, como se isso fosse um objetivo a ser alcançado por qualquer programador em user mode. Bom, não é.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-07.html#precedence_difference">Precedence difference</a></b>
<small><i>2007-07-10 blog english ccpp computer  Once upon a time my old friend Kabloc wrote this little and "harmless" function in order to print the multiplication table:     #include <stdio.h>          int main()     {       int f1,f2,s=0;          for( f1 = 1; (f1 == 11 && s != 5) ? s=5, f1=0, putchar(10) : ( f1 <= 10 ) ? f1 = f1 : f1 = 12, f1 <= 11 ; f1++ )</small></i>
</td></tr>
<tr><td>
<img src="img/historia_do_windows_parte_20_windows2.jpg"/>
<b><a href="2007-07.html#historia_do_windows_parte_20">História do Windows - parte 2.0</a></b>
<small><i>2007-07-04 blog computer  > Eu seu, eu sei. A maioria dos meus leitores odiou o tema [História do Windows] na era paleozóica. Porém, como eu disse na parte 1.0, estou apenas satisfazendo a outra parte de leitores que procurou no Google por esse tema e acabou caindo no meu antigo blog. Mas vejamos o lado bom: a partir da próxima versão iremos destrinchar a API do sistema, entendendo o porquê das coisas serem como elas são. No momento os deixo apenas com história, pois é desconhecido para mim como funcionavam os primeiros rabiscos do MS-DOS Shell, mais conhecido como Windows/386. Bom divertimento!</small></i>
</td></tr>
<tr><td>
<b><a href="2007-07.html#introducao_ao_softice">Introdução ao SoftICE</a></b>
<small><i>2007-07-02 blog computer  O que acontece quando você precisa depurar um programa e não tem o Visual Studio instalado na máquina onde o problema está ocorrendo? Ora, para isso que existe o Remote Debugging. Eu uso direto. Você só precisa rodar um pequeno programa na máquina que vai ser depurada e abrir uma porta ou duas. O resto o Visual Studio da máquina que vai depurar faz.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-06.html#a_inteligencia_do_if_parte_2">A Inteligência do if: Parte 2</a></b>
<small><i>2007-06-29 blog closed assembly philosophy programming computer  Vimos na [primeira parte] desse artigo como o if revolucionou o mundo da computação ao trazer um salto que depende de condições anteriores e, portanto, depende do estado do programa. A ele chamamos de salto condicional. Também vimos como o resto das construções lógicas de uma linguagem são apenas derivações montadas a partir de saltos condicionais e incondicionais. Nesta segunda parte veremos como implementar um saldo condicional baseando-se no fato de que o computador pode apenas realizar operações matemáticas. Afinal de contas, um computador não "pensa".</small></i>
</td></tr>
<tr><td>
<img src="img/historia_do_windows_parte_10_windows1.png"/>
<b><a href="2007-06.html#historia_do_windows_parte_10">História do Windows - parte 1.0</a></b>
<small><i>2007-06-26 blog history windows computer  Devido à grande procura através de mecanismos de busca (vulgo Google), estarei republicando esse artigo dividido em partes (até porque existem partes não acabadas), cada parte descrevendo um conceito geral do que representou cada versão do sistema operacional. Bem-vindos ao [História do Windows].</small></i>
</td></tr>
<tr><td>
<b><a href="2007-06.html#disassembling_the_array_operator">Disassembling the array operator</a></b>
<small><i>2007-06-22 blog code english ccpp computer  Arrays are fascinating in C language because they are so simple and so powerful at the same time. When we start to really understand them and realize all its power we are very close to understand another awesome feature of the language: pointers.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-06.html#a_inteligencia_do_if_parte_1">A Inteligência do if: Parte 1</a></b>
<small><i>2007-06-18 blog closed assembly philosophy programming computer  No nível mais baixo, podemos dizer que as instruções de um computador se baseiam simplesmente em cálculos matemáticos e manipulação de memória. E entre os tipos de manipulação existe aquela que muda o endereço da próxima instrução que será executada. A essa manipulação damos o nome de salto.</small></i>
</td></tr>
<tr><td>
<img src="img/about_brand.png"/>
<b><a href="2007-06.html#about">About</a></b>
<small><i>2007-06-14 blog  Quer entrar em contato? Mande o bom e velho [email]. Quer um [resumo profissional]? ![Eu mesmo!](about_author.jpg) Wanderley Caloni é um [programador] C/C++ especializado em backend para Windows que decidiu ter seu próprio blogue técnico a pedidos insistentes do seu amigo Rodrigo Strauss, que estava blogando já fazia alguns anos no www.1bit.com.br. Busquei mantê-lo atualizado por esses longos anos de programação, depuração e transpiração com minhas peripécias do dia-a-dia. Eventualmente me tornei crítico de cinema e juntei aqui essas duas escovas de dentes, textos técnicos e cinematográficos, o que acabou tornando o saite gigante a ponto de eu precisar trocar meu static site generator duas vezes. Hoje uso AWK. Sim, os clássicos acabam quebrando um galho =).</small></i>
</td></tr>
</table>
<span style="float: left;">
</span>
</div>
</div>
</section>
<footer class="footer">
<div class="container">
</div>
<div class="intentionally-blank"></div>
</footer>
</body>
</html>
