<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Blogue do Caloni</title>
<meta name="author" content="Caloni" />
<meta name="generator" content="https://github.com/caloni/journal">
<meta property="og:title" content="Blogue do Caloni"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="http://www.caloni.com.br"/>
<meta property="og:image" content="/blog/img/about-brand.png"/>
<meta property="og:description" content="Write for computers, people and food."/>
<link href="/blog/index.xml" rel="feed" type="application/rss+xml" title="Blogue do Caloni"/>
<link rel="stylesheet" type="text/css" href="/blog/css/custom.css"/>
<link rel="stylesheet" type="text/css" href="/blog/css/jquery-ui.css"/>
<script src="/blog/js/jquery-1.12.4.js"></script>
<script src="/blog/js/jquery-ui.js"></script>
<script src="/blog/js/copy_clipboard.js"></script>
<script>
var quick_search_posts = [ 
 ]; 
</script>
<script src="/blog/js/quick_search.js"></script>
<script src="/blog/js/list.js"></script>
<link rel="icon" href="/blog/img/favicon.ico"/>
</head>
<body style="min-height:100vh;display:flex;flex-direction:column">
<nav class="navbar has-shadow is-white"
role="navigation" aria-label="main navigation">
<div class="container">
<div class="navbar-brand">
&nbsp;
<a class="navbar-item" href="index.html">
<div class="is-4"><b>Blogue do Caloni</b></div>
</a>
</div>
</div>
</nav>
<div class="container">
<div class="column">
<div style="min-height:56vh">
<div style="padding-bottom: 1em;"></div>
<span id="antidebug_ocupando_a_debugport" title="Antidebug: ocupando a DebugPort"/></span>
<section id="section_antidebug_ocupando_a_debugport">
<p class="title">Antidebug: ocupando a DebugPort</p>
<span class="title-heading">Caloni, 2007-08-23 computer projects blog</span>

<p>Quando um depurador inicia um processo para ser depurado ou, o caso abordado por este artigo, se conecta em um processo já iniciado, as comunicações entre esses dois processos é feita através de um recurso interno do Windows chamado de LPC (Local Procedure Call). O sistema cria uma "porta mágica" de comunicação específica para a depuração e os eventos trafegam por meio dela.</p>

<p>Entre esses eventos podemos citar os seguintes:</p>

<pre>
   
</pre>
<ul><li>Breakpoints disparados.</li>
<li>Exceções lançadas.</li>
<li>Criação/saída de threads.</li>
<li>Load/unload de DLLs.</li>
<li>Saída do processo.</li></ul>
<p>No caso de se conectar em um processo já existente, é chamada a função da API DebugActiveProcess. A partir dessa chamada, se retornado sucesso, o processo que depura agora está liberado para ficar chamando continuamente a função API WaitForDebugEvent. E o código se resume a isto:</p>

<pre>
   void DebugLoop()
   {
     bool exitLoop = false;
   
     while( ! exitLoop )
     {
       DEBUG_EVENT debugEvt;
   
       WaitForDebugEvent(&amp;debugEvt, 
         INFINITE);
   
       switch( debugEvt.dwDebugEventCode )
       {
         // This one...
   
         // That one...
   
         // Process is going out.
         case EXIT_PROCESS_DEBUG_EVENT:
           exitLoop = true;
           break;
       }
   
       // Unfreeze the thread who sent the debug event.
       // Otherwise, it stays frozen forever!
       ContinueDebugEvent(debugEvt.dwProcessId, 
         debugEvt.dwThreadId, 
         DBG_EXCEPTION_NOT_HANDLED);
     }
   } 
</pre>
<p>O detalhe interessante desse processo de comunicação depurador/depurado é que um processo só pode ser depurado por apenas UM depurador. Ou seja, enquanto houver um processo depurando outro, os outros processos só ficam na vontade.</p>

<p>Partindo desse princípio, podemos imaginar uma proteção baseada nessa exclusividade, criando um processo protetor que conecta no processo protegido e o "depura". Fiz um código de exemplo que faz justamente isso: ele atacha em um processo para depurá-lo (basta passar o PID como parâmetro) e não deixa mais outro depurador ocupar a debug port. Os passos para testá-lo são:</p>

<p>  1. Compilar o código.</p>

<p>  2. Executar o notepad (ou qualquer outra vítima).</p>

<p>  3. Obter seu PID (Process ID).</p>

<p>  4. Executar o protetor passando o PID como parâmetro.</p>

<p>  5. Tentar "atachar" no processo através do Visual C++.</p>

<p>Após o processo de attach, a porta de debug é ocupada, e a comunicação entre depurador e depurado é feita através do LPC. Abaixo uma pequena ilustração de como as coisas ocorrem:</p>

<img src="/blog/img/antidebug_ocupando_a_debugport_debugport.gif"/>

<p>Basicamente o processo fica recebendo eventos de debug (através da fila de mensagens LPC) continuamente até o evento final, o de final de processo. Note que se alguém tentar derrubar o processo que depura o processo depurado cai junto.</p>

<p>O ponto forte desse tipo de proteção é que não afeta a compreensão e a legibilidade do código. De fato o próprio código que "protege" está em outro processo. O fraco, eu diria, é a sua alta visibilidade. Todo mundo que tentar atacar verá dois processos serem criados; e isso já faz pensar...</p>

<p>Por isso é necessário pensar bem na implementação. Particularmente uma coisa a ser bem arquitetada é a união entre depurador e depurado. Quanto melhor essas duas peças forem encaixadas, tão mais difícil será para o atacante separá-las. Uma idéia adicional é utilizar a mesma técnica na direção oposta, ou seja, o processo depurado se atachar no depurador.</p>

<p>Dessa vez não vou afirmar que, uma vez entendido o problema, a solução torna-se óbvia. Isso porque ainda não pensei o suficiente para achar uma solução óbvia. Idéias?</p>

</section>

<span style="float: left;">
 <a href="historia_da_linguagem_c_parte_2.html">[historia_da_linguagem_c_parte_2]</a>
</span>
</div>
</div>
</section>
<footer class="footer">
<div class="container">
</div>
<div class="intentionally-blank"></div>
</footer>
</body>
</html>
