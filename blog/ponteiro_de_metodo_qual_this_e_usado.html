<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Blogue do Caloni</title>
<meta name="author" content="Caloni" />
<meta name="generator" content="https://github.com/caloni/journal">
<meta property="og:title" content="Blogue do Caloni"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="http://www.caloni.com.br"/>
<meta property="og:image" content="/blog/img/about-brand.png"/>
<meta property="og:description" content="Write for computers, people and food."/>
<link href="/blog/index.xml" rel="feed" type="application/rss+xml" title="Blogue do Caloni"/>
<link rel="stylesheet" type="text/css" href="/blog/css/custom.css"/>
<link rel="stylesheet" type="text/css" href="/blog/css/jquery-ui.css"/>
<script src="/blog/js/jquery-1.12.4.js"></script>
<script src="/blog/js/jquery-ui.js"></script>
<script src="/blog/js/copy_clipboard.js"></script>
<script src="/blog/js/list.js"></script>
<link rel="icon" href="/blog/img/favicon.ico"/>
</head>
<body style="min-height:100vh;display:flex;flex-direction:column">
<nav class="navbar has-shadow is-white"
role="navigation" aria-label="main navigation">
<div class="container">
<div class="navbar-brand">
&nbsp;
<a class="navbar-item" href="index.html">
<div class="is-4"><b>Blogue do Caloni</b></div>
</a>
</div>
</div>
</nav>
<div class="container">
<div class="column">
<div style="min-height:56vh">
<div style="padding-bottom: 1em;"></div>
<span id="ponteiro_de_metodo_qual_this_e_usado" title="Ponteiro de método: qual this é usado?"/></span>
<section id="section_ponteiro_de_metodo_qual_this_e_usado">
<p class="title">Ponteiro de método: qual this é usado?</p>
<span class="title-heading">Caloni, 2007-11-07 computer blog</span>

<p>Depois de publicado o artigo anterior sobre ponteiros de métodos surgiu uma dúvida muito pertinente do autor do blogue <a href="http://codebehind.wordpress.com">CodeBehind</a>, um escovador de bits disfarçado de programador .NET: qual objeto que vale na hora de chamar um método pelo ponteiro?</p>

<p>Isso me estimulou a desdobrar um pouco mais os mistérios por trás dos ponteiro de métodos e de membros, e descobrir os detalhes mais ocultos desse lado esotérico da linguagem.</p>

<p>Para entender por inteiro o que acontece quando uma chamada ou acesso utilizando ponteiros dependentes de escopo, algumas pequenas mudanças foram feitas na nossa pequena classe Rand.</p>

<pre>
#include &lt;iostream&gt;
#include &lt;time.h&gt;

class Rand;
typedef void (Rand::*FP)();
typedef int Rand::*MP;

class Rand
{
public:
  Rand()
  {
    m_num = rand() % 100;
  }

  int m_num;

  void Print()
  {
    std::cout &lt;&lt; &quot;this: &quot; 
      &lt;&lt; std::hex &lt;&lt; this 
      &lt;&lt; &quot;, member: &quot; 
      &lt;&lt; std::dec &lt;&lt; m_num
      &lt;&lt; std::endl;
  }
};

/** No princípio Deus disse: 
    'int main!'
*/
int main()
{
  srand(time(NULL));

  Rand r1, r2, r3;
  FP fp = &amp;Rand::Print;
  MP mp = &amp;Rand::m_num;

  (r1.*fp)();
  (r2.*fp)();
  (r3.*fp)();

  std::cout &lt;&lt; std::endl;
  
  std::cout &lt;&lt; &quot;this: &quot; 
    &lt;&lt; std::hex &lt;&lt; &amp;r1 
    &lt;&lt; &quot;, member: &quot; 
    &lt;&lt; std::dec &lt;&lt; r1.*mp 
    &lt;&lt; std::endl;

  std::cout &lt;&lt; &quot;this: &quot; 
    &lt;&lt; std::hex &lt;&lt; &amp;r2 
    &lt;&lt; &quot;, member: &quot; 
    &lt;&lt; std::dec &lt;&lt; r2.*mp 
    &lt;&lt; std::endl;

  std::cout &lt;&lt; &quot;this: &quot; 
    &lt;&lt; std::hex &lt;&lt; &amp;r3 
    &lt;&lt; &quot;, member: &quot; 
    &lt;&lt; std::dec &lt;&lt; r3.*mp 
    &lt;&lt; std::endl;
} 
</pre>
<p>O novo código chama através do mesmo ponteiro o mesmo método (duh), mas através de três objetos diferentes. Se observarmos a saída veremos que cada instância da classe guardou um inteiro aleatório diferente para si:</p>

<pre>
this: 0012FF6C, member: 97
this: 0012FF5C, member: 5
this: 0012FF60, member: 44

this: 0012FF6C, member: 97
this: 0012FF5C, member: 5
this: 0012FF60, member: 44
</pre>
<p>Cada compilador e plataforma tem a liberdade de implementar o padrão C++ da maneira que quiser, mas o conceito no final acaba ficando quase a mesma coisa. No caso de ponteiros de métodos, o ponteiro guarda realmente o endereço da função que pertence à classe. Porém, como todo método não-estático em C++, para chamá-lo é necessário possuir um this, ou seja, o ponteiro para a instância:</p>

<img src="/blog/img/ponteiro_de_metodo_qual_this_e_usado_fuzzycall.gif"/>

<p>Em assembly teremos algo assim:</p>

<pre>
; FP fp = &amp;Rand::Print;
lea rax,[Rand::Print]  
mov qword ptr [fp],rax

; (r1.*fp)();
lea rcx,[r1]  
call qword ptr [fp]  

; (r2.*fp)();
lea rcx,[r2]  
call qword ptr [fp]  

; (r3.*fp)();
lea rcx,[r3]  
call qword ptr [fp]  
</pre>
<p>Além do ponteiro de métodos, também é possível no C++ apontar para membros de um dado objeto como foi feito no exemplo acima. Para tanto, como vimos no código, basta declarar um tipo de ponteiro de membro de acordo com o tipo desejado com o escopo da classe: typedef int Rand::*MP. Nesse caso, a técnica de usar o próprio enderenço não funciona, já que cada objeto possui um membro próprio em um lugar de memória próprio. Porém, assim como os ponteiros de métodos, os ponteiros de membros exigem um objeto para serem acessados, o que já nos dá a dica de onde o objeto começa. Sabendo onde ele começa, fica fácil saber onde fica o membro através do seu offset, ou seja, a distância dele a partir do início da memória do objeto. O código abaixo simplifica a obtenção de um objeto dentro da classe usando ponteiro para membros:</p>

<pre>
MP mp = &amp;Rand::m_num;
int i1 = r1.*mp;
int i2 = r2.*mp;
int i3 = r3.*mp;
</pre>
<p>Note no assembly gerado que para isso funcionar o código precisa do offset armazenado em algum lugar. E, nada mais óbvio, o "ponteiro" de um membro de uma classe nada mais é que o offset deste membro dentro desta classe.</p>

<pre>
; MP mp = &amp;Rand::m_num;
mov dword ptr [mp],0

; int i1 = r1.*mp;
movsxd rax,dword ptr [mp] 
mov eax,dword ptr r1[rax] 
mov dword ptr [i1],eax 

; int i2 = r2.*mp;
movsxd rax,dword ptr [mp] 
mov eax,dword ptr r2[rax] 
mov dword ptr [i2],eax 

; int i3 = r3.*mp;
movsxd rax,dword ptr [mp] 
mov eax,dword ptr r3[rax] 
mov dword ptr [i3],eax
</pre>
<p>Como podemos ver, não é nenhuma magia negra a responsável por fazer os ponteiros de métodos e de membros funcionarem em C++. Porém, eles não são ponteiros ordinário que costumamos misturar a torto e a direito. Essa distinção na linguagem é importante para manter o código "minimamente sadio".</p>

</section>

<span style="float: left;">
 <a href="detectando_hooks_globais_no_windbg.html">[detectando_hooks_globais_no_windbg]</a>
 <a href="ponteiros_de_metodo_conceito_fundamental.html">[ponteiros_de_metodo_conceito_fundamental]</a>
</span>
</div>
</div>
</section>
<footer class="footer">
<div class="container">
</div>
<div class="intentionally-blank"></div>
</footer>
</body>
</html>
