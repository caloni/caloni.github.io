<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Blogue do Caloni</title>
<meta name="author" content="Caloni" />
<meta name="generator" content="https://github.com/caloni/journal">
<meta property="og:title" content="Blogue do Caloni"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="http://www.caloni.com.br"/>
<meta property="og:image" content="/blog/img/about-brand.png"/>
<meta property="og:description" content="Write for computers, people and food."/>
<link href="/blog/index.xml" rel="feed" type="application/rss+xml" title="Blogue do Caloni"/>
<link rel="stylesheet" type="text/css" href="/blog/css/custom.css"/>
<link rel="stylesheet" type="text/css" href="/blog/css/jquery-ui.css"/>
<script src="/blog/js/jquery-1.12.4.js"></script>
<script src="/blog/js/jquery-ui.js"></script>
<script src="/blog/js/copy_clipboard.js"></script>
<script src="/blog/js/list.js"></script>
<link rel="icon" href="/blog/img/favicon.ico"/>
</head>
<body style="min-height:100vh;display:flex;flex-direction:column">
<nav class="navbar has-shadow is-white"
role="navigation" aria-label="main navigation">
<div class="container">
<div class="navbar-brand">
&nbsp;
<a class="navbar-item" href="index.html">
<div class="is-4"><b>Blogue do Caloni</b></div>
</a>
</div>
</div>
</nav>
<div class="container">
<div class="column">
<div style="min-height:56vh">
<div style="padding-bottom: 1em;"></div>
<span id="desconstruindo_ioccc" title="Desconstruindo IOCCC"/></span>
<section id="section_desconstruindo_ioccc">
<p class="title">Desconstruindo IOCCC</p>
<span class="title-heading">Caloni, 2008-02-11 computer blog</span>

<p>Como alguns devem saber, e outros não (ou não deveriam), existe uma competição internacional para escolher quem escreve o código em C mais ofuscado. Isso mesmo. O evento se chama <a href="http://www.ioccc.org">The International Obfuscated C Code Contest</a> (IOCCC resumidamente) e costuma premiar anualmente os melhores "do ramo" com a chamada "menção desonrosa".</p>

<p>Acredito que a real valia de um campeonato desse porte é fazer as pessoas pensarem mais a fundo sobre as regras da linguagem. Isso faz com que erros mais obscuros que encontramos no dia-a-dia se tornem mais fáceis. Claro que ninguém deveria programar como os caras desse torneio, mas a título de aprendizagem, é uma grande aula sobre C.</p>

<p>Publico aqui a interpretação do primeiro programa a ganhar a tal <a href="http://www.ioccc.org/1984/anonymous/anonymous.c">menção desonrosa</a>, em 1984. Se trata do batidíssimo "Hello World", só que um pouco compactado e confuso. Vejamos o fonte original:</p>

<pre>
int i;main(){for(;i[&quot;]&lt;i;++i){--i;}&quot;];read('-'-'-',i+++&quot;hell\
o, world!\n&quot;,'/'/'/'));}read(j,i,p){write(j/p+p,i---j,i/i);}
</pre>
<p>Aparentemente o fonte é bem confuso, apesar de podermos já ver a famosa string escondida no meio do código. Depois de aplicar uma formatação mais adequada para nossa tarefa de desfazer o feito, o resultado é bem mais legível:</p>

<pre>
int i;

main()
{
  for( ; i[&quot;] &lt; i; ++i ){--i;}&quot;]; read('-' - '-', i++ + &quot;hello, world!\n&quot;, '/' / '/') )
    ;
}

read(j, i, p)
{
  write(j / p + p, i-- - j, i / i);
}
</pre>
<p>Algumas construções são óbvias. Vamos então partir para as não-tão-óbvias.</p>

<pre>
int i;
</pre>
<p>Como toda variável global inteira, é inicializada com zero. Logo, a linha acima é equivalente a "int i =0".</p>

<pre>
main() { }
read() { }
</pre>
<p>Aos programadores C++ desavisados de plantão, em C o valor de retorno padrão é int, e, caso não seja retornado nada, isso não constitui um erro, porém o comportamento é não-definido. Nada de mal, porém, pode ocorrer, a não ser o retorno de lixo da pilha.</p>

<pre>
for( ; &lt;censurado&gt;; &lt;censurado&gt; )
    ;
</pre>
<p>Outra coisa óbvia, mas não tanto, é um laço for sem corpo. Ele possui apenas um ponto-e-vírgula, que identifica uma instrução nula. Não faz nada no corpo, mas pode fazer coisas interessantes no cabeçalho, ou seja, na inicialização, no teste e no incremento. Como podemos ver, a inicialização também está vazia, contendo esse laço apenas o teste e o incremento. No teste temos a seguinte comparação:</p>

<pre>
i[&quot;] &lt; i; ++i ){--i;}&quot;]
</pre>
<p>Ora, sabendo que a variável "i" inicialmente tem o valor zero, o que estamos vendo aqui é a mesma coisa que</p>

<pre>
0[&quot;] &lt; i; ++i ){--i;}&quot;]
</pre>
<p>E uma vez que aprendemos algumas <a href="curiosidades_inuteis_o_operador_de_subscrito_em_c.html">peculiaridades sobre o operador de subscrito</a> em C, sabemos que a linha acima é equivalente a essa linha abaixo:</p>

<pre>
&quot;] &lt; i; ++i ){--i;}&quot;[0]
</pre>
<p>Agora ficou mais fácil de entender. Se trocarmos a nossa string literal por uma variável (forma mais usual), temos um acesso típico a um dos caracteres de uma string:</p>

<pre>
char* str = &quot;] &lt; i; ++i ){--i;}&quot;;
str[0];
</pre>
<p>Só precisamos lembrar que a variável i é que define a posição, e por ser uma variável, pode mudar durante a execução:</p>

<pre>
int i = 0;
char* str = &quot;] &lt; i; ++i ){--i;}&quot;;
str[i];
</pre>
<p>Pois bem. Agora sabemos que o laço irá ser testado pelo menos uma vez, o que quer dizer que a parte do incremento vai executar pelo menos uma vez. E essa parte é a seguinte:</p>

<pre>
read('-' - '-', i++ + &quot;hello, world!\n&quot;, '/' / '/')
</pre>
<p>Uma chamada de função. Nada mais simples. Podemos anular algumas coisas por aqui. Por exemplo, se subtraímos um número dele mesmo encontramos zero, e se dividirmos um número por ele mesmo o resultado é um:</p>

<pre>
'-' - '-' == 0
'/' / '/' == 1
</pre>
<p>Lembre-se de que um caractere em C é um tipo inteiro, e portanto, pode fazer parte de cálculos matemáticos. Depois dessa simplificação, temos</p>

<pre>
read(0, i++ + &quot;hello, world!\n&quot;, 1)
</pre>
<p>Agora você deveria estar se perguntando (se ainda não encontrou a resposta) do porquê de eu ter dividido os três sinais de + dessa forma. Existem duas opções para a divisão:</p>

<pre>
i++ + &quot;hello, world!\n&quot; /* ou */
i+ ++&quot;hello, world&quot;\n&quot;  /* ?? */
</pre>
<p>A primeira forma é a resposta correta devido à regra de precedência (deferida pela gramática). Antes os operadores unários, depois os binários. Dessa forma, um "i+" não quer dizer nada, mas "i++" é um operando com um operador unário.</p>

<p>Voltando à expressão, imagino que a essa altura você já deva ter decifrado que i++ + "hello, world!\n" é o mesmo que:</p>

<pre>
char* str = &quot;hello, world&quot;\n&quot;;
&amp;str[i++];
</pre>
<p>Ou seja, obtemos o endereço do primeiro caractere da string e incrementamos nossa variável "i" que, como sabemos, é usada no teste do laço for. Na primeira vez, testamos se o primeiro caractere de "] &lt; i; ++i ){--i;}" é diferente de zero. Na segunda iteração, portanto, iremos testar se o segundo caractere será zero. Sabendo disso, podemos deduzir que o laço irá correr por todos os caracteres da string de teste, até encontrar o zero finalizador de string. Ao mesmo tempo, iremos enviar para a função read sempre o endereço do i'ésimo caractere da string "hello, world!\n", pois essa string também é indexada pela variável "i".</p>

<p>Isso quer dizer que nosso laço irá terminar exatamente no final de ambas as strings! (Note, que para comparar as strings, usamos as strings originais do programa, sem melhorar a formatação).</p>

<pre>
&quot;] &lt; i ; + + i ) { - - i ; }&quot;
 1 2 3 4 5 6 7 8 9 0 1 2 3 4
&quot;h e l l o ,   w o r l d ! \n&quot;
</pre>
<p>Também devemos lembrar que o caractere de controle '\n' é representado apenas por um byte, apesar de no fonte parecer dois.</p>

<p>Em um passado bem longínquo, o padrão ANSI C não existia, e outras funções dominavam o ambiente UNIX. Muitas dessas funções foram adaptadas, e outras completamente copiadas para a formação do padrão. No entanto, ainda que o padrão não tenha colocado algumas funções clássicas, elas continuaram sendo usadas e suportadas. Um bom exemplo disso são as funções read e write, que, apesar de não estarem no padrão, estão no <a href="the_c_programming_language.html">livro de KandR</a>, no capítulo sobre fluxos (streams) em UNIX, provando que são bem populares.</p>

<p>Dentro desse mundo paralelo, existem identificadores de fluxos padrões para a entrada e a saída padrão. Melhor ainda, esses identificadores são inteiros que estão especificados da seguinte maneira (tirado da <a href="https://ftp.gnu.org/old-gnu/Manuals/glibc-2.2.3/html_node/libc_231.html">referência GNU</a> da linguagem C, meu grifo):</p>

<blockquote>There are also symbolic constants defined in unistd.h for the file descriptors belonging to the standard streams stdin, stdout, and stderr; see Standard Streams.</blockquote>
<blockquote>STDIN_FILENO</blockquote>
<blockquote>This macro has value 0, which is the file descriptor for standard input.</blockquote>
<blockquote>STDOUT_FILENO</blockquote>
<blockquote>This macro has value 1, which is the file descriptor for standard output.</blockquote>
<blockquote>STDERR_FILENO</blockquote>
<blockquote>This macro has value 2, which is the file descriptor for standard error output.</blockquote>
<p>Agora podemos voltar ao fonte. Vejamos como é implementada a função read, chamada dentro do laço for. Como todos sabem, se uma função já é definida em sua própria unidade, não haverá uma busca por referências externas, o que quer dizer que a implementação padrão de read não atrapalha a implementação local.</p>

<pre>
read(j, i, p)
{
  write(j / p + p, i-- - j, i / i);
}
</pre>
<p>Ótimo. A função read chama a função (essa sim, padrão) write. Sabemos que tanto o primeiro quanto o último parâmetro da função será sempre constante no laço for:</p>

<pre>
read(0, i++ + &quot;hello, world!\n&quot;, 1)
</pre>
<p>O que quer dizer que o primeiro argumento passado para write será sempre o mesmo:</p>

<pre>
j == 0;
p == 1;
j / p + p == 1;
</pre>
<p>Além da constante óbvia passada no último argumento:</p>

<pre>
i / i = 1; /* independente de i */
</pre>
<p>Isso quer dizer que a chamada para write pode ser resumida para:</p>

<pre>
write(1, i-- - j, 1);
</pre>
<p>O decremento da variável "i" (dentro de read) nunca é usado, uma vez que é uma variável local. E subtrair "j" é inócuo, uma vez que o valor de "j" será sempre zero. Logo, o argumento do meio é sempre o parâmetro do meio, por mais idiota que isso possa parecer =)</p>

<pre>
write(1, i, 1);
</pre>
<p>Pronto, já temos condições de interpretar o significado dessa chamada à write. Como já vimos, o número 1 identifica a saída padrão, o que quer dizer que estamos escrevendo algo na saída padrão. Esse algo é o parâmetro "i" que, como vimos, é o endereço do i'ésimo caractere da string "hello, word!\n". O último argumento é o número de bytes a serem escritos, que será sempre um. O que quer dizer que o laço em for faz a chamada para a função read `strlen("hello, world!\n")` vezes passando o endereço do próximo caractere de cada vez. A função read, por sua vez, escreve este caractere na saída padrão. O resultado, como todos que compilarem o fonte e rodarem poderão comprovar, é a impressão da mensagem mais famosa do mundo da computação:</p>

<pre>
hello, world!
</pre>
<p>E voilà =)</p>

<p>Abaixo um código-fonte equivalente, devidamente desencriptado:</p>

<pre>
int i = 0;

main()
{
  char* indexString = &quot;]&lt;i;++i){--i;}&quot;;
  char* outputString = &quot;hello, world!\n&quot;;

  for( ; indexString[i] != 0; read(&amp;outputString[i++]) )
    ;
}

read(outStr)
{
  write(1, outStr, 1);
}
</pre>
</section>

<span style="float: left;">
 <a href="funky_dowhile.html">[funky_dowhile]</a>
 <a href="process_monitor_e_o_monopolio_malcriado.html">[process_monitor_e_o_monopolio_malcriado]</a>
</span>
</div>
</div>
</section>
<footer class="footer">
<div class="container">
</div>
<div class="intentionally-blank"></div>
</footer>
</body>
</html>
