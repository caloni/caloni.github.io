<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Blogue do Caloni</title>
<meta name="author" content="Caloni" />
<meta name="generator" content="https://github.com/caloni/journal">
<meta property="og:title" content="Blogue do Caloni"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="http://www.caloni.com.br"/>
<meta property="og:image" content="/blog/img/about-brand.png"/>
<meta property="og:description" content="Write for computers, people and food."/>
<link href="/blog/index.xml" rel="feed" type="application/rss+xml" title="Blogue do Caloni"/>
<link rel="stylesheet" type="text/css" href="/blog/css/custom.css"/>
<link rel="stylesheet" type="text/css" href="/blog/css/jquery-ui.css"/>
<script src="/blog/js/jquery-1.12.4.js"></script>
<script src="/blog/js/jquery-ui.js"></script>
<script src="/blog/js/copy_clipboard.js"></script>
<script>
var quick_search_posts = [ 
 ]; 
</script>
<script src="/blog/js/quick_search.js"></script>
<script src="/blog/js/list.js"></script>
<link rel="icon" href="/blog/img/favicon.ico"/>
</head>
<body style="min-height:100vh;display:flex;flex-direction:column">
<nav class="navbar has-shadow is-white"
role="navigation" aria-label="main navigation">
<div class="container">
<div class="navbar-brand">
&nbsp;
<a class="navbar-item" href="index.html">
<div class="is-4"><b>Blogue do Caloni</b></div>
</a>
</div>
</div>
</nav>
<div class="container">
<div class="column">
<div style="min-height:56vh">
<div style="padding-bottom: 1em;"></div>
<span id="antidebug_interpretacao_baseada_em_excecao_parte_1" title="Antidebug: interpretação baseada em exceção (parte 1)"/></span>
<section id="section_antidebug_interpretacao_baseada_em_excecao_parte_1">
<p class="title">Antidebug: interpretação baseada em exceção (parte 1)</p>
<span class="title-heading">Caloni, 2007-07-20 computer projects blog</span>

<p>Um depurador utiliza breakpoints para "paralisar" momentaneamente a execução do programa sendo depurado. Para isso ele se utiliza de uma bem conhecida instrução conhecida como int 3. Essa instrução gera uma exceção -- exceção de breakpoint -- que é capturada pelo sistema operacional e repassada para o código de tratamento dessa exceção. Em programas sendo depurados esse código está localizado no depurador. Em programas "livres" esse código normalmente não existe e ao acontecer essa exceção o aplicativo simplesmente "capota".</p>

<p>A idéia principal na proteção baseada em exceção é tomarmos conta dessas exceções durante a execução do aplicativo. Fazendo isso podemos nos aproveitar desse fato e, no código responsável por tratar a exceção, executar o código protegido. A solução discutida aqui é parecido com um interpretador de scripts. Consiste basicamente de duas threads. A primeira thread lê uma seqüência de instruções e manda a segunda thread executá-las passo a passo. Para fazer isso a segunda thread usa um conjunto de pequenas funções com blocos de código bem definidos. Em pseudocódigo isso ficaria assim:</p>

<pre>
   void Function1();
   void Function2();
   void Function3();
   //...
   void FunctionN();
   void ExecThread()
   {
     while( true )
     {
       ExecFunction(funcNumber);
     }
   }
   int Functions[] = { 
     3, 4, 1, 2, 34, 66, 982
   };
   int Start()
   {
     CreateThread(ExecThread);
     for( 0 to size(Functions) )
     {
       ExecThreadToExecFunc(Function[i]);
     }
     return 0;
   } 
</pre>
<p>A proteção ainda não está aí. Mas fará parte intrínseca da thread de execução. Tudo que precisamos fazer é adicionar um tratamento de exceções e fazer chover ints 3. As exceções disparadas pela int 3 são capturadas por uma segunda função que antes de retornar o controle executa a próxima instrução enfileirada:</p>

<pre>
   DWORD ExceptFilter()
   {
     ExecFunction(number);
     // goes to except code
     return EXCEPTION_EXECUTE_HANDLER;
   }
   void ExecThread()
   {
     while( true )
     {
       __try
       {
         // breakpoint exception
         __asm int 3
         // it stops the debugger 
         // if we have an attached 
         // debugger in the process
         // or throws an exception 
         // if there is no one
       }
       __except( ExceptFilter() )
       {
         // does nothing
       }
       Sleep(someTime);
     }
   } 
</pre>
<p>O algoritmo da thread de execução continua o mesmo. Só que o ponto onde cada instrução é executada depende do lançamento de uma exceção. Note que essa exceção tem que ocorrer para que a chamada da próxima instrução ocorra. Isso é fundamental, pois dessa forma ninguém pode simplesmente retirar o int 3 do código para evitar o lançamento da exceção. Se fizer isso, então mais nenhuma instrução será executada.</p>

<p>Na prática, se alguém tentar depurar um programa desse tipo vai ter que enfrentar dezenas ou centenas de lançamento de exceções até descobrir o que está acontecendo. Claro que, como em toda a proteção de software, ela não é definitiva; tem por função dificultar o trabalho de quem tenta entender o software. Isso não vai parar aqueles que são <a href="http://www.codebreakers-journal.com">realmente bons no que fazem</a>.</p>

<p>O preço pago por essa proteção fica na visibilidade e compreensão do código-fonte comprometidos pelo uso da técnica. A programação fica baseada em uma máquina de estados e as funções ficam limitadas a algum tipo de padronização no comportamento. Quando mais granular for o pseudoscript, ou seja, quanto menores forem os blocos de código contido nas minifunções, mais difícil de entender o código será.</p>

<p>Fiz um código de exemplo que recebe entrada por um prompt de comandos (update 2026-01-27: ao longo do tempo perdi esse código, então pedi para o Chat-GPT escrever um novo) e mapeia a primeira palavra digitada para o índice de uma função que deve ser chamada. O resto da linha digitada é passado como parâmetro para essa função. A thread de interpretação lê a entrada do usuário e escreve em uma variável-string global, ao mesmo tempo que a thread de execução espera essa string ser preenchida para executar a ação. </p>

<pre>
#include &lt;intrin.h&gt; // __debugbreak();
#include &lt;windows.h&gt;
#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
// use this to debug
#ifdef _DEBUG
#define BREAK throw EXCEPTION_ACCESS_VIOLATION
#else
#define BREAK __debugbreak()
#endif
using namespace std;
// mini function &quot;VM&quot;
void FuncHello(const string&amp; arg)
{
    cout &lt;&lt; &quot;[FuncHello] Hello! Arg = &quot; &lt;&lt; arg &lt;&lt; endl;
}
void FuncEcho(const string&amp; arg)
{
    cout &lt;&lt; &quot;[FuncEcho] &quot; &lt;&lt; arg &lt;&lt; endl;
}
void FuncExit(const string&amp; arg)
{
    cout &lt;&lt; &quot;[FuncExit] Exiting...&quot; &lt;&lt; endl;
    ExitProcess(0);
}
// functions table
typedef void (*FuncPtr)(const string&amp;);
FuncPtr g_Functions[] =
{
    FuncHello, // 0
    FuncEcho,  // 1
    FuncExit   // 2
};
// global state (simplified)
atomic&lt;int&gt; g_NextFuncIndex(-1);
string g_Arg;
// execution based on exception
LONG WINAPI ExceptFilter(EXCEPTION_POINTERS* info)
{
    int idx = g_NextFuncIndex.load();
    if (idx &gt;= 0 &amp;&amp; idx &lt; (int)(sizeof(g_Functions) / sizeof(FuncPtr)))
    {
        g_Functions[idx](g_Arg);
        g_NextFuncIndex.store(-1);
    }
    return EXCEPTION_EXECUTE_HANDLER;
}
DWORD WINAPI ExecThread(LPVOID)
{
    while (true)
    {
        __try
        {
            // force breakpoint exception
            BREAK;
        }
        __except (ExceptFilter(GetExceptionInformation()))
        {
            // nothing to see here
        }
		Sleep(50); // prevents starvation
    }
    return 0;
}
// interpreter thread
int CommandToFunction(const string&amp; cmd)
{
    if (cmd == &quot;hello&quot;) return 0;
    if (cmd == &quot;echo&quot;)  return 1;
    if (cmd == &quot;exit&quot;)  return 2;
    return -1;
}
void InterpreterLoop()
{
    while (true)
    {
        cout &lt;&lt; &quot;&gt; &quot;;
        string line;
        getline(cin, line);
        if (line.empty())
            continue;
		// separates command and argument
        string cmd, arg;
        size_t pos = line.find(' ');
        if (pos == string::npos)
        {
            cmd = line;
        }
        else
        {
            cmd = line.substr(0, pos);
            arg = line.substr(pos + 1);
        }
        int idx = CommandToFunction(cmd);
        if (idx == -1)
        {
            cout &lt;&lt; &quot;Unknown command.&quot; &lt;&lt; endl;
            continue;
        }
        g_Arg = arg;
        g_NextFuncIndex.store(idx);
    }
}
int main()
{
    cout &lt;&lt; &quot;Anti-debug exception-based interpreter demo\n&quot;;
    cout &lt;&lt; &quot;Commands: hello, echo &lt;text&gt;, exit\n\n&quot;;
    CreateThread(nullptr, 0, ExecThread, nullptr, 0, nullptr);
    InterpreterLoop();
    return 0;
}
</pre>
<p>Foi usado o pool dessa variável para o código ficar mais simples, mas o ideal seria algum tipo de sincronismo, como eventos, por exemplo.</p>

<p>O ponto forte da proteção é que a pessoa precisa entender o que está acontecendo para tomar alguma atitude inteligente para solucionar o "problema". O ponto fraco é que após entendido o problema a solução torna-se fácil de visualizar. Tão fácil que eu nem pretendo citar aqui.</p>

<p>Futuramente veremos uma maneira de tornar as coisas mais legíveis e usáveis no dia-a-dia de um programador de software de segurança.</p>

</section>

<span style="float: left;">
 <a href="movendo_o_cursor_do_mouse_com_o_teclado.html">[movendo_o_cursor_do_mouse_com_o_teclado]</a>
 <a href="what_happens_inside_the_sizeof_operator.html">[what_happens_inside_the_sizeof_operator]</a>
</span>
</div>
</div>
</section>
<footer class="footer">
<div class="container">
</div>
<div class="intentionally-blank"></div>
</footer>
</body>
</html>
