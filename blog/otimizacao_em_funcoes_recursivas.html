<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Blogue do Caloni</title>
<meta name="author" content="Caloni" />
<meta name="generator" content="https://github.com/caloni/journal">
<meta property="og:title" content="Blogue do Caloni"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="http://www.caloni.com.br"/>
<meta property="og:image" content="/blog/img/about-brand.png"/>
<meta property="og:description" content="Write for computers, people and food."/>
<link href="/blog/index.xml" rel="feed" type="application/rss+xml" title="Blogue do Caloni"/>
<link rel="stylesheet" type="text/css" href="/blog/css/custom.css"/>
<link rel="stylesheet" type="text/css" href="/blog/css/jquery-ui.css"/>
<script src="/blog/js/jquery-1.12.4.js"></script>
<script src="/blog/js/jquery-ui.js"></script>
<script src="/blog/js/copy_clipboard.js"></script>
<script src="/blog/js/list.js"></script>
<link rel="icon" href="/blog/img/favicon.ico"/>
</head>
<body style="min-height:100vh;display:flex;flex-direction:column">
<nav class="navbar has-shadow is-white"
role="navigation" aria-label="main navigation">
<div class="container">
<div class="navbar-brand">
&nbsp;
<a class="navbar-item" href="index.html">
<div class="is-4"><b>Blogue do Caloni</b></div>
</a>
</div>
</div>
</nav>
<div class="container">
<div class="column">
<div style="min-height:56vh">
<div style="padding-bottom: 1em;"></div>
<span id="otimizacao_em_funcoes_recursivas" title="Otimização em funções recursivas"/></span>
<section id="section_otimizacao_em_funcoes_recursivas">
<p class="title">Otimização em funções recursivas</p>
<span class="title-heading">Caloni, 2008-01-18 computer blog</span>

<p>O livro que estou lendo, Dominando Algoritmo com C, como o próprio nome diz, fala sobre algoritmos em C. Os primeiros capítulos são praticamente uma revisão para quem já programou em C, pois tratam de coisas que programadores com mais de cinco anos de casa devem ter na memória cachê (listas, pilhas, recursão, etc). Porém, tive uma agradável surpresa de achar um truque muito sabido que não conhecia, chamado de <a href="http://en.wikipedia.org/wiki/Tail_recursion">tail recursion</a>. Fiz questão de testar nos dois compiladores mais conhecidos e eis o resultado.</p>

<p>Imagine uma função recursiva que calcula o <a href="http://pt.wikipedia.org/wiki/Fatorial">fatorial</a> de um número. Apenas para lembrar, o fatorial de um número n é igual a n * n-1 * n-2 * n-3 até o número 1. Existem implementações iterativas (com um laço for, por exeplo) e recursivas, que no caso chamam a mesma função n vezes.</p>

<pre>
   int factorial(int n)
   {
     if (n &gt; 1)
       return factorial(n - 1) * n;
     else
       return 1;
   }
   int main()
   {
     return factorial(1000);
   }
</pre>
<p>Para ver o overhead de uma função dessas, compilamos com a opção de debug e depuramos no CDB.</p>

<pre>
   &gt;cl /Zi recursive-factorial1.c
   &gt;cdb recursive-factorial1.exe
   Microsoft (R) Windows Debugger Version 6.8.0004.0 X86
   Copyright (c) Microsoft Corporation. All rights reserved.
   CommandLine: recursive-factorial1.exe
   Symbol search path is: SRV*C:\Symbols*\\symbolserver\OSSYMBOLS
   Executable search path is:
   ModLoad: 00400000 0041e000   recursive-factorial1.exe
   ModLoad: 7c900000 7c9b0000   ntdll.dll
   ModLoad: 7c800000 7c8f5000   C:\WINDOWS\system32\kernel32.dll
   (594.700): Break instruction exception - code 80000003 (first chance)
   eax=00241eb4 ebx=7ffdb000 ecx=00000000 edx=00000001 esi=00241f48 edi=00241eb4
   eip=7c901230 esp=0012fb20 ebp=0012fc94 iopl=0         nv up ei pl nz na po nc
   cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
   ntdll!DbgBreakPoint:
   7c901230 cc              int     3
   0:000&gt; bp factorial
   *** WARNING: Unable to verify checksum for recursive-factorial1.exe
   0:000&gt; l+*
     WARNING: Line information loading disabled
   Source options are ffffffff:
        1/t - Step/trace by source line
        2/l - List source line at prompt
        4/s - List source code at prompt
        8/o - Only show source code at prompt
   0:000&gt; g
   Breakpoint 0 hit
   &gt;    2: {
   0:000&gt; p
   &gt;    3:         if (n &gt; 1)
   0:000&gt;
   &gt;    4:                 return factorial(n - 1) * n;
   0:000&gt;
   Breakpoint 0 hit
   &gt;    2: {
   0:000&gt;
   &gt;    3:         if (n &gt; 1)
   0:000&gt;
   &gt;    4:                 return factorial(n - 1) * n;
   0:000&gt;
   Breakpoint 0 hit
   &gt;    2: {
   0:000&gt;
   &gt;    3:         if (n &gt; 1)
   0:000&gt;
   &gt;    4:                 return factorial(n - 1) * n;
   0:000&gt;
   Breakpoint 0 hit
   &gt;    2: {
   0:000&gt;
   &gt;    3:         if (n &gt; 1)
   0:000&gt;
   &gt;    4:                 return factorial(n - 1) * n;
   0:000&gt;
   Breakpoint 0 hit
   &gt;    2: {
   0:000&gt;
   &gt;    3:         if (n &gt; 1)
   0:000&gt;
   &gt;    4:                 return factorial(n - 1) * n;
   0:000&gt;
   Breakpoint 0 hit
   &gt;    2: {
   0:000&gt;
   &gt;    3:         if (n &gt; 1)
   0:000&gt; k
   ChildEBP RetAddr
   0012ff28 00401035 recursive_factorial1!factorial+0x3
   0012ff34 00401035 recursive_factorial1!factorial+0x15
   0012ff40 00401035 recursive_factorial1!factorial+0x15
   0012ff4c 00401035 recursive_factorial1!factorial+0x15
   0012ff58 00401035 recursive_factorial1!factorial+0x15
   0012ff64 0040105d recursive_factorial1!factorial+0x15
   0012ff70 00401268 recursive_factorial1!main+0xd
   0012ffc0 7c816fd7 recursive_factorial1!__tmainCRTStartup+0x15f
   0012fff0 00000000 kernel32!BaseProcessStart+0x23
   0:000&gt;
</pre>
<p>Ou seja, conforme chamamos a função recursivamente, a pilha tende a crescer. Agora imagine todo o overhead da execução, que precisa, a cada chamada, gerar um stack frame.</p>

<p>A mesma coisa podemos notar se compilarmos o mesmo fonte no GCC e depurarmos pelo GDB. Aliás, a primeira participação especial do GDB nesse blogue =)</p>

<pre>
   $ gcc -g recursive-factorial1.c
   $ gdb a.exe
   GNU gdb 6.5.50.20060706-cvs (cygwin-special)
   Copyright (C) 2006 Free Software Foundation, Inc.
   GDB is free software, covered by the GNU General Public License, and you are
   welcome to change it and/or distribute copies of it under certain conditions.
   Type &quot;show copying&quot; to see the conditions.
   There is absolutely no warranty for GDB.  Type &quot;show warranty&quot; for details.
   This GDB was configured as &quot;i686-pc-cygwin&quot;...
   (gdb) break factorial
   Breakpoint 1 at 0x401056: file recursive-factorial1.c, line 3.
   (gdb) run
   Starting program: /cygdrive/c/temp/a.exe
   Loaded symbols for /cygdrive/c/WINDOWS/system32/ntdll.dll
   Loaded symbols for /cygdrive/c/WINDOWS/system32/kernel32.dll
   Loaded symbols for /usr/bin/cygwin1.dll
   Loaded symbols for /cygdrive/c/WINDOWS/system32/advapi32.dll
   Loaded symbols for /cygdrive/c/WINDOWS/system32/rpcrt4.dll
   Breakpoint 1, factorial (n=1000) at recursive-factorial1.c:3
   3               if (n &gt; 1)
   (gdb) step
   4                       return factorial(n - 1) * n;
   (gdb)
   Breakpoint 1, factorial (n=999) at recursive-factorial1.c:3
   3               if (n &gt; 1)
   (gdb)
   4                       return factorial(n - 1) * n;
   (gdb)
   Breakpoint 1, factorial (n=998) at recursive-factorial1.c:3
   3               if (n &gt; 1)
   (gdb)
   4                       return factorial(n - 1) * n;
   (gdb)
   Breakpoint 1, factorial (n=997) at recursive-factorial1.c:3
   3               if (n &gt; 1)
   (gdb)
   4                       return factorial(n - 1) * n;
   (gdb)
   Breakpoint 1, factorial (n=996) at recursive-factorial1.c:3
   3               if (n &gt; 1)
   (gdb)
   4                       return factorial(n - 1) * n;
   (gdb)
   Breakpoint 1, factorial (n=995) at recursive-factorial1.c:3
   3               if (n &gt; 1)
   (gdb)
   4                       return factorial(n - 1) * n;
   (gdb)
   Breakpoint 1, factorial (n=994) at recursive-factorial1.c:3
   3               if (n &gt; 1)
   (gdb)
   4                       return factorial(n - 1) * n;
   (gdb)
   Breakpoint 1, factorial (n=993) at recursive-factorial1.c:3
   3               if (n &gt; 1)
   (gdb)
   4                       return factorial(n - 1) * n;
   (gdb) backtrace
   #0  factorial (n=993) at recursive-factorial1.c:4
   #1  0x00401068 in factorial (n=994) at recursive-factorial1.c:4
   #2  0x00401068 in factorial (n=995) at recursive-factorial1.c:4
   #3  0x00401068 in factorial (n=996) at recursive-factorial1.c:4
   #4  0x00401068 in factorial (n=997) at recursive-factorial1.c:4
   #5  0x00401068 in factorial (n=998) at recursive-factorial1.c:4
   #6  0x00401068 in factorial (n=999) at recursive-factorial1.c:4
   #7  0x00401068 in factorial (n=1000) at recursive-factorial1.c:4
   #8  0x004010b3 in main () at recursive-factorial1.c:11
   (gdb)
</pre>
<p>Isso acontece porque o compilador é obrigado a montar um novo stack frame para cada chamada da mesma função, já que os valores locais precisam manter-se intactos até o retorno recursivo da função. Porém, existe uma otimização chamada de tail recursion, que ocorre se, e somente se (de acordo com o livro):</p>

<ul><li>A chamada recursiva é a última instrução que será executada no corpo da função.</li>

<li>O valor de retorno da chamada não é parte de uma expressão.</li></ul>

<p>Note que ser a última instrução não implica em ser a última linha da função, o importante é que seja a última linha executada. No nosso exemplo, isso já é fato, só que usamos o retorno em uma expressão.</p>

<pre>
   return factorial(n - 1) * n;
   // o retorno da chamada recursiva 
   // é parte de uma expressão
</pre>
<p>Por isso é necessário desenvolver uma segunda versão do código, que utiliza dois parâmetros para que aconteça a situação de tail recursion.</p>

<pre>
   int factorial(int n, int a)
   {
     if (n &lt; 0)
       return 0;
     else if (n == 0)
       return 1;
     else if (n == 1)
       return a;
     else
       return factorial(n - 1, n * a);
   }
   int main()
   {
     return factorial(1000, 1);
   }
</pre>
<p>Nessa segunda versão, a chamada da função recursiva não mais é parte de uma expressão, e continua sendo a última instrução executada. Agora só temos que compilar com a opção de otimização certa em ambos os compiladores e testar.</p>

<p>Para o Visual Studio, podemos usar a flag /Og (otimização global).</p>

<pre>
   &gt;cl /Zi /Og recursive-factorial2.c
   &gt;cdb recursive-factorial2.exe
   ...
   bp factorial
   g
   ...
   Breakpoint 0 hit
   eax=003235f0 ebx=7c80abc1 ecx=00000001 edx=0041c560 esi=00000002 edi=00000a28
   eip=00401020 esp=0012ff68 ebp=0012ffc0 iopl=0         nv up ei pl zr na pe nc
   cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
   recursive_factorial2!factorial:
   00401020 55              push    ebp
   0:000&gt; l+*
     WARNING: Line information loading disabled
   Source options are ffffffff:
        1/t - Step/trace by source line
        2/l - List source line at prompt
        4/s - List source code at prompt
        8/o - Only show source code at prompt
   0:000&gt; p
   &gt;    3:         if (n &lt; 0)
   0:000&gt;
   &gt;    5:         else if (n == 0)
   0:000&gt;
   &gt;    7:         else if (n == 1)
   0:000&gt;
   &gt;   10:                 return factorial(n - 1, n * a);
   0:000&gt;
   &gt;    5:         else if (n == 0)
   0:000&gt;
   &gt;    7:         else if (n == 1)
   0:000&gt;
   &gt;   10:                 return factorial(n - 1, n * a);
   0:000&gt;
   &gt;    5:         else if (n == 0)
   0:000&gt;
   &gt;    7:         else if (n == 1)
   0:000&gt;
   &gt;   10:                 return factorial(n - 1, n * a);
   0:000&gt;
   &gt;    5:         else if (n == 0)
   0:000&gt;
   &gt;    7:         else if (n == 1)
   0:000&gt;
   &gt;   10:                 return factorial(n - 1, n * a);
   0:000&gt;
   &gt;    5:         else if (n == 0)
   0:000&gt;
   &gt;    7:         else if (n == 1)
   0:000&gt;
   &gt;   10:                 return factorial(n - 1, n * a);
   0:000&gt;
   &gt;    5:         else if (n == 0)
   0:000&gt;
   &gt;    7:         else if (n == 1)
   0:000&gt;
   &gt;   10:                 return factorial(n - 1, n * a);
   0:000&gt;
   &gt;    5:         else if (n == 0)
   0:000&gt;
   &gt;    7:         else if (n == 1)
   0:000&gt;
   &gt;   10:                 return factorial(n - 1, n * a);
   0:000&gt;
   &gt;    5:         else if (n == 0)
   0:000&gt;
   &gt;    7:         else if (n == 1)
   0:000&gt;
   &gt;   10:                 return factorial(n - 1, n * a);
   0:000&gt;
   &gt;    5:         else if (n == 0)
   0:000&gt;
   &gt;    7:         else if (n == 1)
   0:000&gt;
   &gt;   10:                 return factorial(n - 1, n * a);
   0:000&gt;
   &gt;    5:         else if (n == 0)
   0:000&gt; k
   ChildEBP RetAddr
   0012ff64 0040105c recursive_factorial2!factorial+0x10
   0012ff70 00401266 recursive_factorial2!main+0xc
   0012ffc0 7c816fd7 recursive_factorial2!__tmainCRTStartup+0x15f
   0012fff0 00000000 kernel32!BaseProcessStart+0x23
   0:000&gt;
</pre>
<p>Como podemos ver, após n chamadas, a pilha continua apenas com uma chamada a factorial.</p>

<p>Para o GCC, a opção é mais explítica, e funciona da mesma forma.</p>

<pre>
   $ gcc -g -foptimize-sibling-calls  recursive-factorial2.c
   $ gdb a.exe
   ...
   (gdb) break factorial
   ...
   (gdb) run
   ...
   Breakpoint 1, factorial (n=1000, a=0) at recursive-factorial2.c:3
   3               if (n &lt; 0)
   (gdb) step
   5               else if (n == 0)
   (gdb)
   7               else if (n == 1)
   (gdb)
   10                      return factorial(n - 1, n * a);
   (gdb)
   11      }
   (gdb)
   factorial (n=1, a=6695656) at recursive-factorial2.c:10
   10                      return factorial(n - 1, n * a);
   (gdb)
   factorial (n=999, a=0) at recursive-factorial2.c:2
   2       {
   (gdb)
   Breakpoint 1, factorial (n=999, a=0) at recursive-factorial2.c:3
   3               if (n &lt; 0)
   (gdb)
   5               else if (n == 0)
   (gdb)
   7               else if (n == 1)
   (gdb)
   10                      return factorial(n - 1, n * a);
   (gdb)
   11      }
   (gdb)
   factorial (n=1, a=6695656) at recursive-factorial2.c:10
   10                      return factorial(n - 1, n * a);
   (gdb)
   factorial (n=998, a=0) at recursive-factorial2.c:2
   2       {
   (gdb)
   Breakpoint 1, factorial (n=998, a=0) at recursive-factorial2.c:3
   3               if (n &lt; 0)
   (gdb)
   5               else if (n == 0)
   (gdb)
   7               else if (n == 1)
   (gdb)
   10                      return factorial(n - 1, n * a);
   (gdb)
   11      }
   (gdb)
   factorial (n=1, a=6695656) at recursive-factorial2.c:10
   10                      return factorial(n - 1, n * a);
   (gdb)
   factorial (n=997, a=0) at recursive-factorial2.c:2
   2       {
   (gdb)
   Breakpoint 1, factorial (n=997, a=0) at recursive-factorial2.c:3
   3               if (n &lt; 0)
   (gdb)
   5               else if (n == 0)
   (gdb)
   7               else if (n == 1)
   (gdb)
   10                      return factorial(n - 1, n * a);
   (gdb)
   11      }
   (gdb)
   factorial (n=1, a=6695656) at recursive-factorial2.c:10
   10                      return factorial(n - 1, n * a);
   (gdb)
   factorial (n=996, a=0) at recursive-factorial2.c:2
   2       {
   (gdb)
   Breakpoint 1, factorial (n=996, a=0) at recursive-factorial2.c:3
   3               if (n &lt; 0)
   (gdb)
   5               else if (n == 0)
   (gdb)
   7               else if (n == 1)
   (gdb)
   10                      return factorial(n - 1, n * a);
   (gdb)
   11      }
   (gdb)
   factorial (n=1, a=6695656) at recursive-factorial2.c:10
   10                      return factorial(n - 1, n * a);
   (gdb) backtrace
   #0  factorial (n=1, a=6695656) at recursive-factorial2.c:10
   #1  0x61006198 in dll_crt0_1 () from /usr/bin/cygwin1.dll
   #2  0x61004416 in _cygtls::call2 () from /usr/bin/cygwin1.dll
   #3  0x00000000 in ?? ()
   (gdb)
</pre>
<p>Voilà!</p>

<p>PS: De brinde uma versão que permite passar o número via linha de comando para facilitar os testes (e você vai reparar que há um problema em calcular o fatorial de 1000: ele é estupidamente grande! Resolver isso fica como exercício =).</p>

<pre>
   #include &lt;stdio.h&gt;
   int factorial(int n, int a)
   {
       if (n &lt; 0)
           return 0;
       else if (n == 0)
           return 1;
       else if (n == 1)
           return a;
       else
           return factorial(n - 1, n * a);
   }
   int main(int argc, char* argv[])
   {
       if( argc == 2 )
       {
           int num = atoi(argv[1]);
           int ret = factorial(num, 1);
           printf(&quot;factorial %d = %d\n&quot;, num, ret);
           return ret;
       }
       else
       {
           printf(&quot;how to use: %s &lt;number&gt;\n&quot;, argv[0]);
           return 1;
       }
   }
</pre>
</section>

<span style="float: left;">
 <a href="terceiro_encontro_c++.html">[terceiro_encontro_c++]</a>
 <a href="encontrando_as_respostas_do_flash_pops.html">[encontrando_as_respostas_do_flash_pops]</a>
</span>
</div>
</div>
</section>
<footer class="footer">
<div class="container">
</div>
<div class="intentionally-blank"></div>
</footer>
</body>
</html>
