<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Blogue do Caloni</title>
<meta name="author" content="Caloni" />
<meta name="generator" content="https://github.com/caloni/journal">
<meta property="og:title" content="Blogue do Caloni"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="http://www.caloni.com.br"/>
<meta property="og:image" content="/blog/img/about-brand.png"/>
<meta property="og:description" content="Write for computers, people and food."/>
<link href="/blog/index.xml" rel="feed" type="application/rss+xml" title="Blogue do Caloni"/>
<link rel="stylesheet" type="text/css" href="/blog/css/custom.css"/>
<link rel="stylesheet" type="text/css" href="/blog/css/jquery-ui.css"/>
<script src="/blog/js/jquery-1.12.4.js"></script>
<script src="/blog/js/jquery-ui.js"></script>
<script src="/blog/js/copy_clipboard.js"></script>
<script src="/blog/js/list.js"></script>
<link rel="icon" href="/blog/img/favicon.ico"/>
</head>
<body style="min-height:100vh;display:flex;flex-direction:column">
<nav class="navbar has-shadow is-white"
role="navigation" aria-label="main navigation">
<div class="container">
<div class="navbar-brand">
&nbsp;
<a class="navbar-item" href="index.html">
<div class="is-4"><b>Blogue do Caloni</b></div>
</a>
</div>
</div>
</nav>
<div class="container">
<div class="column">
<div style="min-height:56vh">
<div style="padding-bottom: 1em;"></div>
<span id="codigos_de_entrevista_o_ponteiro_nulo" title="Códigos de entrevista - o ponteiro nulo"/></span>
<section id="section_codigos_de_entrevista_o_ponteiro_nulo">
<p class="title">Códigos de entrevista - o ponteiro nulo</p>
<span class="title-heading">Caloni, 2008-02-25 computer blog</span>

<p>Bom, parece que o "mother-fucker" wordpress ferrou com meu artigo sobre o Houaiss. Enquanto eu choro as pitangas aqui vai um outro artigo um pouco mais simples, mas igualmente interessante.</p>

<blockquote>"Wanderley, tenho umas sugestões para teu blog.</blockquote>

<blockquote>A primeira:</blockquote>

<blockquote>Que tal analisar o código abaixo e dizer se compila ou não. Se não compilar, explicar porquê não compila. Se compilar, o que acontecerá e por quê."</blockquote>
<p>O código é o que veremos abaixo:</p>

<pre>
   #include &lt;stdio.h&gt;
   #include &lt;stdlib.h&gt;
   void func()
   {
     *(int *)0 = 0;
     return 0;
   }
   int main(int argc, char **argv)
   {
     func();
     return 0;
   } 
</pre>
<p>Bem, para testar a compilação basta compilar. Porém, se estivermos em uma entrevista, geralmente não existe nenhum compilador em um raio de uma sala de reunião senão seu próprio cérebro.</p>

<p>E é nessas horas que os entrevistadores testam se você tem um bom cérebro ou um bom currículo.</p>

<p>Por isso, vamos analisar passo a passo cada bloco de código e entender o que pode estar errado. Se não encontrarmos, iremos supor que está tudo certo.</p>

<pre>
   #include &lt;stdio.h&gt;
   #include &lt;stdlib.h&gt;
</pre>
<p>Dois includes padrões, ultranormal, nada de errado aqui.</p>

<pre>
   void func()
   {
     *(int *)0 = 0;
     return 0;
   }
</pre>
<p>Duas ressalvas aqui: a primeira quanto ao retorno da função é void, porém a função retorna um inteiro. Na linguagem C, isso funciona, no máximo um warning do compilador. Em C++, isso é erro brabo de tipagem.</p>

<p>A segunda ressalva diz respeito à linha obscura, sintaticamente correta, mas cuja semântica iremos guardar para o final, já que ainda falta o main para analisar.</p>

<pre>
   int main(int argc, char **argv)
   {
       func();
       return 0;
   }
</pre>
<p>A clássica função inicial, nada de mais aqui. Retorna um int, e de fato retorna. Chama a função func, definida acima.</p>

<p>A linha que guardamos para analisar contém uma operação de casting, atribuição e deferência, sendo o casting executado primeiro, operador unário que é, seguido pelo segundo operador unário, a deferência. Como sempre, a atribuição é uma das últimas. Descomprimida a expressão dessa linha, ficamos com algo parecido com as duas linhas abaixo:</p>

<pre>
   int* p = (int*) 0;
   *p = 0;
</pre>
<p>Não tem nada de errado em atribuir o valor 0 a um ponteiro, que é equivalente ao define NULL da biblioteca C (e C++). De acordo com a <a href="https://ftp.gnu.org/old-gnu/Manuals/glibc-2.2.5/html_node/Null-Pointer-Constant.html">referência GNU</a>, é recomendado o uso do define, mas nada impede utilizar o 0 "hardcoded".</p>

<p>Porém, estamos escrevendo em um ponteiro nulo, o que com certeza é um comportamento não-definido de conseqüências provavelmente funestas. O ponteiro nulo é um ponteiro inválido que serve apenas para marcar um ponteiro como inválido. Se escrevermos em um endereço inválido, bem, não é preciso ler o padrão para saber o que vai acontecer =)</p>

<p>Alguns amigos me avisaram sobre algo muito pertinente: dizer que acessar um ponteiro nulo, portanto inválido, é errado e nunca deve ser feito. Como um ponteiro nulo aponta para um endereço de memória inválido, acessá-lo irá gerar uma exceção no seu sistema operacional e fazer seu programa capotar. Um ponteiro nulo é uma maneira padrão e confiável de marcar o ponteiro como inválido, e testar isso facilmente através de um if. Mais uma vez: ponteiros nulos apontando para um endereço de memória inválido (o endereço 0) nunca devem ser acessados, apenas atribuído a ponteiros.</p>

<p>Em código. Isso pode:</p>

<pre>
   int* p = 0; // atribuindo nulo a um ponteiro
   int* p2 = p; // isso também pode
</pre>
<p>Isso não pode:</p>

<pre>
   *p = 15; // nunca acessar ponteiros nulos
   int x = *p; // isso também não pode, ler de um ponteiro nulo
</pre>
<p>Dito isso, me sinto melhor =)</p>

<h2>Update 2008-02-29: Quando o ponteiro nulo não é inválido</h2>

<p>Existe coisa mais prazerosa do que admitir um erro que foi cometido na mesma semana? Existe: quando você sabia que estava certo, mas resolveu usar o senso comum por falta de provas.</p>

<p>Pois bem. O mesmo amigo que me recomendou que escrevesse sobre o assunto do ponteiro nulo achou um livro sobre <a href="http://www.literateprogramming.com/ctraps.pdf">armadilhas em C</a> com um exemplo que demonstra exatamente o contrário: dependendo da plataforma, ponteiros nulos são sim válidos.</p>

<p>Nesse caso, se tratava de um programa que iria rodar em um microprocessador, daqueles que o <a href="http://dqsoft.blospot.com">DQ</a> costuma programar. Pois bem. Quando o dito cujo ligava era necessário chamar uma rotina que estava localizada exatamente no endereço 0. Para fazer isso, o código era o seguinte:</p>

<pre>
   ( * (void(*)()) 0 ) ();
</pre>
<p>Nada mais simples: um cast do endereço 0 (apesar de normalmente inválido, 0 pode ser convertido para endereço) para ponteiro de função que não recebe parâmetros e não retorna nada, seguido de deferência ("o apontado de") e chamada (a dupla final de parênteses). A linha acima é o equivalente às linhas abaixo:</p>

<pre>
   typedef void (*func_t)();
   func_t func = (func_t) 0;
   func();
</pre>
<p>É bem o que o autor diz depois de jogar esta expressão: "expressions like these strike terror into the hearts of C programmers". É lógico que isso não é bem verdade para as pessoas que acompanham este blogue =)</p>

</section>

<span style="float: left;">
 <a href="conversor_de_houaiss_para_babylon_parte_1.html">[conversor_de_houaiss_para_babylon_parte_1]</a>
 <a href="configurando_seus_projetos_no_visual_studio_para_rodar_em_outras_maquinas.html">[configurando_seus_projetos_no_visual_studio_para_rodar_em_outras_maquinas]</a>
</span>
</div>
</div>
</section>
<footer class="footer">
<div class="container">
</div>
<div class="intentionally-blank"></div>
</footer>
</body>
</html>
