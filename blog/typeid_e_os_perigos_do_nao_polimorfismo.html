<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Blogue do Caloni</title>
<meta name="author" content="Caloni" />
<meta name="generator" content="https://github.com/caloni/journal">
<meta property="og:title" content="Blogue do Caloni"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="http://www.caloni.com.br"/>
<meta property="og:image" content="/blog/img/about-brand.png"/>
<meta property="og:description" content="Write for computers, people and food."/>
<link href="/blog/index.xml" rel="feed" type="application/rss+xml" title="Blogue do Caloni"/>
<link rel="stylesheet" type="text/css" href="/blog/css/custom.css"/>
<link rel="stylesheet" type="text/css" href="/blog/css/jquery-ui.css"/>
<script src="/blog/js/jquery-1.12.4.js"></script>
<script src="/blog/js/jquery-ui.js"></script>
<script src="/blog/js/copy_clipboard.js"></script>
<script src="/blog/js/list.js"></script>
<link rel="icon" href="/blog/img/favicon.ico"/>
</head>
<body style="min-height:100vh;display:flex;flex-direction:column">
<nav class="navbar has-shadow is-white"
role="navigation" aria-label="main navigation">
<div class="container">
<div class="navbar-brand">
&nbsp;
<a class="navbar-item" href="index.html">
<div class="is-4"><b>Blogue do Caloni</b></div>
</a>
</div>
</div>
</nav>
<div class="container">
<div class="column">
<div style="min-height:56vh">
<div style="padding-bottom: 1em;"></div>
<span id="typeid_e_os_perigos_do_nao_polimorfismo" title="Typeid e os perigos do não-polimorfismo"/></span>
<section id="section_typeid_e_os_perigos_do_nao_polimorfismo">
<p class="title">Typeid e os perigos do não-polimorfismo</p>
<span class="title-heading">Caloni, 2007-10-24 computer ccpp blog</span>

<p>Quando usamos o operador typeid geralmente desejamos conhecer informações sobre o tipo exato do objeto que temos em mãos, independente da hierarquia de herança a qual seu tipo pertença. Só que por ignorar, assim como o <a href="what_happens_inside_the_sizeof_operator.html">sizeof</a>, que esse operador possui duas caras, às vezes damos com os burros n'água e compramos gato por lebre. Não é pra menos. Uma sutil diferença entre classes polimórficas e estáticas pode dar aquele susto que só C++ pode proporcionar.</p>

<p>Eis um exemplo singelo, sem dramatização (com dramatização == "500 linhas de código de produção além do código abaixo").</p>

<pre>
   #include &lt;iostream&gt;
   #include &lt;typeinfo&gt;
   using namespace std;
   class Base
   {
   public:
     Base()
     {
       cout &lt;&lt; &quot;Base()\n&quot;;
       m_x = 0;
     }
     ~Base()
     {
       cout &lt;&lt; &quot;~Base()\n&quot;;
     }
     int m_x;
   };
   class Deriv : public Base
   {
   public:
     Deriv()
     {
       cout &lt;&lt; &quot;Deriv()\n&quot;;
       m_x = 1;
       m_y = 0;
     }
     virtual ~Deriv()
     {
       cout &lt;&lt; &quot;~Deriv()\n&quot;;
     }
     int m_y;
   };
   void func(Base* b)
   {
     cout &lt;&lt; typeid(*b).name() &lt;&lt; '\n';
   }
   int main()
   {
     Base* b = new Deriv();
     func(b);
   } 
</pre>
<p>O typeid usado nesse exemplo será o estático, no estilo typeid(type), porque o tipo do objeto para a função é de "ponteiro para objeto de classe não-polimórfica", ou seja, sem nenhuma função virtual. É importante lembrar que o polimorfismo em C++ só é aplicado se houver razão para tal, pois na linguagem a regra é que "não existe sobrecarga de execução sem que o programador queira":</p>

<pre>
   &gt;./program
   Base()
   Deriv()
   class Base
</pre>
<p>Se o esperado pelo programador fosse um class Deriv na última linha da saída, ou seja, que o typeid utilizado fosse a versão dinâmica, então a nossa classe Base tem que ser polimórfica:</p>

<pre>
   virtual ~Base()
   {
     cout &lt;&lt; &quot;~Base()\n&quot;;
   } 
</pre>
<p>Esse é um erro equivalente ao chamar o operador delete usando o ponteiro recebido em func. Se isso fosse feito, seria chamado apenas o destrutor da classe Base. Por falar nisso, temos nesse exemplo um leak de memória (percebeu pela saída que os destrutores não são chamados?). Mas esse é um erro bem menos sutil que o visto pelo nosso amigo typeid amigo-da-onça ;).</p>

<pre>
   &gt;./program
   Base()
   Deriv()
   class Deriv
</pre>
</section>

<span style="float: left;">
 <a href="protecao_dos_membros_protected.html">[protecao_dos_membros_protected]</a>
 <a href="guia_basico_para_programadores_de_primeiro_breakpoint.html">[guia_basico_para_programadores_de_primeiro_breakpoint]</a>
</span>
</div>
</div>
</section>
<footer class="footer">
<div class="container">
</div>
<div class="intentionally-blank"></div>
</footer>
</body>
</html>
