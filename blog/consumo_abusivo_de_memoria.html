<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Blogue do Caloni</title>
<meta name="author" content="Caloni" />
<meta name="generator" content="https://github.com/caloni/journal">
<meta property="og:title" content="Blogue do Caloni"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="http://www.caloni.com.br"/>
<meta property="og:image" content="/blog/img/about-brand.png"/>
<meta property="og:description" content="Write for computers, people and food."/>
<link href="/blog/index.xml" rel="feed" type="application/rss+xml" title="Blogue do Caloni"/>
<link rel="stylesheet" type="text/css" href="/blog/css/custom.css"/>
<link rel="stylesheet" type="text/css" href="/blog/css/jquery-ui.css"/>
<script src="/blog/js/jquery-1.12.4.js"></script>
<script src="/blog/js/jquery-ui.js"></script>
<script src="/blog/js/copy_clipboard.js"></script>
<script src="/blog/js/list.js"></script>
<link rel="icon" href="/blog/img/favicon.ico"/>
</head>
<body style="min-height:100vh;display:flex;flex-direction:column">
<nav class="navbar has-shadow is-white"
role="navigation" aria-label="main navigation">
<div class="container">
<div class="navbar-brand">
&nbsp;
<a class="navbar-item" href="index.html">
<div class="is-4"><b>Blogue do Caloni</b></div>
</a>
</div>
</div>
</nav>
<div class="container">
<div class="column">
<div style="min-height:56vh">
<div style="padding-bottom: 1em;"></div>
<span id="consumo_abusivo_de_memoria" title="Consumo abusivo de memória"/></span>
<section id="section_consumo_abusivo_de_memoria">
<p class="title">Consumo abusivo de memória</p>
<span class="title-heading">Caloni, 2012-05-19 computer blog</span>

<p>Era um belo dia em um ambiente de processamento fictício de filas fictícias e threads fictícias. Eis um belo código com filas, threads e processamentos feitos em stop-motion:</p>

<pre>
#include &lt;windows.h&gt; // critical section, create thread...
#include &lt;list&gt; // nossa lista interna
#include &lt;time.h&gt; // randomização

struct Queue // uma fila (duh)
{
    size_t bufferSize; // cada item é um buffer de tamanho fixo
    DWORD wait; // antes de processar, aguardemos esse tempo fixo
    CRITICAL_SECTION cs; // stl é thread-safe, pero no mucho
    std::list&lt;char*&gt; items; // os itens!
};

DWORD WINAPI InsertItems(LPVOID pvQueue) // insere, insere, insere....
{
    Queue&amp; queue = *(Queue*) pvQueue;
    for( int i = 0; i &lt; 10 * 1000; ++i ) // 10k itens!
    {
        char* buffer = new char[queue.bufferSize];
        memset(buffer, (int) (i % ('Z' - 'A')) + 'A', queue.bufferSize); // teoricamente de A a Z
        buffer[queue.bufferSize - 1] = 0; // string C pra facilitar nossa depuração
        EnterCriticalSection(&amp;queue.cs); // deixa eu entrar!
        queue.items.push_back(buffer);
        LeaveCriticalSection(&amp;queue.cs); // deixa eu sair!
        Sleep(10); // dá uma dormidinha (sempre menor dormidinhas do processamento)
    }
    return ERROR_SUCCESS; // &quot;tá tudo certo!&quot; (by Starcraft 2)
}

DWORD WINAPI ProcessItems(LPVOID pvQueue) // processa, processa, processa...
{
    Queue&amp; queue = *(Queue*) pvQueue;
    DWORD wait = 2;
    Sleep(10000); // como um advogado oportunista, aguardamos por alguém pra processar
    while( ! queue.items.empty() ) // agora vai até esvaziar o recinto
    {
        EnterCriticalSection(&amp;queue.cs); // deixa eu entrar!
        char* buffer = queue.items.front();
        queue.items.pop_front();
        LeaveCriticalSection(&amp;queue.cs); // deixa eu sair!
        delete [] buffer;
        Sleep(queue.wait); // aguarda por... por quanto mesmo?
    }
    return ERROR_SUCCESS; // &quot;tá tudo certo!&quot; (by Starcraft 2)
}

int main(int argc, char* argv[]) // No princípio havia a pilha, quando Deus disse: 'int main!'
{
    static const size_t QUEUES_SIZE = 20; // número de filas sendo processadas
    static const size_t QUEUE_ITEM_SIZE = 0x1000; // 1KB é o chunk alocado por item
    static const DWORD WAIT_TIMES[] = { 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 1000 }; // alguém vai esperar demais

    Queue queues[QUEUES_SIZE]; // as filas
    HANDLE queueThreads[QUEUES_SIZE * 2]; // as threads que processam as filas

    srand((unsigned int)time(0)); // randomizemos tudo

    for( size_t i = 0; i &lt; QUEUES_SIZE; ++i )
    {
        queues[i].bufferSize = QUEUE_ITEM_SIZE + i; // para diferenciarmos as filas
        queues[i].wait = WAIT_TIMES[ rand() % (sizeof(WAIT_TIMES) / sizeof(DWORD)) ]; // vamos esperar por... por quanto mesmo?
        InitializeCriticalSection(&amp;queues[i].cs); // deu crash em algumas situações em release (stl deveria ser thread-safe...)
        queueThreads[i] = CreateThread(NULL, 0, InsertItems, &amp;queues[i], 0, NULL); // criamos thread de inserção
        queueThreads[QUEUES_SIZE + i] = CreateThread(NULL, 0, ProcessItems, &amp;queues[i], 0, NULL); // criamos thread de processamento
    }

    WaitForMultipleObjects(QUEUES_SIZE * 2, queueThreads, TRUE, INFINITE); // espera a 'gaguera'
    return 0; // &quot;tá tudo certo!&quot; (by Starcraft 2)
}
</pre>
<p>Se olharmos de perto o processamento e a memória consumida por esse processo, veremos que no início existe um boom de ambos, mas após um momento de pico, o processamento praticamente pára, mas a memória se mantém:</p>

<img src="/blog/img/consumo_abusivo_de_memoria_hoxWfdi.png"/>

<p>Depois de pesquisar por meus tweets favoritos, fica fácil ter a receita para verificarmos isso usando nosso depurador favorito: ~~Visual Studio~~ WinDbg!</p>

<img src="/blog/img/consumo_abusivo_de_memoria_ZKVVT0O.png"/>

<p>windbg -pn MemoryConsumption.exe</p>

<img src="/blog/img/consumo_abusivo_de_memoria_Bzb2XVY.png"/>

<p>Achamos onde está a memória consumida. Agora precisamos de dicas do que pode estar consumindo essa memória. Vamos começar por listar os chunks alocados por tamanho de alocação:</p>

<pre>
0:004&gt; !heap -stat -h 0
Allocations statistics for
 heap @ 00670000
group-by: TOTSIZE max-display: 20

size #blocks total ( %) (percent of total busy bytes)
1037 25e5 - 2667433 (33.04)
1025 25e6 - 263da3e (32.90)
1024 25e4 - 2639410 (32.89)
...
</pre>
<p>O Top 3 é de tamanhos conhecidos pelo código, de 1024 a 1024 + QUEUES_SIZE - 1. O de tamanho 1037, por exemplo, possui 0x25e5 blocos alocados. Vamos listar cada um deles:</p>

<pre>
0:004&gt; !heap -flt s 1037
 _HEAP @ 420000
 _HEAP @ 670000
 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state
&lt;span style=&quot;color: #ff0000;&quot;&gt; 00558600 0221 0000 [00] 00558618 01037 - (busy)&lt;/span&gt;         &lt;--- vamos usar esse primeiro mais tarde
 0055fd38 0221 0221 [00] 0055fd50 01037 - (busy)
 00561f48 0221 0221 [00] 00561f60 01037 - (busy)
 00565260 0221 0221 [00] 00565278 01037 - (busy)
 0056c998 0221 0221 [00] 0056c9b0 01037 - (busy)
 0056daa0 0221 0221 [00] 0056dab8 01037 - (busy)
 0056eba8 0221 0221 [00] 0056ebc0 01037 - (busy)
 00570db8 0221 0221 [00] 00570dd0 01037 - (busy)
 00572fc8 0221 0221 [00] 00572fe0 01037 - (busy)
 005740d0 0221 0221 [00] 005740e8 01037 - (busy)
 0058abc8 0221 0221 [00] 0058abe0 01037 - (busy)
 00595618 0221 0221 [00] 00595630 01037 - (busy)
 00599a38 0221 0221 [00] 00599a50 01037 - (busy)
 0059de58 0(...)
</pre>
<p>A listagem do depurador nos dá o endereço onde o chunk foi alocado no heap e o endereço devolvido para o usuário, onde colocamos nossas tralhas. Através de ambos é possível trackear a pilha da chamada que alocou cada pedaço de memória. Isso, claro, se previamente tivermos habilitado essa informação através do <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/gflags">GFlags</a>:</p>

<img src="/blog/img/consumo_abusivo_de_memoria_JeqoBju.png"/>

<pre>
0:004&gt; !heap -p -a &lt;span style=&quot;color: #ff0000;&quot;&gt;00558600&lt;/span&gt;
 address 00558600 found in
 _HEAP @ 670000
 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state
 &lt;span style=&quot;color: #ff0000;&quot;&gt;00558600 0221 0000 [00] 00558618 01037 - (busy)&lt;/span&gt;
 Trace: b7a24
 7722dfa2 ntdll!RtlAllocateHeap+0x00000274
 5b628343 MSVCR100D!_heap_alloc_base+0x00000053
 5b63697c MSVCR100D!_nh_malloc_dbg+0x000002dc
 5b63671f MSVCR100D!_nh_malloc_dbg+0x0000007f
 5b6366cc MSVCR100D!_nh_malloc_dbg+0x0000002c
 5b639c5b MSVCR100D!malloc+0x0000001b
 5b627db1 MSVCR100D!operator new+0x00000011
 e84dee MemoryConsumption!operator new[]+0x0000000e
&lt;span style=&quot;color: #ff0000;&quot;&gt; e818be MemoryConsumption!InsertItems+0x0000004e&lt;/span&gt;
 7679339a kernel32!BaseThreadInitThunk+0x0000000e
 771e9ef2 ntdll!__RtlUserThreadStart+0x00000070
 771e9ec5 ntdll!_RtlUserThreadStart+0x0000001b
</pre>
<p>Dessa forma temos onde cada memória foi alocada, o que nos dará uma informação valiosa, dependendo qual o tipo de problema estamos tentando resolver.</p>

<pre>
0:004&gt; u &lt;span style=&quot;color: #ff0000;&quot;&gt;e818be&lt;/span&gt;
MemoryConsumption!InsertItems+0x4e [c:\...\memoryconsumption.cpp @ 18]:
00e818be 83c404 add esp,4
00e818c1 898514ffffff mov dword ptr [ebp-0ECh],eax
00e818c7 8b9514ffffff mov edx,dword ptr [ebp-0ECh]
00e818cd 8955e0 mov dword ptr [ebp-20h],edx
00e818d0 8b45f8 mov eax,dword ptr [ebp-8]
00e818d3 8b08 mov ecx,dword ptr [eax]
00e818d5 51 push ecx
00e818d6 8b45ec mov eax,dword ptr [ebp-14h]
</pre>
<p>Outra informação relevante é o que está gravado na memória, que pode nos dar insights de que tipo de objeto estamos lidando:</p>

<pre>
0:004&gt; db &lt;span style=&quot;color: #ff0000;&quot;&gt;00558618&lt;/span&gt;
00558618 c0 b7 8c 0b 98 03 55 00-00 00 00 00 00 00 00 00 ......U.........
00558628 13 10 00 00 01 00 00 00-15 94 00 00 fd fd fd fd ................
00558638 51 51 51 51 51 51 51 51-51 51 51 51 51 51 51 51 QQQQQQQQQQQQQQQQ
00558648 51 51 51 51 51 51 51 51-51 51 51 51 51 51 51 51 QQQQQQQQQQQQQQQQ
00558658 51 51 51 51 51 51 51 51-51 51 51 51 51 51 51 51 QQQQQQQQQQQQQQQQ
00558668 51 51 51 51 51 51 51 51-51 51 51 51 51 51 51 51 QQQQQQQQQQQQQQQQ
00558678 51 51 51 51 51 51 51 51-51 51 51 51 51 51 51 51 QQQQQQQQQQQQQQQQ
00558688 51 51 51 51 51 51 51 51-51 51 51 51 51 51 51 51 QQQQQQQQQQQQQQQQ
</pre>
<p>Não é o caso, mas vamos supor que fosse um objeto/tipo conhecido. Poderíamos simplesmente "importar" o tipo diretamente do PDB que estamos para modelar a memória que encontramos em volta. Mais detalhes <a href="importando_tipos_de_outros_projetos.html">em outro artigo</a>.</p>

<p>Funções/classes usadas nesse artigo: <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread">CreateThread</a> (cria uma nova linha de execução), <a href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects">WaitForMultipleObjects</a> (pode aguardar diferentes linhas de execução terminarem), <a href="https://en.cppreference.com/w/cpp/container/list.html">std::list</a> (lista na STL para inserir/remover objetos na frente e atrás (ui)), <a href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-initializecriticalsection">Initialize</a>, <a href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-entercriticalsection">Enter</a> e <a href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-leavecriticalsection">LeaveCriticalSection</a> (uma maneira simples de criar blocos de entrada atômica, ou seja, apenas uma thread entra por vez) e <a href="https://en.cppreference.com/w/cpp/string/byte/memset">memset</a>. Se você não sabe usar memset, provavelmente não entendeu nada desse artigo.</p>

</section>

<span style="float: left;">
 <a href="base64.html">[base64]</a>
</span>
</div>
</div>
</section>
<footer class="footer">
<div class="container">
</div>
<div class="intentionally-blank"></div>
</footer>
</body>
</html>
