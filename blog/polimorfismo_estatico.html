<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Blogue do Caloni</title>
<meta name="author" content="Caloni" />
<meta name="generator" content="https://github.com/caloni/journal">
<meta property="og:title" content="Blogue do Caloni"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="http://www.caloni.com.br"/>
<meta property="og:image" content="/blog/img/about-brand.png"/>
<meta property="og:description" content="Write for computers, people and food."/>
<link href="/blog/index.xml" rel="feed" type="application/rss+xml" title="Blogue do Caloni"/>
<link rel="stylesheet" type="text/css" href="/blog/css/custom.css"/>
<link rel="stylesheet" type="text/css" href="/blog/css/jquery-ui.css"/>
<script src="/blog/js/jquery-1.12.4.js"></script>
<script src="/blog/js/jquery-ui.js"></script>
<script src="/blog/js/copy_clipboard.js"></script>
<script src="/blog/js/list.js"></script>
<link rel="icon" href="/blog/img/favicon.ico"/>
</head>
<body style="min-height:100vh;display:flex;flex-direction:column">
<nav class="navbar has-shadow is-white"
role="navigation" aria-label="main navigation">
<div class="container">
<div class="navbar-brand">
&nbsp;
<a class="navbar-item" href="index.html">
<div class="is-4"><b>Blogue do Caloni</b></div>
</a>
</div>
</div>
</nav>
<div class="container">
<div class="column">
<div style="min-height:56vh">
<div style="padding-bottom: 1em;"></div>
<span id="polimorfismo_estatico" title="Polimorfismo estático"/></span>
<section id="section_polimorfismo_estatico">
<p class="title">Polimorfismo estático</p>
<span class="title-heading">Caloni, 2009-07-10 computer blog</span>

<p>Para explicar polimorfismo, nada como ver as coisas como elas eram. Se você fosse um programador C de vinte anos atrás e criasse as seguintes funções:</p>

<pre>
int soma(int x, int y);
double soma(double x, double y);

int main()
{
    int zi = soma(2, 3);
    double zd = soma(2.5, 3.4);
    return 0;
}
</pre>
<p>Imediatamente o compilador iria acusar os seguintes erros:</p>

<pre>
overload.c

overload.c(2) : warning C4028: formal parameter 1 different from declaration
overload.c(2) : warning C4028: formal parameter 2 different from declaration
overload.c(2) : error C2371: 'soma' : redefinition; different basic types
        overload.c(1) : see declaration of 'soma'
</pre>
<p>Isso acontece porque em C os identificadores são únicos por escopo. Esse é o motivo por que o seguinte código também está errado:</p>

<pre>
int main()
{
    int x = 0;
    int x = 1;
    return 0;
}
overload.c
overload.c(5) : error C2374: 'x' : redefinition; multiple initialization
        overload.c(4) : see declaration of 'x'
</pre>
<p>De volta aos anos 90, isso também está errado em C++. Até por uma questão de lógica: como o compilador pode saber a qual variável estamos nos referindo se usarmos o mesmo nome para duas delas?</p>

<p>Só que existe um truquezinho para impedir essa ambiguidade quando falamos de funções: os parâmetros que ela recebe.</p>

<pre>
int soma(int x, int y);
double soma(double x, double y);

int main()
{
    int zi = soma(2, 3); // dois tipos int: chamar soma(int, int)
    double zd = soma(2.5, 3.4); // dois tipos double: só pode ser soma(double, double)
    return 0;
}
C:\Tests&gt;cl /c overload.cpp
Microsoft (R) 32-bit C/C++ Optimizing Compiler Version 13.10.6030 for 80x86
Copyright (C) Microsoft Corporation 1984-2002. All rights reserved.

overload.cpp

C:\Tests&gt;
</pre>
<p>Isso permitiu que em C++ fosse criada a sobrecarga estática, que é exatamente isso: chamar a função não apenas de acordo com seu nome, mas também de acordo com sua assinatura, ou seja, o número e o tipo dos parâmetros recebidos. Chamamos de sobrecarga estática porque isso é feito apenas pelo compilador, não pesando em nada durante a execução do programa.</p>

<p>Entre seus usos mais comuns estão os seguintes:</p>

<p>Ter funções com o mesmo nome mas que tratam de diferentes parâmetros;</p>

<pre>
soma(int, int);
soma(double, double);
</pre>
<p>Obs.: Isso ignora, é claro, as facilidades dos templates.</p>

<p>Versões novas da mesma função que recebem parâmetros adicionais;</p>

<pre>
export_data(void* buffer, int size);
export_data(void* buffer, int size, unsigned long options);
</pre>
<p>Mesmo nome de método para setar e obter o valor de uma propriedade;</p>

<pre>
Class::Property(int x); // setter
int x Class::Property() const; // getter
</pre>
<p>Bom, o que mais sua imaginação mandar =)</p>

</section>

<span style="float: left;">
 <a href="static_polymorphism.html">[static_polymorphism]</a>
 <a href="como_funcionam_as_strings.html">[como_funcionam_as_strings]</a>
</span>
</div>
</div>
</section>
<footer class="footer">
<div class="container">
</div>
<div class="intentionally-blank"></div>
</footer>
</body>
</html>
