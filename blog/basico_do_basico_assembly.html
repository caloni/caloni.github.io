<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Blogue do Caloni</title>
<meta name="author" content="Caloni" />
<meta name="generator" content="https://github.com/caloni/journal">
<meta property="og:title" content="Blogue do Caloni"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="http://www.caloni.com.br"/>
<meta property="og:image" content="/blog/img/about-brand.png"/>
<meta property="og:description" content="Write for computers, people and food."/>
<link href="/blog/index.xml" rel="feed" type="application/rss+xml" title="Blogue do Caloni"/>
<link rel="stylesheet" type="text/css" href="/blog/css/custom.css"/>
<link rel="stylesheet" type="text/css" href="/blog/css/jquery-ui.css"/>
<script src="/blog/js/jquery-1.12.4.js"></script>
<script src="/blog/js/jquery-ui.js"></script>
<script src="/blog/js/copy_clipboard.js"></script>
<script src="/blog/js/list.js"></script>
<link rel="icon" href="/blog/img/favicon.ico"/>
</head>
<body style="min-height:100vh;display:flex;flex-direction:column">
<nav class="navbar has-shadow is-white"
role="navigation" aria-label="main navigation">
<div class="container">
<div class="navbar-brand">
&nbsp;
<a class="navbar-item" href="index.html">
<div class="is-4"><b>Blogue do Caloni</b></div>
</a>
</div>
</div>
</nav>
<div class="container">
<div class="column">
<div style="min-height:56vh">
<div style="padding-bottom: 1em;"></div>
<span id="basico_do_basico_assembly" title="Básico do básico: assembly"/></span>
<section id="section_basico_do_basico_assembly">
<p class="title">Básico do básico: assembly</p>
<span class="title-heading">Caloni, 2009-01-26 computer blog</span>

<p>É lógico que não poderia faltar no cinto de utilidades de todo bom programador C conhecimentos básicos da linguagem assembly, sua mãe espiritual. São tantos conceitos em comum que, uma vez aprendido seu funcionamento, fica difícil não pensar no código-assembly gerado pelo compilador C. E é nesse ponto que as coisas começam a ficar mais claras.</p>

<p>Antes de tudo, é importantíssimo lembrar que o foco aqui é apenas a arquitetura 8086, um dos marcos na invenção de computadores de massa, mas que existem trocentros outros modelos de processadores e computadores funcionando mundo afora. Não deixe sua mente fechar para os outros tipos de modelos.</p>

<p>A CPU trabalha em conjunto com a memória RAM. Só que o acesso à essa memória, apesar de rápida, não é comparável à velocidade em que as coisas ocorrem dentro da própria CPU. Esse é apenas um dos motivos para a existência de um conjunto bem menor de memória que vive nas entranhas do processador, bem ao lado dele. São os chamados registradores.</p>

<img src="/blog/img/basico_do_basico_assembly_kcKufIn.gif"/>

<p>Os registradores são memória do tipo ultra-rápida que funciona no mesmo ritmo do processador. A maioria das instruções executadas pela CPU faz referência a pelo menos um registrador. E por um motivo muito simples: é o modelo de entrada-e-saída funcionando!</p>

<p>No modelo de entrada-e-saída, ultrassimplificado por mim nesse artigo, o processador executa microinstruções muito básicas, que juntas fazem alguma coisa de útil, por exemplo, somar dois números:</p>

<p>x = y + z;</p>

<p>A operação acima é realizada através de microinstruções bem sucintas:</p>

<p>  1. Leia memória y para registrador 1</p>

<p>  2. Leia memória z para registrador 2</p>

<p>  3. Some valor de registrador 1 e 2 e coloque resultado no registrador 1</p>

<p>  4. Carregue memória x com valor do registrador 1</p>

<img src="/blog/img/basico_do_basico_assembly_N90ooMD.gif"/>

<p>É lógico que o sistema não se baseia apenas em movimentações simples de memória. Existem algumas abstrações que estão incrustadas no funcionamento da arquitetura. Uma das mais importantes é o conceito de pilha, vital tanto em arquitetura, quanto assembly, quanto linguagem C e muitas outras linguagens, também.</p>

<p>Pilha é uma forma de armazenar memória em blocos empilhados um-a-um. Esses blocos são empilhados na ordem a, b, c e desempilhados na ordem c, b, a. Ou seja, quem foi empilhado por último será o primeiro a ser desempilhado. A analogia com uma pilha de pratos é óbvia e simples de imaginar.</p>

<img src="/blog/img/basico_do_basico_assembly_EmiZKdc.gif"/>

<img src="/blog/img/basico_do_basico_assembly_wZ6kKs8.jpg"/>

<p>Para isso funcionar em termos de memória computacional, o programa reserva um espaço de memória com começo e fim que irá guardar os blocos empilhados. Além de ter começo e fim é necessário ter um marcador de onde estamos para empilhar o próximo item ou desempilhar o último.</p>

<p>Se você pensou rápido, a resposta é sim, existem registradores para guardar a posição na pilha em que estamos. Aliás, quando mudamos de função, o valor desses registradores é salvo na própria pilha, já que voltaremos à mesma posição após a chamada.</p>

<blockquote>Um passado distante. Antigamente eram muito usados os chamados registradores de segmento. Eles representavam o endereçamento da arquitetura de 16 bits do 8086. Cada endereço de memória estava localizado em um segmento, que era uma abstração para multiplicar a memória e assim alcançar a quantidade de RAM que estava disponível no sistema. Com a chegada do 32 bits, isso não é mais usado, pelo menos diretamente (ainda existem segmentos em 32 ou 64 bits), pelos programadores, que não têm que se preocupar mais tanto com esses detalhes internos da memória.</blockquote>
<p>Resumidamente, temos no PC os seguintes tipos de registradores e seu uso geral na programação C:</p>

<ul><li>Registradores de uso geral: EAX, EBX, ECX, EDX.</li>

<li>Registradores de código e dados: ESP, EBP, EIP.</li></ul>

<p>Você os verá em 90% das ocasiões em que desassemblar seu código C, pois a rotina do código não muda muito: soma, divide, multiplica, muda endereço do código (saltos), compara valores (flags).</p>

<h4>Flags?</h4>

<p>Ah, sim, as flags! Elas são importantíssimas para o funcionamento sadio de nossos programas. Sem as flags, não teríamos coisas maravilhosas e fundamentais na programação moderna, tais como o salto condicional.</p>

<p>As flags são bits que mudam de acordo com algumas instruções, principalmente as de comparação (vide cmp). Após a execução de comparação, o estado de determinadas flags junto da próxima instrução (que deverá ser um salto condicional) irá dizer para onde o programa irá pular sua execução. É assim que temos o if:</p>

<pre>
   if( x == 10 )
     XEhIgualA10();
   else
     XEhDiferenteDe10();
</pre>
<p>O código acima seria representado em assembly mais ou menos como abaixo:</p>

<p>  1. carrega valor de x no registrador 1</p>

<p>  2. compara registrador 1 com 10</p>

<p>  3. pula para 6 se for diferente</p>

<p>  4. chama XEhIgualA10</p>

<p>  5. pula para 7</p>

<p>  6. chama XEhDiferenteDe10</p>

<p>  7. próxima instrução</p>

<blockquote>Uma curiosidade interessante é a flag de comparação. Se o resultado da comparação disser que os dois elementos são iguais, a flag fica igual a zero, o que significa que os comparandos são idênticos. Se você reparar, a mesma semântica é utilizada na conhecida função strcmp, que retorna zero caso duas strings sejam idênticas. Isso faz sentido em ambos os lados, já que o resultado computacional geralmente deixa um rastro de diferença que é usado como retorno. Se esse rastro não existir, quer dizer que o que foi comparado é idêntico.</blockquote>
<h4>Opcodes para aprender:</h4>

<ul><li>mov</li>

<li>cmp</li>

<li>jmp</li>

<li>jne, jle, jnz, etc</li>

<li>push e pop</li>

<li>call e ret</li></ul>

<h4>Pedaços de código que vale a pena estudar:</h4>

<pre>
   push ebp
   mov epb, esp
   push eax
   mov ecx, dword ptr[variavel]
   push 10
   call funcao
   cmp something
   jne | jae | ...
</pre>
<h4>O que é legal de fazer para treinar assembly</h4>

<p>Desmonte programas, chamadas API. Veja que funções internas elas chamam para realizar determinada tarefa. Tente mudar o comportamento do programa para provar que suas observações sobre o funcionamento estavam corretas.</p>

<p>PS.: Ia me esquecendo. Enquanto estava escrevendo este artigo, um <a href="http://dqsoft.blogspot.com/2009/01/simulando-um-computador-14.html">conjunto</a> <a href="http://dqsoft.blogspot.com/2009/01/simulando-um-computador-24.html">bem</a> <a href="http://dqsoft.blogspot.com/2009/01/simulando-um-computador-34.html">mais</a> <a href="http://dqsoft.blogspot.com/2009/01/simulando-um-computador-44.html">detalhado</a> de artigos estava sendo publicado pelo DQ. Recomendo veementemente sua leitura.</p>

</section>

<span style="float: left;">
 <a href="as_funcoespolegar.html">[as_funcoespolegar]</a>
 <a href="basico_do_basico_binario.html">[basico_do_basico_binario]</a>
</span>
</div>
</div>
</section>
<footer class="footer">
<div class="container">
</div>
<div class="intentionally-blank"></div>
</footer>
</body>
</html>
