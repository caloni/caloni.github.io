<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta http-equiv="default-style" content="text/html; charset=utf-8"/>
<title>2009-07</title>
<link rel="stylesheet" href="css/stylesheet.css" type="text/css" />
<link rel="stylesheet" href="css/page-template.xpgt" type="application/adobe-page-template+xml" />
</head>
<body>
<div class="body">
<span epub:type="pagebreak" id="_200907" title="2009-07"/>
<h1 class="chapter-title"><strong>2009-07</strong></h1>
<span epub:type="pagebreak" id="_strings" title="Strings"/>
<section title="Strings" epub:type="bodymatter chapter">
<h1 class="chapter-subtitle"><strong>Strings</strong></h1>
<p class="note-title">2009-07-07 <a href="_200906.xhtml#_bugs_dificeis_de_achar">&lt;</a><a href="toc_computer.xhtml">computer</a><a href="_200907.xhtml#_polimorfismo_estatico">&gt;</a></p>

<p>Como já vimos centenas e centenas de vezes, memória é apenas memória até que alguém diga que isso vale alguma coisa. Em seu estado latente é o que chamamos formalmente de dados. E dados são bytes armazenados na memória.</p>
<p>No entanto, quando esses dados viram algo de útil em um determinado contexto, não necessariamente alterando-se seu conteúdo na memória, passamos a lidar com informação. Ou seja, é um dado com significado. E informação é a interpretação desses mesmos dados.</p>
<p>A conclusão óbvia para isso, falando de strings, é: uma série de bytes enfileirados na memória pode ser uma string.</p>
<p>Para tanto precisamos apenas de dados (os bytes enfileirados) e significado (uma tabela de símbolos que traduza esses bytes para caracteres e a definição de como a string se organiza).</p>
<p>Por exemplo, uma série de bytes diferentes de zero com valores que representam índices de uma tabela de tradução de caracteres e que termina sua sequência em um byte com o valor zero nele é considerada uma string C, ou string terminada em nulo.</p>
<p>Já uma mesma sequência de bytes no mesmo molde só que sem o byte final com o valor zero, mas com um byte inicial que tem como valor não um índice de caractere, mas o número de bytes subsequentes, isso é uma string Pascal, ou uma string com contador de tamanho.</p>
<p>Agora note por que tanto uma string vazia em Pascal e em C possuem os mesmos dados, mas informação diferente.</p>
<p>Outras strings que não necessariamente possuem terminador nulo: std::string, UNICODESTRING.aspx), strings no kernel.</p>
</section>
<span epub:type="pagebreak" id="_polimorfismo_estatico" title="Polimorfismo estático"/>
<section title="Polimorfismo estático" epub:type="bodymatter chapter">
<h1 class="chapter-subtitle"><strong>Polimorfismo estático</strong></h1>
<p class="note-title">2009-07-10 <a href="_200907.xhtml#_strings">&lt;</a><a href="toc_computer.xhtml">computer</a><a href="_200907.xhtml#_static_polymorphism">&gt;</a></p>

<p>Para explicar polimorfismo, nada como ver as coisas como elas eram. Se você fosse um programador C de vinte anos atrás e criasse as seguintes funções:</p>
<pre>
int soma(int x, int y);
double soma(double x, double y);
int main()
{
    int zi = soma(2, 3);
    double zd = soma(2.5, 3.4);
    return 0;
}
</pre>
<p>Imediatamente o compilador iria acusar os seguintes erros:</p>
<pre>
   overload.c
   
   overload.c(2) : warning C4028: formal parameter 1 different from declaration
   overload.c(2) : warning C4028: formal parameter 2 different from declaration
   overload.c(2) : error C2371: 'soma' : redefinition; different basic types
           overload.c(1) : see declaration of 'soma'
</pre>
<p>Isso acontece porque em C **os identificadores são únicos por escopo**. Esse é o motivo por que o seguinte código também está errado:</p>
<pre>
int main()
{
    int x = 0;
    int x = 1;
    return 0;
}
   overload.c
   overload.c(5) : error C2374: 'x' : redefinition; multiple initialization
           overload.c(4) : see declaration of 'x'
</pre>
<p>De volta aos anos 90, isso também está errado em C++. Até por uma questão de lógica: como o compilador pode saber a qual variável estamos nos referindo se usarmos o mesmo nome para duas delas?</p>
<p>Só que existe um truquezinho para impedir essa ambiguidade quando falamos de funções: os parâmetros que ela recebe.</p>
<pre>
int soma(int x, int y);
double soma(double x, double y);
int main()
{
    int zi = soma(2, 3); // dois tipos int: chamar soma(int, int)
    double zd = soma(2.5, 3.4); // dois tipos double: só pode ser soma(double, double)
    return 0;
}
   C:\Tests&gt;cl /c overload.cpp
   Microsoft (R) 32-bit C/C++ Optimizing Compiler Version 13.10.6030 for 80x86
   Copyright (C) Microsoft Corporation 1984-2002. All rights reserved.
   
   overload.cpp
   
   C:\Tests&gt;
</pre>
<p>Isso permitiu que em C++ fosse criada a sobrecarga estática, que é exatamente isso: chamar a função não apenas de acordo com seu nome, mas também de acordo com sua assinatura, ou seja, o número e o tipo dos parâmetros recebidos. Chamamos de sobrecarga estática porque isso é feito apenas pelo compilador, não pesando em nada durante a execução do programa.</p>
<p>Entre seus usos mais comuns estão os seguintes:</p>
<p>  * Ter funções com o mesmo nome mas que tratam de diferentes parâmetros;</p>
<pre>
   * soma(int, int);
   * soma(double, double);
   * Obs.: Isso ignora, é claro, as facilidades dos templates.
</pre>
<p>  * Versões novas da mesma função que recebem parâmetros adicionais;</p>
<pre>
   * export_data(void* buffer, int size);
   * export_data(void* buffer, int size, unsigned long options);
</pre>
<p>  * Mesmo nome de método para setar e obter o valor de uma propriedade;</p>
<pre>
   * Class::Property(int x); // setter
   * int x Class::Property() const; // getter
</pre>
<p>  * Bom, o que mais sua imaginação mandar =)</p>
</section>
<span epub:type="pagebreak" id="_static_polymorphism" title="Static Polymorphism"/>
<section title="Static Polymorphism" epub:type="bodymatter chapter">
<h1 class="chapter-subtitle"><strong>Static Polymorphism</strong></h1>
<p class="note-title">2009-07-10 <a href="_200907.xhtml#_polimorfismo_estatico">&lt;</a><a href="toc_computer.xhtml">computer</a><a href="_200907.xhtml#_name_mangling">&gt;</a> <a href="_200808.xhtml#_antidebugging_during_the_process_attach">&lt;</a><a href="toc_english.xhtml">english</a><a href="_200908.xhtml#_what_ive_been_doing_in_the_last_10_years">&gt;</a></p>

<p>To explain the polymorphism nothing is better than see how stuff used to be. If you were a twenty old C programmer in the past and created the following functions:</p>
<pre>
int soma(int x, int y);
double soma(double x, double y);
int main()
{
    int zi = soma(2, 3);
    double zd = soma(2.5, 3.4);
    return 0;
}
</pre>
<p>Immediately the compiler would blame you about the following errors:</p>
<pre>
   
   overload.c
   
   overload.c(2) : warning C4028: formal parameter 1 different from declaration
   overload.c(2) : warning C4028: formal parameter 2 different from declaration
   overload.c(2) : error C2371: 'sum' : redefinition; different basic types
           overload.c(1) : see declaration of 'sum'
</pre>
<p>This happens because in C **the identifiers are unique into the scope.** This is the reason why the following code is wrong also:</p>
<pre>
int main()
{
    int x = 0;
    int x = 1;
    return 0;
}
   overload.c
   overload.c(5) : error C2374: 'x' : redefinition; multiple initialization
           overload.c(4) : see declaration of 'x'
</pre>
<p>Back to the 90's, this is also wrong in C++. Even for a logic issue: how the compiler can pick a variable if we're using the same name for both of them?</p>
<p>Even though, there's a little trick to stop the ambiguity when we talk about functions: the parameters that they receives.</p>
<pre>
int soma(int x, int y);
double soma(double x, double y);
int main()
{
    int zi = soma(2, 3); // dois tipos int: chamar soma(int, int)
    double zd = soma(2.5, 3.4); // dois tipos double: só pode ser soma(double, double)
    return 0;
}
   C:Tests&gt;cl /c overload.cpp
   Microsoft (R) 32-bit C/C++ Optimizing Compiler Version 13.10.6030 for 80x86
   Copyright (C) Microsoft Corporation 1984-2002. All rights reserved.
   
   overload.cpp
   
   C:Tests&gt;
</pre>
<p>This allowed in C++ the creation of static overload, that is exactly this: to call a function not just by its name, but also to match its signature, the number and the type of the received parameters. We call static because this is done just by the compiler, not creating any overhead during the execution.</p>
<p>Among the most common uses some are as it follows:</p>
<p>  * Functions with the same name treating different parameters;</p>
<pre>
   * sum(int, int);
   * sum(double, double);
   * Obs.: This ignores, of course, the templates usefulness.
</pre>
<p>  * New version of the same fuction with addictional parameters;</p>
<pre>
   * export_data(void* buffer, int size);
   * export_data(void* buffer, int size, unsigned long options);
</pre>
<p>  * Same method name to set and get the value of a class property;</p>
<pre>
   * Class::Property(int x); // setter
   * int x Class::Property() const; // getter
</pre>
<p>  * Well, whatever your imagination and needs demand =)</p>
</section>
<span epub:type="pagebreak" id="_name_mangling" title="Name mangling"/>
<section title="Name mangling" epub:type="bodymatter chapter">
<h1 class="chapter-subtitle"><strong>Name mangling</strong></h1>
<p class="note-title">2009-07-13 <a href="_200907.xhtml#_static_polymorphism">&lt;</a><a href="toc_computer.xhtml">computer</a><a href="_200908.xhtml#_adplus_no_cliente_nao_voce">&gt;</a></p>

<p>A sobrecarga estática possui algumas desvantagens em relação ao sistema de nomes da boa e velha linguagem C: ela não foi padronizada entre compiladores. O que isso quer dizer na prática é que funções exportadas de bibliotecas dinâmicas (DLLs) vão possuir nomes diferentes dependendo do compilador utilizado (e sua versão). Isso é o que chamamos name mangling.</p>
<p>Em dois projetos usando Visual C++ 2008 e Borland C++ Builder 5 (última versão que funciona direito) eu fiz uma exportação da função soma em linguagem C (o fonte é um .c). Veja o resultado:</p>
<p>Já usando a linguagem C++ (o fonte é um .cpp) temos outro resultado totalmente diferente para nossas duas funções soma descritas no artigo anterior:</p>
<p>Se quiser tentar entender essas letrinhas bizarras, recomendo baixar projetos de exemplo. Se apenas entender que você não conseguirá juntar classes VC++ e Builder usando dllexport.aspx) para tudo quanto é lado, então terminamos por aqui.</p>
</section>
<span epub:type="pagebreak" id="_a_procura_de_vida_extraterrestre" title="À procura de vida extraterrestre"/>
<section title="À procura de vida extraterrestre" epub:type="bodymatter chapter">
<h1 class="chapter-subtitle"><strong>À procura de vida extraterrestre</strong></h1>
<p class="note-title">2009-07-20</p>

<p>Faz uns bons dez anos que eu instalei pela primeira vez em meu Pentium 133 MHz o seti@home, um programinha que se propunha a localizar vida extraterrena através de emissões de rádio capturadas pelas nossas potentes antenas de Arecibo. Ele dizia fazer isso durante o tempo ocioso do meu processador. Como eu sou uma pessoa que costuma costumava confiar bastante nas pessoas, além de ser fã incondicional do filme Contato, instalei sem medo.</p>
<p>Algum tempo se passou e hoje volto a instalar o mesmo programa, agora envolto em um invólucro de programas de mesmo teor chamado Boinc, que junta todas essas redes de trabalho em equipe. O computador é usado hoje em dia para diversos trabalhos que exigem um certo esforço no processamento que torna proibitivo alocar máquinas somente para isso (se não impossível do ponto de vista geográfico).</p>
<p>Eis uma lista dos principais projetos disponíveis através do Boinc que me chamaram a atenção:</p>
<ul><li>Climateprediction.net busca prever as possíveis consequências para o mundo das futuras transformações no clima.</li>
<li>CPUGrid.net é uma simulação molecular de proteínas otimizada para as GPUs da NVidia e o Playstation 3.</li>
<li>Superlink@Technion e ajude os cientistas a encontrar os prováveis genes causadores de fatalidades como câncer, a diabetes, hipertensão e esquizofrenia.</li>
<li>Chess960@home para análise de uma variante do xadrez tradicional que sempre coloca as peças iniciais em posições aleatórias.</li>
<li>PrimeGrid é um gerador de uma base de dados pública de números primos sequenciais, além de procurar por números primos gêmeos gigantes (vai saber).</li>
<li>Quantum Monte Carlo at Home não é o que parece: Estudo da estrutura e da reatividade de moléculas usando a Química Quântica (?).</li></ul>
<p>Dentre eles, acabei ficando mesmo com o bom e velho seti@home. Pode me chamar de egoísta, mas mesmo que encontrem a cura do câncer, não será muito produtivo para mim, que possuo questões existenciais que, acredito eu, facilitariam a compreensão das pessoas acerca da nossa extrema pequenez nesse universo, nos colocando cada vez mais no cantinho de nossa existência.</p>
<p>Escolha o seu!</p>
</section>
<span epub:type="pagebreak" id="_cuidado_com_a_copia_de_arquivos_na_vmware" title="Cuidado com a cópia de arquivos na VMWare"/>
<section title="Cuidado com a cópia de arquivos na VMWare" epub:type="bodymatter chapter">
<h1 class="chapter-subtitle"><strong>Cuidado com a cópia de arquivos na VMWare</strong></h1>
<p class="note-title">2009-07-27</p>

<p>Quebrei a cabeça com uma DLL de hook que não estava funcionando para usuários comuns. No entanto, para qualquer administrador funcionava.</p>
<p>Isso acontece porque quando se arrasta uma DLL recém-compilada para a VMWare ela possui um mecanismo que primeiro cria esse arquivo no temporário do usuário atual e depois move esse arquivo para o lugar onde você de fato arrastou.</p>
<p>Como sabemos, a pasta temporária de um usuário fica em seu perfil, que possui direitos de uso apenas do usuário e dos administradores do sistema. Se eu copio um arquivo de uma pasta restrita para outra pasta os direitos do arquivo permanecem. Isso quer dizer que apenas o usuário atual e os administradores terão acesso ao arquivo, mesmo que se trate de um arquivo para uso de todos.</p>
<p>Resultado: arrastava a nova DLL de hook compilada da pasta de saída direto para a pasta de sistema da máquina virtual e esse caminho através do temporário era seguido, tornando a DLL inacessível para os usuários que eu estava testando.</p>
<p>Solução: após arrastar o arquivo, mude suas permissões. Ou copie-o através do bom e velho copiar/colar. Diferente do arrastar, o Ctrl+C Ctrl+V não gera arquivos temporários.</p>
</section>
<span epub:type="pagebreak" id="_estado" title="Estado"/>
<section title="Estado" epub:type="bodymatter chapter">
<h1 class="chapter-subtitle"><strong>Estado</strong></h1>
<p class="note-title">2009-07-01 <a href="_200906.xhtml#_mascaras">&lt;</a><a href="toc_quotes.xhtml">quotes</a><a href="_200908.xhtml#_irritacao">&gt;</a> <a href="_200906.xhtml#_mascaras">&lt;</a><a href="toc_self.xhtml">self</a><a href="_200908.xhtml#_irritacao">&gt;</a> <a href="_200906.xhtml#_mascaras">&lt;</a><a href="toc_now.xhtml">now</a><a href="_200908.xhtml#_irritacao">&gt;</a></p>

<p>&gt; Não busque nenhum outro estado além daquele em que você está agora.</p>
<p>&gt; Tolle, Eckhart (O Poder do Agora, 1997)</p>
</section>
</div>
</body>
</html>
