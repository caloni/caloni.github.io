<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head><meta http-equiv="default-style" content="text/html; charset=utf-8"/>
<title>2007-10</title>
<link rel="stylesheet" href="css/stylesheet.css" type="text/css" />
<link rel="stylesheet" href="css/page-template.xpgt" type="application/adobe-page-template+xml" />
</head>
<body>
<div class="body">
<span epub:type="pagebreak" id="_200710" title="2007-10"/>
<h1 class="chapter-title"><strong>2007-10</strong></h1>
<span epub:type="pagebreak" id="_debug_da_bios_com_o_softice_16_bits" title="Debug da BIOS com o SoftIce 16 bits"/>
<section title="Debug da BIOS com o SoftIce 16 bits" epub:type="bodymatter chapter">
<h1 class="chapter-subtitle"><strong>Debug da BIOS com o SoftIce 16 bits</strong></h1>
<p class="note-title">2007-10-02 <a href="_200709.xhtml#_introducao_ao_c_builderturbo_c">&lt;</a><a href="toc_computer.xhtml">computer</a><a href="_200710.xhtml#_historia_do_windows_parte_50">&gt;</a> <a href="_200709.xhtml#_why_is_my_dll_locked">&lt;</a><a href="toc_blog.xhtml">blog</a><a href="_200710.xhtml#_historia_do_windows_parte_50">&gt;</a> <a href="toc_blogging.xhtml">blogging</a><a href="_200805.xhtml#_kernel_mode_user_mode">&gt;</a></p>

<p>Para quem acha que ainda n√£o desceu demais o n√≠vel existe um <a href="https://www.codeproject.com/articles/Debugging-and-Building-Operating-Systems">√≥timo artigo</a> no Code Project de S. Z. Keller (aka ShalomZ) sobre como construir seu pr√≥prio sistema operacional. √â simples, direta e empolgante a maneira com que ele explica e trata os detalhes b√°sicos, desde quando o computador √© ligado at√© quando o boot loader carrega e entrega o controle de execu√ß√£o. Eu mesmo fiz o teste com a imagem que foi disponibilizada para download e funcionou direitinho. Agora esse meu artigo se disp√µe a explicar como voc√™ pode fazer para depurar o processo de load do seu primeiro sistema operacional.</p>
<p>Primeiro precisamos de uma ferramenta fundamental para esse tipo de depura√ß√£o: o SoftIce vers√£o 16 bits. Desconhe√ßo algum outro depurador de sistema em 16 bits, mas se voc√™ souber de algum, pode us√°-lo com esse tutorial com as devidas adapta√ß√µes.</p>
<p>Passado o desafio inicial de encontrar essa vers√£o do SoftIce e saber us√°-la, o resto √© f√°cil:</p>
<p>  1. Crie uma nova VMWare, Virtual PC, VMSbrubles configurada para bootar pelo disquete.</p>
<p>  2. Formate dois disquetes de MS-DOS, FreeDos, Sbrubles-DOS.</p>
<p>  3. Copie o setor de boot dispon√≠vel no artigo do CP para o disquete usando o programa dispon√≠vel em um dos disquetes.</p>
<p>  4. Copie o SoftIce no outro disquete.</p>
<p>  5. Efetue o boot com o disquete do SoftIce.</p>
<p>  6. Execute o SoftIce (√© s√≥ rodar, ele permanece residente e √© ativado com Ctrl + D).</p>
<p>  7. Coloque um breakpoint na int 0x13 (disco) na fun√ß√£o 2 (leitura) (faz-se assim: bpint 13 ah=2).</p>
<p>  8. Troque o disquete do Softice pelo disquete com o setor de boot do artigo do CP.</p>
<p>  9. Efetue novamente o boot na m√°quina em modo "quente" (usando o pr√≥prio SoftIce, comando boot).</p>
<p>  10. A execu√ß√£o deve ser paralisada exatamente no ponto onde o c√≥digo da BIOS l√™ o setor de boot do seu disquete.</p>
<p>  11. Digite p ret e em seguida F10 ou T e seja feliz.</p>
<p>Pelo softice 16 bits conseguimos parar a execu√ß√£o nas interrup√ß√µes da BIOS e ainda especificar qual das fun√ß√µes ser√° executada, definida no registrador AH; mais detalhes sobre layout de mem√≥ria do 8086 no artigo do DQ (1).</p>
<p>Quando o c√≥digo da BIOS √© executado, ele precisa, entre outras coisas, fazer tr√™s:</p>
<p>  1. Encontrar o dispositivo padr√£o de boot.</p>
<p>  2. Ler o primeiro setor desse dispositivo para o endere√ßo 0x7C00.</p>
<p>  3. Entregar a execu√ß√£o para o c√≥digo em 0x7C00.</p>
<p>O item 2 √© justamente o que utiliza essa interrup√ß√£o para ler do disco. Eu prefiri colocar o breakpoint no item 2, mas nada impediria de voc√™ coloc√°-lo no item 3 e j√° iniciar a depura√ß√£o no c√≥digo do boot loader. Mas, como eu j√° passei por problemas encontrados no c√≥digo da BIOS que impediam o sistema de entregar a execu√ß√£o para o setor de boot, j√° dei a dica de lambuja caso voc√™ tamb√©m tenha a oportunidade de se divertir em um cliente depurando a BIOS de algum laptop desajustado.</p>
<img src="img/debug_da_bios_com_o_softice_16_bits_bpint_boot.png"/>
<p>A refer√™ncia para saber quais as fun√ß√µes para cada interrup√ß√£o na hora de depurar a BIOS pode ser encontrada em listas como a Ralf Brown's Interrupt List (2)</p>
<p>A partir dessa leitura se usa o comando p ret do depurador, que √© mais ou menos o step out do SoftIce 32. Ou seja, ele avan√ßa a execu√ß√£o at√© a fun√ß√£o retornar. No caso do SoftIce 16 ele ir√° avan√ßar at√© o pr√≥ximo ret/iret. Por isso que tamb√©m precisamos executar a pr√≥xima instru√ß√£o (o pr√≥prio ret) para cair onde queremos. √â nesse ponto que o "nosso" c√≥digo come√ßa a executar e onde conseguimos colocar breakpoints "de verdade", ou seja, escrevendo no parte do c√≥digo que deve ser interrompida a chamada da interrup√ß√£o de breakpoint (int 3). Lembre-se que n√£o √© isso o que √© feito para parar no c√≥digo da BIOS, uma vez que esta reside em mem√≥ria de somente leitura (pelo menos durante a execu√ß√£o).</p>
<img src="img/debug_da_bios_com_o_softice_16_bits_myos_start.png"/>
<p>(1) <a href="https://dqsoft.blogspot.com/2006/10/gerenciamento-de-memria-386.html">Gerenciamento de mem√≥ria 386</a> - Daniel Quadros</p>
<p>(2) <a href="https://en.wikipedia.org/wiki/Ralf_Brown%27s_Interrupt_List">Ralf Brown's Interrupt List na Wikipedia</a></p>
</section>
<span epub:type="pagebreak" id="_cronograma" title="Cronogramas"/>
<section title="Cronogramas" epub:type="bodymatter chapter">
<h1 class="chapter-subtitle"><strong>Cronogramas</strong></h1>
<p class="note-title">2007-10-04</p>

<p>Nunca fui muito bom em definir cronogramas e nunca conheci algu√©m que fosse. Por√©m, ultimamente, no conforto do lar (f√©rias), estou me saindo razoavelmente bem ao aplicar no meu dia-a-dia algumas regras que estabeleci como sendo boas pra mim. N√£o s√£o regras que baixei do s√≠tio do Joel nem √© um design pattern, mas j√° me ajudam um bocado. Gostaria de compartilh√°-las com meus pontuais leitores, que sempre entregam seus projetos em dia e nunca se esquecem de comentar uma linha de c√≥digo sequer. Voc√™s s√£o meu objetivo de vida e motivo de orgulho deste humilde blogue, que se esmera a cada dia que passa para ser fiel √† ineg√°vel qualidade do meu p√∫blico. Quando crescer quero ser igual a voc√™s.</p>
<p>Mas enquanto n√£o sou, vamos √†s regras.</p>
<p>O primeiro grande passo √© admitir que acertar cronogramas √© como acertar na loteria: milh√µes de pessoas tentam toda semana e uns poucos gatos pingados conseguem de vez em quando. E ainda assim por acaso. O importante nessa analogia √© perceber que, independente de ser dif√≠cil de acertar, isso n√£o impede as pessoas de tentar. Veja voc√™, elas (normalmente) n√£o jogam 1, 2, 3, 4, 5, 6. Por qu√™? Porque elas tentam jogar no que acreditam ser uma combina√ß√£o mais prov√°vel. E antes que um s√°bio chin√™s diga que a chance de sair a seq√º√™ncia 1, 2, 3, 4, 5, 6 √© t√£o prov√°vel quanto qualquer outra, explico que a analogia aqui √© psicol√≥gica, n√£o matem√°tica. As pessoas tentam acertar, por mais irracional que isso pare√ßa. A mesma filosofia deve ser seguida para cronogramas. N√£o chute valores que est√£o dentro da sua zona de conforto, mas tente de fato chegar o mais pr√≥ximo poss√≠vel da realidade. E, quem sabe um dia, voc√™ n√£o √© sorteado.</p>
<p>A segunda regra reza que o tempo estimado vira tempo m√≠nimo. Voc√™ far√° uma tarefa em uma hora. Mas, diabos, voc√™ n√£o sabe disso antes de fazer e coloca no cronograma tr√™s horas. Quanto tempo voc√™ vai levar agora? Tr√™s horas. N√£o que voc√™ n√£o consiga em menos tempo, mas, ao "alargar" a janela de tempo para tr√™s horas, seu ritmo ir√° seguir essa premissa e ser√° mais lento. H√° uma explica√ß√£o psicol√≥gica para isso chamada Lei de Parkinson (1). Obviamente que o inverso n√£o √© verdadeiro. Quer dizer, voc√™ n√£o vai terminar uma tarefa de uma hora em dez minutos se colocar dez minutos na sua tabela m√°gica. Isso, mais uma vez, n√£o √© matem√°tica: √© psicologia.</p>
<p>&gt; A mesma analogia absurda serve para valores muito altos. Se estimar tr√™s meses para uma tarefa de uma hora, ter√° tr√™s meses para procurar um emprego novo, e n√£o para terminar a tarefa.</p>
<p>A terceira regra diz sobre o tamanho das tarefas: as menores s√£o mais exatas. Este √© o velho ditado de dividir para conquistar. Afinal, √© muito melhor estimar o tempo para fazer uma nova fun√ß√£o do que estimar o tempo total para a nova vers√£o do produto. Portanto, trate de dividir o seu elefante. O limite √© a partir do momento em que se sentir confort√°vel para prever o tempo necess√°rio a ser gasto em uma subtarefa. √â muito simples ilustrar e entender esse conceito com c√≥digo. Voltando ao caso da fun√ß√£o, digamos que voc√™ consiga terminar a bendita fun√ß√£o em exata uma hora. Voc√™ √© bom, hein?</p>
<p>Por√©m, essa fun√ß√£o ainda:</p>
<ul><li>n√£o foi comentada,</li>
<li>n√£o foi testada,</li>
<li>n√£o foi testada em release.</li></ul>
<p>Logo, essa √© uma tarefa em que voc√™ termina o mais importante em uma hora... mas n√£o termina tudo. Deve-se sempre considerar a tarefa por completo, pois no final de quinze tarefas vai faltar comentar e testar tudo isso, o que aumentar√° consideravelmente a imprevisiblidade no seu cronograma.</p>
<p>Seja honesto consigo mesmo e com seu chefe: voc√™ realmente trabalha 8 horas por dia? √â l√≥gico que n√£o! E n√£o √© nenhuma vergonha admitir isso. Todos n√≥s temos emails para ler e responder, reuni√µes para presenciar e blogues importantes para acompanhar. Portanto, ignore essa conversa fiada de 8 horas e admita: n√£o se deve contar os dias como se eles tivessem 8 horas. Ningu√©m √© produtivo programando 8 horas seguidas. Essa pessoa est√° te enganando ou usando coca√≠na (que n√£o pode ser usada todos os dias).</p>
<p>Qual o valor de um dia, ent√£o? Cada um sabe o valor que deve ser decrementado desse valor simb√≥lico de 8 horas, mas esse valor sempre ser√° menor. N√£o se iluda! Se precisar harmonizar seu cronograma com um relat√≥rio para entregar para o chefe voc√™ pode usar de maneira privada o seu contador pessoal, por exemplo, trabalho 4 horas no m√°ximo programando por dia, e converter para torn√°-lo p√∫blico, multiplicando por dois para dar as 8 horas di√°rias.</p>
<p>A maneira com que eu administro meu tempo tenta (eu disse tenta) seguir as regras at√© aqui dispostas. Al√©m dessas eu adicionei algumas regras minhas, baseadas em valores razo√°veis e premissas consideravelmente l√≥gicas. Ali√°s, isso me lembra uma √∫ltima regra geral: entenda o seu ritmo.</p>
<p>O cronograma costuma (deveria) ser considerado uma coisa pessoal. Por qu√™? Porque cada um tem seu tempo. O que vale mais ao executar uma tarefa geralmente √© (deveria ser) qualidade, e n√£o quantidade. Seu vizinho de baia costuma terminar as coisas na metade do tempo que voc√™? Bom para ele. Por√©m, se voc√™ tenta empregar o mesmo ritmo ao seu dia-a-dia vai ter que gastar depois mais do dobro do tempo que voc√™ economizou corrigindo os erros de uma tarefa feita nas coxas. Nada √© "de gr√°tis".</p>
<p>Encare o trabalho assim como dormir: cada um tem o seu n√∫mero de horas noturnas para descansar. Se dormir mais ou menos que o normal isso ir√° influenciar mais tarde, quando acordar. Alguns dormem 4, outros 12 horas. A m√©dia √© 8. Mas e da√≠?</p>
<p>Primeiro eu tento usar um princ√≠pio que a maioria das pessoas conhece e a minoria acredita: se chama princ√≠pio de Pareto. Ele diz que 20% de uma tarefa resolve 80% dos problemas. Aos poucos eu fui acreditando nele at√© que cheguei √† conclus√£o que deve funcionar, por√©m existe um problema: definir quais s√£o esses 20%.</p>
<p>Voltando novamente no caso da fun√ß√£o, √© √≥bvio que a parte mais importante √© fazer a fun√ß√£o. Mais uma vez, cada caso √© um caso, e o importante √© desenvolver esse feeling do que √© mais importante. Fazendo o que √© mais importante o resto vir√° complementar a solu√ß√£o.</p>
<p>Essa ordem do que √© mais importante deve servir para dividir qualquer tarefa e as tarefas de cada dia, ordenadas por import√¢ncia. Dessa forma, √© f√°cil come√ßar o dia ou uma tarefa maior pelo que √© mais importante. Isso nos leva a um segundo problema: definir o que √© importante.</p>
<p>A maior dificuldade em definir o que √© importante √© que muitas vezes ele se confunde com o que √© urgente, mesmo sendo dois conceitos bem diferentes.</p>
<p>Por exemplo, para mim foi urgente escrever este artigo, j√° que estou compromissado com a freq√º√™ncia do meu blogue. O importante fica por conta do conte√∫do. Por exemplo, considero ter tocado em todos os pontos que julgo importantes para esse tema, o que por si s√≥ caracterizaria o fim desse artigo. E √© isso a√≠.</p>
<p>Bons cronogramas!</p>
<p>&gt; O trabalho se expande de forma a preencher o tempo dispon√≠vel para sua conclus√£o.</p>
<p>&gt; Parkinson's Law</p>
</section>
<span epub:type="pagebreak" id="_historia_do_windows_parte_50" title="Hist√≥ria do Windows - parte 5.0"/>
<section title="Hist√≥ria do Windows - parte 5.0" epub:type="bodymatter chapter">
<h1 class="chapter-subtitle"><strong>Hist√≥ria do Windows - parte 5.0</strong></h1>
<p class="note-title">2007-10-08 <a href="_200710.xhtml#_debug_da_bios_com_o_softice_16_bits">&lt;</a><a href="toc_computer.xhtml">computer</a><a href="_200710.xhtml#_engenharia_reversa_para_principiantes">&gt;</a> <a href="_200710.xhtml#_debug_da_bios_com_o_softice_16_bits">&lt;</a><a href="toc_blog.xhtml">blog</a><a href="_200710.xhtml#_the_c_programming_language">&gt;</a></p>

<p>Em novembro de 1998 (apenas para parceiros Microsoft) √© lan√ßada a vers√£o 5.0 do Windows NT, conhecida como Windows 2000. Melhorias significativas foram feitas no acesso √† internet, intranet e extranet. Aplica√ß√µes de gerenciamento se integram fortemente e a grande novidade em termos de estrutura√ß√£o de dados √© o Active Directory, uma tecnologia compat√≠vel com o conceito de Distributed File System, que viabiliza uma nova forma das empresas organizarem seus dados de maneira mais transparente √† rede. Assim come√ßou a <a href="_202009.xhtml#_historia_do_windows">Hist√≥ria do Windows</a> para redes de gente grande.</p>
<img src="img/historia_do_windows_parte_50_windows_2000.png"/>
<p>Vamos aproveitar que a vers√£o NT foi melhorada para dar uma recapitulada geral de como as coisas funcionam internamente no sistema operacional. Em um desenho da arquitetura veremos diferentes m√≥dulos que fazem parte do sistema operacional que dividem fun√ß√µes espec√≠ficas e que possuem m√©todos espec√≠ficos de comunica√ß√£o interna e externa. Importante notar que a divis√£o entre os componentes que descreverei abaixo j√° existia desde a primeira vers√£o do NT, sendo que apenas alguns itens foram adicionados, como o Gerenciador de Plug &amp; Play e o Gerenciador de Energia. Os elementos principais do Windows, visto sob camadas de abstra√ß√£o, s√£o:</p>
<ul><li>Aplica√ß√µes Win32, POSIX, OS/2;</li>
<li>Subsistemas Win32, POSIX, OS/2;</li>
<li>Subsistemas de integridade;</li>
<li>Servi√ßos do Executivo (em ingl√™s Executive Services);</li>
<li>Gerenciador de I/O ou I/O Manager;</li>
<li>Gerenciador de Mem√≥ria Virtual ou VMM, o Virtual Memory Manager;</li>
<li>Process Manager, PnP Manager e Power Manager;</li>
<li>Object Manager;</li>
<li>Microkernel;</li>
<li>Kernel mode drivers;</li>
<li>Hardware Abstraction Layer (aka HAL);</li>
<li>Por fim, o hardware.</li></ul>
<img src="img/historia_do_windows_parte_50_windows_architecture.png"/>
<p>&gt; Um outro item important√≠ssimo que foi movido da vers√£o 3.51 para a 4.0 √© a GDI, respons√°vel pelos gr√°ficos. Inicialmente ela estava no modo de usu√°rio, mas a necessidade de aumentar o desempenho do sistema fez com que ela fosse incorporada ao n√∫cleo do sistema.  Agora vamos dissecar as partes interessantes.</p>
<p>As aplica√ß√µes, ou programas, que rodam sobre o sistema operacional preferencialmente s√£o feitas para rodar no Windows, mas n√£o precisa ser assim. A abstra√ß√£o inicial que se fez foi o uso de subsistemas que suportam um ambiente de execu√ß√£o. Essa foi a maneira escolhida pelos projetistas para que existisse compatibilidade com outros sistemas operacionais, como o OS/2 e POSIX (um padr√£o de aplicativo utilizado em ambientes UNIX/Linux). A mesma abstra√ß√£o permite que se rodem aplicativos 16 bits em cima do ambiente NT, que √© todo feito em 32.</p>
<p>Os subsistemas de compatibilidade s√£o servi√ßos do sistema operacional que fornecem o ambiente de execu√ß√£o adequado para cada tipo de aplica√ß√£o. Quando o usu√°rio executa um arquivo, o loader do Windows detecta o tipo de aplica√ß√£o tentando rodar e carrega o subsistema necess√°rio. Dessa forma a execu√ß√£o de aplicativos MS-DOS e Windows 3.11 se torna transparente para o usu√°rio. No entanto, as prote√ß√µes necess√°rias (e.g. acesso a interrup√ß√µes) ser√£o respeitadas. Al√©m dos subsistemas que ir√£o fornecer os mecanismos necess√°rios para a execu√ß√£o dos aplicativos dependendo de seu formato, existem aqueles subsistemas que tomam conta de alguns detalhes cruciais para a correta execu√ß√£o das tarefas do sistema operacional. Entre eles o mais importante √© a parte de seguran√ßa, respons√°vel por realizar o login dos usu√°rios.</p>
<p>Os chamados Servi√ßos do Executivo basicamente s√£o o conjunto de fun√ß√µes que est√£o dispon√≠veis no modo de usu√°rio para realizar opera√ß√µes mais complexas no n√∫cleo do sistema, como leitura/escrita em arquivo, cria√ß√£o de threads, chamada direta de um driver, etc. Mais basicamente ainda, se trata de um vetor de ponteiros de fun√ß√µes que s√£o chamadas em kernel mode quando o modo de usu√°rio chama uma interrup√ß√£o ou comando em assembly espec√≠fico para realizar uma chamada de sistema.</p>
<p>O I/O Manager √© um componente muito usado toda hora no sistema, pois ele trata de chamadas de leitura/escrita em qualquer dispositivo, seja um arquivo, uma porta serial ou uma placa de v√≠deo. Como conceitualmente as requisi√ß√µes do sistema operacional foram organizadas como opera√ß√µes de entrada e sa√≠da, o I/O Manager √© essencial para a maioria das opera√ß√µes com dispositivos, sejam f√≠sicos, l√≥gicos ou virtuais.</p>
<p>A mem√≥ria virtual √© parte integrante e indispens√°vel para o desempenho e normal funcionamento do sistema operacional. Entre suas responsabilidades est√£o a necessidade de dividir a mem√≥ria entre os diferentes processos de acordo com o uso e proteg√™-la contra leituras, escritas e execu√ß√µes n√£o autorizadas. Parte integrante do Memory Manager, embora freq√ºentemente visto como um m√≥dulo separado por sua l√≥gica, o Gerenciador de Cach√™, em ingl√™s Cache Manager, se concentra mais em estabelecer as diretizes usadas para paginar partes da mem√≥ria para o disco e tornar a carreg√°-las na mem√≥ria principal (RAM).</p>
<p>O Process Manager, PnP Manager e Power Manager possuem fun√ß√µes mais perif√©ricas, mas n√£o menos importantes. O Process Manager cria novos processos e mant√©m a rela√ß√£o entre eles. O PnP (Plug and Play) Manager, novo no Windows 2000, gerencia a adi√ß√£o e remo√ß√£o de dispositivos que s√£o plug√°veis enquanto a m√°quina est√° ligada. O Gerenciador de Energia, tamb√©m novo, teve sua import√¢ncia aumentada com o advindo do uso massivo de laptops. √â ele que controla coisas como a hiberna√ß√£o do sistema operacional, por exemplo.</p>
<p>O Gerenciador de Objetos, o Object Manager, tamb√©m √© parte central e obrigat√≥ria do sistema operacional, pois ele gerencia todos os recursos dispon√≠veis tanto em kernel quanto em user mode (espelhado pelo kernel). No Windows, qualquer recurso √© representado por um objeto, seja um arquivo, uma thread, um processo, um evento, uma interrup√ß√£o, etc. Sendo que tudo √© representado como um objeto, esse m√≥dulo foi especialmente criado para gerenciar todos os recursos de uma vez. Dessa forma tipos de controle global, como o controle de acesso, p√¥de ser centralizado em apenas um lugar no c√≥digo, assim como o gerenciamento de handles, que s√£o manipuladores de recursos que existem em modo de usu√°rio.</p>
<p>O microkernel pode ser entendido como a parte que faz coisas muito b√°sicas em um sistema operacional. T√£o b√°sicas quanto executar as threads, gerenciar interrup√ß√µes e abstrair pequenas diferen√ßas entre arquiteturas. Os drivers em kernel mode fazem par com o microkernel, e podem ser escrito pela Microsoft ou por fabricantes de dispositivos. S√£o eles os respons√°veis por controlar o hardware que est√° atr√°s do sistema, como o disco, a porta serial, a rede, a placa de v√≠deo, a pr√≥pria CPU, etc. Muitos podem ser l√≥gicos, como os filtros e os drivers de sistema de arquivos e, acredite se quiser, costumam ser mais complexos que os que controlam diretamente o hardware.</p>
<p>A HAL, Hardware Abstraction Layer, ou Camada de Abstra√ß√£o de Hardware, √© totalmente dependente de plataforma, e justamente por causa disso ela √© totalmente isolada do resto do sistema operacional, tornando a portabilidade mais f√°cil de ser suportada. Em alguns casos a HAL √© implementada como um conjunto de macros, o que quer dizer que voc√™ ter√° que recompilar seus drivers para mudar de plataforma (x86 para x64, por exemplo). Al√©m disso, existe um conjunto de DLLs compiladas para cada plataforma, que √© renomeada (para hal.dll) e copiada durante a instala√ß√£o. Isso explica porque em algumas situa√ß√µes se voc√™ copia a instala√ß√£o do Windows de uma m√°quina para outra com diferen√ßas relevantes de arquitetura pode ser que as coisas n√£o saiam exatamente como voc√™ esperava.</p>
<p>E por fim, a n√£o ser que estejamos falando do XBox, o hardware √© feito por terceiros, como a Intel, a AMD e a NVIDIA, e √© onde voc√™ instala o seu sistema operacional do cora√ß√£o para rodar seus aplicativos do cora√ß√£o. O bom de um sistema operacional do cora√ß√£o √© que voc√™ n√£o percebe sua exist√™ncia quando est√° rodando seu jogo do cora√ß√£o. Pelo menos n√£o deveria. O √∫nico momento que o sistema operacional do cora√ß√£o revela sua exist√™ncia √© quando as coisas d√£o errada e voc√™ recebe uma tela azul do cora√ß√£o.</p>
</section>
<span epub:type="pagebreak" id="_engenharia_reversa_para_principiantes" title="Engenharia reversa para principiantes"/>
<section title="Engenharia reversa para principiantes" epub:type="bodymatter chapter">
<h1 class="chapter-subtitle"><strong>Engenharia reversa para principiantes</strong></h1>
<p class="note-title">2007-10-10 <a href="_200710.xhtml#_historia_do_windows_parte_50">&lt;</a><a href="toc_computer.xhtml">computer</a><a href="_200710.xhtml#_the_c_programming_language">&gt;</a></p>

<p>Dei uma reformada em minha √∫ltima <a href="https://github.com/Caloni/lectures/blob/master/engenhariareversaparaprincipiantes.pdf">palestra sobre engenharia reversa</a>. O tema escolhido foi tentar abranger os n√≠veis de conhecimento que uma pessoa disposta a se dedicar √† engenharia reversa de programas deveria ter, desde programa√ß√£o, passando pelo sistema operacional e terminando no uso de ferramentas. Achei interessante abordar esse tipo de conte√∫do pelo fato de existirem pessoas que gostariam de come√ßar ou j√° come√ßaram e n√£o sabem para onde ir.</p>
<p>Outra coisa que fiquei receoso de colocar (mas coloquei) foi a lista de tarefas para usar o conhecimento aprendido. Pode ser frustrante tentar procurar emprego nessa √°rea aqui no Brasil e n√£o adianta nada aprender e n√£o usar. A engenharia reversa, assim como a √°rea de seguran√ßa da informa√ß√£o, para ser efetiva, deve levar em conta como as coisas s√£o feitas, o que quer dizer que fazer v√≠rus e quebrar prote√ß√£o de software faz parte do aprendizado.</p>
<p>Se houverem interessados o suficiente poderei ministrar uma palestra online, para ilustrar os slides e tirar d√∫vidas. Lembrando que isso n√£o inclui as perguntas "como eu quebro o programa X" ou "faz um v√≠rus pra mim".</p>
</section>
<span epub:type="pagebreak" id="_the_c_programming_language" title="A Linguagem de Programa√ß√£o C: O Livro"/>
<section title="A Linguagem de Programa√ß√£o C: O Livro" epub:type="bodymatter chapter">
<h1 class="chapter-subtitle"><strong>A Linguagem de Programa√ß√£o C: O Livro</strong></h1>
<p class="note-title">2007-10-12 <a href="_200709.xhtml#_a_mobilidade_das_variaveis_no_printf">&lt;</a><a href="toc_ccpp.xhtml">ccpp</a><a href="_200710.xhtml#_typeid_e_os_perigos_do_nao_polimorfismo">&gt;</a> <a href="toc_books.xhtml">books</a><a href="_200804.xhtml#_crash_dump_analysis_o_livro">&gt;</a> <a href="_200710.xhtml#_engenharia_reversa_para_principiantes">&lt;</a><a href="toc_computer.xhtml">computer</a><a href="_200710.xhtml#_guia_basico_para_programadores_de_primeiro_int_main">&gt;</a> <a href="_200710.xhtml#_historia_do_windows_parte_50">&lt;</a><a href="toc_blog.xhtml">blog</a><a href="_200710.xhtml#_guia_basico_para_programadores_de_primeiro_int_main">&gt;</a></p>

<p>O cl√°ssico de Ritchie e Kernighan, criadores da linguagem C, n√£o foi meu primeiro livro de programa√ß√£o. E nem deveria ser. N√£o o recomendo para iniciantes, pois √© necess√°rio possuir algum conhecimento e pr√°tica para realmente aproveitar os conceitos desse livro.</p>
<p>Ent√£o, o que ler antes disso? Existem tantos livros bons para iniciantes (e tantos livros p√©ssimos). Eu comecei com C Completo e Total, de Herbert Schildt. N√£o me arrependi. O autor vai descrevendo C para quem j√° tentou fazer algumas coisas, j√° programou outras e est√° afim de tirar as principais d√∫vidas sobre essa linguagem que tantos abominam por ser dif√≠cil, e tantos idolatram por ser poderosa. As pr√°ticas do livro j√° s√£o um bom in√≠cio para quem quer pensar, entender e programar.</p>
<p>Depois de Schildt passei a ler os livros da Viviane, os famos√≠ssimos m√≥dulos do Treinamento em Linguagem C. S√£o √≥timos para a pr√°tica e para reafirmar os conceitos lidos no primeiro livro. Para uma linguagem t√£o importante uma segunda opini√£o √© sempre bem-vinda.</p>
<p>Ent√£o chegou a hora. Passei algumas das minhas melhores horas na biblioteca lendo como os pr√≥prios criadores da linguagem a ensinam, e como o padr√£o ANSI √© definido (em termos bem simplificados, condi√ß√£o perfeita para entender a l√≥gica do compilador). Com o livro √© poss√≠vel perceber claramente que a linguagem √© t√£o simples quanto poderosa, lembrando (quem diria!) o mais abominado ainda assembly. Vamos aos cap√≠tulos.</p>
<h2>Chapter 1: A Tutorial Introduction</h2>
<p>O come√ßo √© quase sempre o mesmo. Os autores explicam um programa simples na linguagem, fazem alguns testes e explicam linha a linha o que cada coisa significa. O importante aqui √© esquecer que existe um sistema operacional rodando por baixo de nosso programa e entender que a linguagem foi desenhada para independer disso. √â t√£o gen√©rica a ponto de independer dela mesma. Explico: enquanto a maioria das linguagens considera sua biblioteca parte integrante da mesma, a linguagem C faz quest√£o de separar as coisas, reafirmando sempre que uma coisa √© o preprocessamento, outra √© a compila√ß√£o, outra √© a linkedi√ß√£o e nenhuma delas precisa de uma biblioteca, apesar de uma ter sido definida no padr√£o (baseada no uso comum da linguagem em diversos ambientes).</p>
<p>Se voc√™ nunca teve contato com C ou deseja ter uma aproxima√ß√£o mais simplificada e quer entender como as coisas mais simples funcionam na linguagem, este cap√≠tulo √© imperd√≠vel.</p>
<h2>Chapter 2: Types, Operators and Expressions</h2>
<p>Essa √© a hora ideal para separar dois conceitos que muitas vezes ficam grudados na mente dos precoces programadores para o resto de suas vidas: uma coisa √© um tipo e outra coisa √© uma express√£o. Uma express√£o possui um tipo, que define seu comportamento de acordo com o operador usado. Tudo √© explicado muito bem com exemplos bem escritos e que s√£o realmente √∫teis, como strlen, atoi, strcat (presentes na biblioteca padr√£o) e at√© um contador de bits.</p>
<p>Se quiser entender o que cada fragmento de l√≥gica na linguagem significa por completo (e n√£o apenas uma express√£o jogada na correria da programa√ß√£o do dia-a-dia) esse cap√≠tulo ir√° explicar. Depois de entend√™-lo, nunca mais vai achar bizarro aqueles problemas de preced√™ncia que permeiam c√≥digo pouco sensato.</p>
<h2>Chapter 3: Control Flow</h2>
<p>Apenas ap√≥s ter explicado os conceitos que regem qualquer linha de c√≥digo operacional em C os autores se dedicam a explanar as diversas formas de controlar o fluxo do seu programa. Nessa hora a linguagem se desdobra, se torna m√°gica, simples, flex√≠vel e poderosa.</p>
<p>N√£o basta apenas possuir l√≥gica de programa√ß√£o. Para escrever bons programas √© necess√°rio saber como construir os blocos funcionais que ir√£o traduzir seus comandos para o computador. √â nesse ponto que √© fundamental o dom√≠nio de qualquer constru√ß√£o em C, seja um simples if ou uma combina√ß√£o maluca de switches, whiles e breaks.</p>
<h2>Chapter 4: Functions and Program Structure</h2>
<p>Entendidos os princ√≠pios b√°sicos de cria√ß√£o e execu√ß√£o de qualquer programa em C, chegou a hora de explicar como a linguagem suporta a organiza√ß√£o de seu c√≥digo atrav√©s de fun√ß√µes, m√≥dulos e diretivas de preprocessamento. Note que os autores partem do princ√≠pio minimalista da linguagem e imagina o que acontece conforme seus programas v√£o se tornando cada vez maiores. Para isso explicam o mesmo princ√≠pio que foi utilizado ao desenhar a linguagem, que at√© hoje √© usada para escrever dezenas de milhares de c√≥digo em um √∫nico projeto, ou at√© milh√µes (como em sistemas operacionais).</p>
<p>No desenvolvimento de software a organiza√ß√£o √© um dos pilares que ir√° transformar o programador em um mestre da arquitetura de seu pr√≥prio c√≥digo. N√£o negligencie a l√≥gica das partes maiores do seu c√≥digo, s√≥ se importando com os pequenos peda√ßos de blocos dentro de uma fun√ß√£o. Antes de ser cientista, seja um desenvolvedor nato.</p>
<h2>Chapter 5: Pointers and Arrays</h2>
<p>A dificuldade com que muitos programadores C t√™m com essas duas caracter√≠sticas da linguagem fizeram com que fosse dedicado um cap√≠tulo inteiro para explicar e reexplicar como os arrays (vetores) e ponteiros funcionam e qual a rela√ß√£o intr√≠nseca entre eles. √â tamb√©m explicada a rela√ß√£o strings x arrays, j√° que em C uma string √© uma cadeia de caracteres.</p>
<p>Se voc√™ programa em C e at√© hoje tem dificuldades para entender completamente esse assunto, sugiro que largue o que voc√™ est√° fazendo agora e leia esse cap√≠tulo at√© o final. Ser√° bem mais proveitoso que ficar zanzando no meio de um monte de blogues (como este aqui).</p>
<h2>Chapter 6: Structures</h2>
<p>A estrutura √© uma composi√ß√£o complexa em C, mas permite um organiza√ß√£o melhor dos dados, da mesma maneira com que as fun√ß√µes organizam melhor o c√≥digo.</p>
<p>Aparentemente o tema estrutura √© mais simples que ponteiros, e deveria ser tratado antes. Por√©m, fazer isso impediria abordar o tema de listas ligadas e outras estruturas que dependem do uso de ponteiros para que estruturas referenciem elas mesmas, algo extremamente recorrente no mundo da programa√ß√£o.</p>
<img src="img/the_c_programming_language_binary_tree.gif"/>
<p>√â sempre bom lembrar que o uso de estruturas foi o nascimento do C++, que prima pela eleg√¢ncia na organiza√ß√£o e harmonia entre seu c√≥digo e dados. A linguagem C tamb√©m n√£o fica para tr√°s, mas √© importante saber usar.</p>
<h2>Chapters 7 and 8: Input and Output / The UNIX System Interface</h2>
<p>Para finalizar √© abordado o tema da interface com o mundo exterior da linguagem. Desde sempre suportando a maneira mais b√°sica, gen√©rica e port√°til de qualquer sistema operacional, o console, talvez hoje essa caracter√≠stica seja um tanto menosprezada pelos usu√°rios de ambientes gr√°ficos. Contudo, n√£o deixa de ter seu valor ainda hoje, nem que seja para escrever programas de teste.</p>
<h2>Ap√™ndices</h2>
<p>Os adendos s√£o incrivelmente √∫teis e os utilizo ainda hoje como refer√™ncia. C√° entre n√≥s, o padr√£o formal da linguagem √© algo chato de se ler, e muitos detalhes s√£o perfeitamente ignor√°veis para quem n√£o est√° desenvolvendo um compilador. Contudo, acredito que a maioria dos bons programadores deveria se preocupar em entender como os compiladores entendem seu c√≥digo, pois muitos dos erros podem ser facilmente resolvidos atrav√©s do desenvolvimento de uma certa empatia com a linguagem. √â por isso que considero o Ap√™ndice A o mais √∫til de todos.</p>
<p>Por outro lado, sempre fui contra a reinven√ß√£o da roda. O que quer dizer que sempre fui a favor do pleno conhecimento da biblioteca padr√£o, pois ela fornece fun√ß√µes das mais usadas no dia-a-dia, e algumas outras que poder√£o ter sua serventia um dia desses. Mas para isso elas devem ser conhecidas. Isso quer dizer que uma passada de olhos no Ap√™ndice B n√£o faz mal a ningu√©m.</p>
<p>O Ap√™ndice C hoje √© um pequeno guia dos curiosos para as mudan√ßas que foram infligidas na linguagem quando esta foi padronizada. Como f√£ incondicional de C, n√£o pude deixar de ler e reler essa parte, j√° que me dedico tamb√©m a conhecer os prim√≥rdios dessa linguagem. Contudo, √© parte opcional para as pessoas pr√°ticas (a n√£o ser que voc√™ esteja com problemas com c√≥digo legado do s√©culo passado).</p>
<h2>Conclus√£o</h2>
<p>Livros v√™m, livros v√£o, mas apenas os cl√°ssicos permanecer√£o. A Linguagem de Programa√ß√£o C √© um cl√°ssico, sem sombra de d√∫vida, e nunca ir√° perder seu valor para a linguagem. A maioria dos livros usa-o como refer√™ncia, assim como os livros t√£o amados da comunidade C++ sempre usam Stroustrup como refer√™ncia. Portanto, se puder, reserve um tempo para o passado.</p>
</section>
<span epub:type="pagebreak" id="_guia_basico_para_programadores_de_primeiro_int_main" title="Guia b√°sico para programadores de primeiro int main"/>
<section title="Guia b√°sico para programadores de primeiro int main" epub:type="bodymatter chapter">
<h1 class="chapter-subtitle"><strong>Guia b√°sico para programadores de primeiro int main</strong></h1>
<p class="note-title">2007-10-16 <a href="_200710.xhtml#_the_c_programming_language">&lt;</a><a href="toc_computer.xhtml">computer</a><a href="_200710.xhtml#_por_que_minha_dll_travou">&gt;</a> <a href="_200710.xhtml#_the_c_programming_language">&lt;</a><a href="toc_blog.xhtml">blog</a><a href="_200710.xhtml#_por_que_minha_dll_travou">&gt;</a></p>

<p>&gt; Vou aproveitar que meu amigo DQ publicou um artigo muito bom sobre [como fazer programas f√°ceis de manter] (merece ser lido!) e vou republicar um artigo do blogue antigo sobre o b√°sico do b√°sico para quem deseja entender como os programas funcionam. N√£o √© nada sofisticado, apenas alguns conceitos comuns que, se voc√™ deseja ser programador, deveria procurar saber.</p>
<h2>C√≥digo, dados e processador</h2>
<p>A primeira coisa a saber √© o que √© um programa. Podemos imagin√°-lo como um arquivo que vai ser interpretado pelo computador. Essa interpreta√ß√£o chamamos de execu√ß√£o. Quando um programa est√° sendo executado tamb√©m √© comum dizermos que ele est√° rodando. Teoricamente ele pode rodar eternamente, mas o que acontece em casos normais √© que ele tem um fim previsto, seja quando o usu√°rio fechar a janela principal (evento externo) ou quando ele terminar o que tinha que fazer (l√≥gica interna).</p>
<p>E do que √© feito um programa? Basicamente de duas coisas: dados de entrada e instru√ß√µes (ou c√≥digo). Os dados podem estar no pr√≥prio programa ou serem lidos de algum outro lugar (do teclado, de outro arquivo, da internet, etc). As instru√ß√µes do seu programa √© o que ser√° interpretado pelo computador. E o que ele far√°? Basicamente alterar os dados de entrada. O objetivo fundamental de um programa √© gerar dados de sa√≠da. Esses dados s√£o escritos/exibidos para algum outro lugar (para a tela, para um arquivo, para a internet, etc).</p>
<p>Vamos analisar essas abstra√ß√µes em exemplos da vida real:</p>
<ul><li>Programa, Dados de entrada, Processamento, Dados de sa√≠da.</li>
<li>Bloco de Notas, Digita√ß√£o do usu√°rio, Leitura do teclado, Texto exibido na tela.</li>
<li>Chat Online, Envio de mensagem, Conex√£o com a internet, Seu amigo recebe a mensagem.</li>
<li>Editor de imagem, Movimento do mouse, Interpreta√ß√£o de movimento, Ret√¢ngulo desenhado.</li>
<li>Browser, Clique do mouse em uma URL, Conex√£o com o site, Exibi√ß√£o da nova p√°gina.</li>
<li>Jogo de Tiro, Clique no bot√£o de tiro, C√°lculo do proj√©til, Inimigo acertado.</li>
<li>Compilador, C√≥digo do programador, Interpreta√ß√£o das instru√ß√µes, C√≥digo de m√°quina (seu programa!).</li></ul>
<p>Como podemos ver, podemos abstrair esse lance de "dados de entrada + processamento = dados de sa√≠da" com qualquer tipo de programa que usarmos. Basta relacionar o que fazemos (digitar algo, arrastar o mouse, apertar um bot√£o, etc) para obtermos a sa√≠da desejada (texto/gr√°fico na tela, no arquivo, na impressora, etc). O programa √© o elemento que fica no meio fazendo essa "m√°gica".</p>
<h2>Dados do programa</h2>
<p>Existem informa√ß√µes intermedi√°rias que precisamos guardar em um programa em execu√ß√£o para que no final consigamos apresentar a sa√≠da desejada ao usu√°rio. Essas informa√ß√µes intermedi√°rias tamb√©m s√£o dados, s√≥ que o usu√°rio n√£o os enxerga. A elas chamamos de vari√°veis. Entenda uma vari√°vel como "um lugar na mem√≥ria onde o programa armazena alguma informa√ß√£o durante o processamento".</p>
<p>Toda vari√°vel √© apenas mem√≥ria interpretada de uma maneira peculiar. Essa maneira de interpretar a mem√≥ria √© chamada de tipo. Cada vari√°vel possui o tipo que lhe conv√©m. Basicamente, existem dois tipos de vari√°veis: n√∫mero (ou inteiro) e texto (ou string).</p>
<h2>Instru√ß√µes do programa</h2>
<p>Imagine um programa sendo executado do come√ßo ao fim. A ordem em que um programa √© executado √© chamado de fluxo de execu√ß√£o. A tend√™ncia natural de um programa √© ser executado pelo computador da sua primeira instru√ß√£o at√© a √∫ltima, sempre nessa ordem. Ou seja, linha 1, linha 2, linha 3, ...., linha n. Pronto. Acabou.</p>
<p>Por√©m, se fosse sempre assim, isso quer dizer que o programa seria executado sempre do mesmo jeito, e os dados de sa√≠da seriam sempre os mesmos, independente dos dados de entrada. Mas isso n√£o acontece, certo? Quer dizer, se voc√™ n√£o mirar direito e apertar o bot√£o certo, o inimigo n√£o vai cair no ch√£o. Isso faz um certo sentido, n√£o?</p>
<p>Seguindo esse racioc√≠nio, podemos deduzir que um programa deve tomar decis√µes para saber o que fazer. E para tomar essas decis√µes ele usa o que recebeu como entrada, que s√£o exatamente os dados de entrada. Nesse contexto, tomar decis√£o significa alterar o fluxo de execu√ß√£o. Ou seja, a ordem n√£o necessariamente ser√° sempre linha 1, linha 2, linha 3, etc, mas poder√° ser, por exemplo, linha 1, linha 52, linha 237643, linha 52 de novo, linha 890, e assim por diante.</p>
<pre>
   001: inicia
   002: l√™ entrada
   003: atirar?
   004: sim! ir para 514
   005: n√£o! ir para 002
   006: ...
   ...
   514: acertei?
   515: sim! ir para 489
   516: n√£o! ir para 234
   517: ...
   ...
   234: fui acertado?
   235: sim! ir para 918
   236: n√£o! ir para 002
   ...
   489: aumenta pontos
   490: ir para 002
   ...
   918: diminui vida
   919: morri?
   920: sim! ir para 980
   921: n√£o! ir para 002
   ...
   980: game over!
   981: sai do programa
</pre>
<p>Note que existem v√°rias perguntas que o programa precisa responder para seguir em frente. Para respond√™-las, o programa pede a ajuda do computador para fazer compara√ß√µes entre vari√°veis. E a√≠ est√° o uso desses dados internos.</p>
<h3>Mudando o fluxo</h3>
<p>Bem, at√© aqui voc√™ j√° aprendeu um mont√£o de coisas:</p>
<ul><li>Programas podem ser armazenados em arquivos.</li>
<li>Quando executados, o computador interpreta suas instru√ß√µes.</li>
<li>Um programa usa dados de entrada para gerar dados de sa√≠da.</li>
<li>Para tomar decis√µes, ele utiliza vari√°veis internas.</li>
<li>A ordem das instru√ß√µes √© chamado fluxo de execu√ß√£o.</li>
<li>A tomada de decis√µes altera o fluxo de execu√ß√£o de um programa.</li></ul>
<p>Para concluir, vamos dar uma espiada nas estruturas de compara√ß√£o de um programa em C e suas conseq√ºentes mudan√ßas de fluxo. Note tamb√©m que as compara√ß√µes s√£o feitas com vari√°veis internas.</p>
<p>If significa "se", ou seja, faz uma compara√ß√£o, e retorna se a compara√ß√£o √© verdadeira (sim!) ou n√£o (n√£o!). Por√©m, o if apenas faz alguma coisa se o resultado for sim.</p>
<img src="img/guia_basico_para_programadores_de_primeiro_int_main_if.gif"/>
<p>Else significa "sen√£o", ou seja, √© o complemento do if. Lembra-se que o if s√≥ faz alguma coisa se o resultado da compara√ß√£o for sim? Pois bem, o else permite fazer outra coisa se o resultado for n√£o.</p>
<img src="img/guia_basico_para_programadores_de_primeiro_int_main_else.gif"/>
<p>While significa "enquanto", e √© o nosso primeiro exemplo de la√ßo, ou loop. Um loop faz constantemente a mesma coisa enquanto o resultado da compara√ß√£o for sim. Uma vez que for n√£o (pode ser a primeira, inclusive), ele n√£o faz mais nada e o programa continua seu fluxo natural.</p>
<img src="img/guia_basico_para_programadores_de_primeiro_int_main_while.gif"/>
<p>For significa "por", com o mesmo sentido que em "ele me chutou por 5 vezes seguidas". Ele pode ter muitos usos, mas o tradicional √© fazer n vezes alguma coisa, sabendo que n √© um n√∫mero de vezes j√° conhecido. Nesse caso, o loop serve apenas para repetir um determinado n√∫mero de vezes uma a√ß√£o, sem nunca variar esse n√∫mero de vezes.</p>
<img src="img/guia_basico_para_programadores_de_primeiro_int_main_for.gif"/>
<h4>√â s√≥ isso?</h4>
<p>Programar n√£o tem segredo. √â tudo uma quest√£o de gostar, aprender, executar, aprender, gostar mais, aprender mais, executar mais, etc. N√£o exatamente nessa ordem. Tudo vai depender dos seus dados de entrada. Mas o fluxo j√° come√ßou sua execu√ß√£o...</p>
<h4>Para saber mais</h4>
<ul><li>Arquitetura de von Neumann</li>
<li>M√°quina de Turing</li></ul>
<h4>Se ainda est√° dif√≠cil compreender</h4>
<ul><li>Resolva exerc√≠cios de l√≥gica.</li>
<li>Leia livros bem introdut√≥rios (at√© para crian√ßa vale) como Introdu√ß√£o Ilustrada √† Computa√ß√£o.</li></ul>
</section>
<span epub:type="pagebreak" id="_por_que_minha_dll_travou" title="Por que minha DLL travou?"/>
<section title="Por que minha DLL travou?" epub:type="bodymatter chapter">
<h1 class="chapter-subtitle"><strong>Por que minha DLL travou?</strong></h1>
<p class="note-title">2007-10-18 <a href="_200710.xhtml#_guia_basico_para_programadores_de_primeiro_int_main">&lt;</a><a href="toc_computer.xhtml">computer</a><a href="_200710.xhtml#_guia_basico_para_programadores_de_primeiro_breakpoint">&gt;</a> <a href="_200710.xhtml#_guia_basico_para_programadores_de_primeiro_int_main">&lt;</a><a href="toc_blog.xhtml">blog</a><a href="_200710.xhtml#_guia_basico_para_programadores_de_primeiro_breakpoint">&gt;</a></p>

<p>O resumo da √≥pera √© que o c√≥digo do Windows chamador do DllMain das DLLs carregadas/descarregadas utiliza um objeto de acesso exclusivo (leia "mutex") para sincronizar as chamadas. O resultado √© que, em um processo, apenas um DllMain √© chamado em um dado momento. Esse objeto √© chamado de loader lock na documenta√ß√£o da Microsoft.</p>
<img src="img/por_que_minha_dll_travou_loader_lock.gif"/>
<p>Escrevi um c√≥digo besta para exemplificar, mas representa o que j√° vi em muito c√≥digo-fonte, e muitas vezes n√£o consegui perceber o que estava acontecendo (tanto porque desconhecia a exist√™ncia desse loader lock quanto o c√≥digo estava obscuro demais pra entender mesmo).</p>
<p>Update 2026-02-04. Perdi o c√≥digo que cito acima, mas perguntei para o Chat-GPT para me dar um exemplo did√°tico:</p>
<pre>
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
DWORD WINAPI WorkerThread(LPVOID lpParam)
{
    // Simulate some work
    Sleep(1000);
    // Anything that might touch loader state is deadly here
    // Even something innocent-looking like LoadLibrary
    LoadLibraryA(&quot;user32.dll&quot;);
    return 0;
}
BOOL WINAPI DllMain(HINSTANCE hinstDLL,
                    DWORD fdwReason,
                    LPVOID lpvReserved)
{
    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
    {
        HANDLE hThread;
        DWORD threadId;
        hThread = CreateThread(
            NULL,
            0,
            WorkerThread,
            NULL,
            0,
            &amp;threadId
        );
        if (hThread)
        {
            // üö® DEADLOCK HERE üö®
            // Loader lock is held, thread cannot safely execute
            WaitForSingleObject(hThread, INFINITE);
            CloseHandle(hThread);
        }
        break;
    }
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
</pre>
<p>Uma simples v√≠tima disso pode ser um pobre execut√°vel usando uma pobremente escrita DLL, assim como no c√≥digo abaixo:</p>
<pre>
   int main()
   {
     printf(&quot;load dll&quot;);
     HMODULE lockDll = LoadLibrary(_T(&quot;dll_lock.dll&quot;));
   
     if( lockDll )
     {
       Sleep(2000);
       printf(&quot;free dll&quot;);
       FreeLibrary(lockDll), lockDll  = NULL;
       printf(&quot;done&quot;);
     }
   }
</pre>
<p>√â importante sempre lembrar que a Microsoft acha feio, muito feio voc√™ ficar dependendo do DllMain pra fazer alguma coisa, mas admite que em alguns casos o √∫nico lugar onde podemos rodar c√≥digo √© no DllMain. Nesses casos -- e em alguns outros -- utilize uma comunica√ß√£o paralela com sua thread travadona, por meio de um evento ou algo do g√™nero, antes que ela realmente saia. Com isso a thread pode ainda n√£o ter sa√≠do, mas pode avisar a thread principal que o que ela precisava fazer j√° foi feito.</p>
<p>Entre os cl√°ssicos e inestim√°veis artigos de Matt Pietrek no Microsoft Journal h√° na <a href="http://bytepointer.com/resources/pietrek_debug_init_routines.htm">edi√ß√£o de setembro de 1999</a> um bem curto a respeito da inicializa√ß√£o de DLLs. Essa √© a leitura mais sucinta, did√°tica e esclarecedora sobre a quest√£o.</p>
</section>
<span epub:type="pagebreak" id="_guia_basico_para_programadores_de_primeiro_breakpoint" title="Guia b√°sico para programadores de primeiro breakpoint"/>
<section title="Guia b√°sico para programadores de primeiro breakpoint" epub:type="bodymatter chapter">
<h1 class="chapter-subtitle"><strong>Guia b√°sico para programadores de primeiro breakpoint</strong></h1>
<p class="note-title">2007-10-22 <a href="_200710.xhtml#_por_que_minha_dll_travou">&lt;</a><a href="toc_computer.xhtml">computer</a><a href="_200710.xhtml#_typeid_e_os_perigos_do_nao_polimorfismo">&gt;</a> <a href="_200710.xhtml#_por_que_minha_dll_travou">&lt;</a><a href="toc_blog.xhtml">blog</a><a href="_200710.xhtml#_typeid_e_os_perigos_do_nao_polimorfismo">&gt;</a></p>

<p>Aproveitando um dos √∫ltimos artigos que fala sobre <a href="_200710.xhtml#_guia_basico_para_programadores_de_primeiro_int_main">conceitos b√°sicos de programa√ß√£o</a>, lembro que, t√£o importante quanto programar √© possuir habilidades b√°sicas de depura√ß√£o, uma arte por muitos programadores ignorada.</p>
<p>√â interessante notar como muitos ignoram a utilidade e conveni√™ncia das tradicionais e poderosas ferramentas de depura√ß√£o passo-a-passo. O motivo pode ser puro desd√©m ou ignor√¢ncia (no sentido de desconhecimento). Se for pelo segundo, a√≠ v√£o algumas dicas para dar uma passada geral no seu programa e, quem sabe, encontrar um ou outro bug pelo caminho.</p>
<img src="img/guia_basico_para_programadores_de_primeiro_breakpoint_debug.png"/>
<p>Os comandos mais comuns de debug s√£o: Start/Continue, Break, Stop, Restart, Show Next Statement, Step Into, Step Over e Step Out.</p>
<p>Run ou Debug √© o comando prim√°rio. Simplesmente inicia uma nova execu√ß√£o de seu programa. Geralmente voc√™ deve utilizar esse comando quando j√° tiver definido seus breakpoints (mais sobre isso abaixo). Do contr√°rio o programa vai iniciar, executar e sair, sem sequer voc√™ notar.</p>
<p>O comando Step Over avan√ßa uma linha de c√≥digo-fonte, parando na seguinte, de uma maneira iterativa. √â a chamada execu√ß√£o passo-a-passo. Com ele voc√™ consegue, com a ajuda das janelas de watch e vari√°veis locais, analisar passo-a-passo a execu√ß√£o do fluxo de seu programa variando de acordo com as condi√ß√µes do sistema.</p>
<p>Stop Into √© um parente bem pr√≥ximo do Step Over, com a importante diferen√ßa de entrar dentro das fun√ß√µes que s√£o chamadas em cada linha de execu√ß√£o. Geralmente √© usado quando voc√™ pretende revisar todo o fluxo de execu√ß√£o porque escreveu c√≥digo novo ou porque ainda n√£o chegou na situa√ß√£o que pretende simular ou ainda porque usou o Step Over antes e descobriu que existe algum problema na fun√ß√£o X que voc√™ passou direto.</p>
<p>J√° o Step Out √© o complemento dos dois Steps acima. Ele vai sair executar todo o resto da fun√ß√£o onde voc√™ est√° e parar exatamente uma linha ap√≥s a chamada dessa fun√ß√£o. Em suma: voc√™ j√° viu o que queria ver dentro da fun√ß√£o atual e quer continuar a execu√ß√£o um ou mais n√≠veis acima na pilha de chamadas.</p>
<p>Voc√™ n√£o precisa passar por todo o seu c√≥digo e todos os seus loops/la√ßos de 500 itera√ß√µes at√© chegar ao ponto que quer analisar. O breakpoint √© um comando nativo do sistema que √© dos mais √∫teis para o programador, capaz de parar o fluxo de execu√ß√£o em um ponto espec√≠fico do c√≥digo. O depurador torna dispon√≠vel para voc√™ esse comando que pode ser engatilhado em qualquer linha, geralmente em uma quantidade razo√°vel. Para controlar todos os breakpoints definidos existe uma janela com essa lista que indica, entre outras coisas, se est√£o habilitados ou n√£o, se possuem alguma condi√ß√£o de quebra, quantas vezes devem parar, etc. Costuma existir um √≥timo controle sobre breakpoints nos depuradores, pois esse √© um comando muito usado em programa√ß√£o (e dos mais antigos).</p>
<p>Praticamente qualquer ferramenta de debug possui um mecanismo para que voc√™ consiga ver o que est√° dentro das vari√°veis de seu programa. Basicamente temos uma janela ou comando de watch, ou inspection, onde podemos inserir as vari√°veis que queremos espiar. Em um n√≠vel mais sofisticado, temos as janelas de locals e autos (o nome pode variar), onde podemos ver, respectivamente, as vari√°veis dentro da fun√ß√£o e as vari√°veis mais pr√≥ximas do ponto onde o c√≥digo est√° parado (as que foram usadas na √∫ltima linha e as que ser√£o usadas na pr√≥xima, por exemplo). Claro que cada ambiente te fornece o que melhor ajudar durante a depura√ß√£o, assim como o Delphi e o C++ Builder possuem o magn√≠fico Object Inspector, uma janela com todas as propriedades de um objeto qualquer do sistema (uma janela, um bot√£o, uma classe, etc).</p>
<p>Seguindo as janelas e comandos √∫teis de debug, a pilha de chamadas ou stack trace mostra a pilha da thread atual sendo depurada. Com ela voc√™ consegue ver o nome da fun√ß√£o que chamou a fun√ß√£o que chamou a fun√ß√£o que chamou... at√© a fun√ß√£o inicial (por exemplo, o nosso conhecido main, a primeira fun√ß√£o de um programa "normal" em C/C++).</p>
<p>No caso de seu programa ser multithreading, ou seja, possuir v√°rias linhas de execu√ß√£o, fluxos distintos de c√≥digo rodando, existir√° uma janela ou comando onde voc√™ pode ver qual a thread atual (a que est√° sendo depurada e destrinchada nas outras janelas) e quais as outras threads. Muitos ambientes permitem que com essa janela seja feito um switch de threads, que √© a troca da thread atual, o que ir√° alterar a janela de pilha de chamadas, de vari√°veis locais, e muito provavelmente a janela do c√≥digo-fonte atualmente em execu√ß√£o.</p>
<p>Depurar esteve sempre ligado √† programa√ß√£o desde os prim√≥rdios da humanidade. Por isso hoje em dia os depuradores est√£o muito evolu√≠dos, geralmente integrados em um ambiente de desenvolvimento (exs: Visual Studio, KDE Develop) e possuem comandos e mais comandos e mais comandos. Existem comandos, por exemplo, para pular fluxo sem executar, definir um breakpoint tempor√°rio, visualizar registradores da m√°quina, visualizar p√°ginas de mem√≥ria, controle de exce√ß√µes, misturar assembly com c√≥digo-fonte, etc. Enfim, cada comando deve ser usado conforme a necessidade e conveni√™ncia. N√£o adianta querer usar tudo e entender tudo de uma vez. Os comandos acima j√° s√£o um √≥timo come√ßo para uma depura√ß√£o poderosa o suficiente para pegar alguns bugs.</p>
</section>
<span epub:type="pagebreak" id="_typeid_e_os_perigos_do_nao_polimorfismo" title="Typeid e os perigos do n√£o-polimorfismo"/>
<section title="Typeid e os perigos do n√£o-polimorfismo" epub:type="bodymatter chapter">
<h1 class="chapter-subtitle"><strong>Typeid e os perigos do n√£o-polimorfismo</strong></h1>
<p class="note-title">2007-10-24 <a href="_200710.xhtml#_guia_basico_para_programadores_de_primeiro_breakpoint">&lt;</a><a href="toc_computer.xhtml">computer</a><a href="_200710.xhtml#_protecao_dos_membros_protected">&gt;</a> <a href="_200710.xhtml#_the_c_programming_language">&lt;</a><a href="toc_ccpp.xhtml">ccpp</a><a href="_200710.xhtml#_protecao_dos_membros_protected">&gt;</a> <a href="_200710.xhtml#_guia_basico_para_programadores_de_primeiro_breakpoint">&lt;</a><a href="toc_blog.xhtml">blog</a><a href="_200710.xhtml#_protecao_dos_membros_protected">&gt;</a></p>

<p>Quando usamos o operador typeid geralmente desejamos conhecer informa√ß√µes sobre o tipo exato do objeto que temos em m√£os, independente da hierarquia de heran√ßa a qual seu tipo perten√ßa. S√≥ que por ignorar, assim como o <a href="_200707.xhtml#_what_happens_inside_the_sizeof_operator">sizeof</a>, que esse operador possui duas caras, √†s vezes damos com os burros n'√°gua e compramos gato por lebre. N√£o √© pra menos. Uma sutil diferen√ßa entre classes polim√≥rficas e est√°ticas pode dar aquele susto que s√≥ C++ pode proporcionar.</p>
<p>Eis um exemplo singelo, sem dramatiza√ß√£o (com dramatiza√ß√£o == "500 linhas de c√≥digo de produ√ß√£o al√©m do c√≥digo abaixo").</p>
<pre>
   #include &lt;iostream&gt;
   #include &lt;typeinfo&gt;
   
   using namespace std;
   
   class Base
   {
   public:
     Base()
     {
       cout &lt;&lt; &quot;Base()\n&quot;;
       m_x = 0;
     }
   
     ~Base()
     {
       cout &lt;&lt; &quot;~Base()\n&quot;;
     }
   
     int m_x;
   };
   
   class Deriv : public Base
   {
   public:
     Deriv()
     {
       cout &lt;&lt; &quot;Deriv()\n&quot;;
   
       m_x = 1;
       m_y = 0;
     }
   
     virtual ~Deriv()
     {
       cout &lt;&lt; &quot;~Deriv()\n&quot;;
     }
   
     int m_y;
   };
   
   void func(Base* b)
   {
     cout &lt;&lt; typeid(*b).name() &lt;&lt; '\n';
   }
   
   int main()
   {
     Base* b = new Deriv();
     func(b);
   } 
   
</pre>
<p>O typeid usado nesse exemplo ser√° o est√°tico, no estilo typeid(type), porque o tipo do objeto para a fun√ß√£o √© de "ponteiro para objeto de classe n√£o-polim√≥rfica", ou seja, sem nenhuma fun√ß√£o virtual. √â importante lembrar que o polimorfismo em C++ s√≥ √© aplicado se houver raz√£o para tal, pois na linguagem a regra √© que "n√£o existe sobrecarga de execu√ß√£o sem que o programador queira":</p>
<pre>
   &gt;./program
   Base()
   Deriv()
   class Base
</pre>
<p>Se o esperado pelo programador fosse um class Deriv na √∫ltima linha da sa√≠da, ou seja, que o typeid utilizado fosse a vers√£o din√¢mica, ent√£o a nossa classe Base tem que ser polim√≥rfica:</p>
<pre>
   virtual ~Base()
   {
     cout &lt;&lt; &quot;~Base()\n&quot;;
   } 
</pre>
<p>Esse √© um erro equivalente ao chamar o operador delete usando o ponteiro recebido em func. Se isso fosse feito, seria chamado apenas o destrutor da classe Base. Por falar nisso, temos nesse exemplo um leak de mem√≥ria (percebeu pela sa√≠da que os destrutores n√£o s√£o chamados?). Mas esse √© um erro bem menos sutil que o visto pelo nosso amigo typeid amigo-da-on√ßa ;).</p>
<pre>
   &gt;./program
   Base()
   Deriv()
   class Deriv
</pre>
</section>
<span epub:type="pagebreak" id="_protecao_dos_membros_protected" title="Prote√ß√£o dos membros protected"/>
<section title="Prote√ß√£o dos membros protected" epub:type="bodymatter chapter">
<h1 class="chapter-subtitle"><strong>Prote√ß√£o dos membros protected</strong></h1>
<p class="note-title">2007-10-26 <a href="_200710.xhtml#_typeid_e_os_perigos_do_nao_polimorfismo">&lt;</a><a href="toc_computer.xhtml">computer</a><a href="_200710.xhtml#_alterando_mensagem_de_erro_no_notepad">&gt;</a> <a href="_200710.xhtml#_typeid_e_os_perigos_do_nao_polimorfismo">&lt;</a><a href="toc_ccpp.xhtml">ccpp</a><a href="_200802.xhtml#_os_diferentes_erros_na_linguagem_c">&gt;</a> <a href="_200710.xhtml#_typeid_e_os_perigos_do_nao_polimorfismo">&lt;</a><a href="toc_blog.xhtml">blog</a><a href="_200710.xhtml#_alterando_mensagem_de_erro_no_notepad">&gt;</a></p>

<p>Quando queremos que um membro de nossa classe seja vis√≠vel apenas dentro dos m√©todos da classe e dentro dos m√©todos das classes derivadas dessa classe usamos o n√≠vel de prote√ß√£o protected. Isso, √© claro, n√£o quer dizer que uma classe derivada v√° ter acesso aos membros protegidos de outra:</p>
<pre>
   #include &lt;iostream&gt;
   
   using namespace std;
   
   class Base
   {
   protected:
   	int m_protected;
   };
   
   class Deriv : public Base
   {
   public:
   	int GetProtectedFromBase();
   	int GetProtectedFromDeriv2();
   };
   
   class Deriv2 : public Base
   {
   };
   
   int Deriv::GetProtectedFromBase()
   {
   	return m_protected;
   }
   
   int Deriv::GetProtectedFromDeriv2()
   {
   	Deriv2 deriv2;
     // error C2248: 'Base::m_protected' : cannot
     // access protected member
     // declared in class 'Base'
   	return deriv2.m_protected;
   }
   
   int main()
   {
   	Deriv deriv;
   	deriv.GetProtectedFromBase();
   	deriv.GetProtectedFromDeriv2();
   }
   
</pre>
<p>Esse √© o motivo fundamental do porqu√™ n√£o podermos fazer isso:</p>
<pre>
   int Deriv::GetProtectedFromBase()
   {
     Base base;
     return base.m_protected;
   } 
</pre>
<p>Ao acessar membros protegidos √© importante o tipo da express√£o que est√° do lado esquerdo do "." ou "-&gt;". Afinal, o n√≠vel de prote√ß√£o se baseia no escopo, e as classes s√£o um escopo. √â por isso que consigo acessar os membros protegidos de um outro objeto de minha classe, mesmo sendo outro objeto:</p>
<pre>
   int Deriv::GetProtectedFromDeriv2()
   {
     Deriv deriv;
     assert(typeid(deriv) == typeid(*this));
     return deriv.m_protected; // OK
   }
</pre>
<p>A defini√ß√£o do escopo √© tudo o que o compilador disp√µe para saber se acessa ou n√£o acessa um membro. Podemos ter acesso a m_protected enquanto somos do tipo Deriv, mas n√£o quando o mesmo objeto √© usado como Base:</p>
<pre>
   int Deriv::GetProtectedFromBase()
   {
     Base&amp; base = *this;
     assert(typeid(base) != typeid(*this));
     return base.m_protected; // ERROR
   }
</pre>
<p>Essa prote√ß√£o parece desnecess√°ria e at√© mesmo incoerente quando lidamos com o mesmo objeto que acessa. Afinal, somos n√≥s mesmos! S√≥ que o compilador n√£o sabe disso, e ele deve desconfiar de tudo e de todos para evitar esse tipo de "ataque":</p>
<pre>
   int Deriv::GetProtectedFromDeriv2()
   {
     Deriv2 deriv2;
     Base&amp; base = deriv2;
     assert(typeid(deriv2) != typeid(*this));
     return base.m_protected; // ERROR
   }
</pre>
<p>Agora a prote√ß√£o do compilador faz sentido. Parece um detalhe fr√≠volo, mas j√° vi programadores de respeito se debatendo pela "burrice" do compilador. Imaginei que talvez houvesse mais pessoas com a mesma d√∫vida de se existe ou n√£o um "bug na linguagem".</p>
</section>
<span epub:type="pagebreak" id="_alterando_mensagem_de_erro_no_notepad" title="Alterando mensagem de erro no Notepad"/>
<section title="Alterando mensagem de erro no Notepad" epub:type="bodymatter chapter">
<h1 class="chapter-subtitle"><strong>Alterando mensagem de erro no Notepad</strong></h1>
<p class="note-title">2007-10-30 <a href="_200710.xhtml#_protecao_dos_membros_protected">&lt;</a><a href="toc_computer.xhtml">computer</a><a href="_200711.xhtml#_ponteiros_de_metodo_conceito_fundamental">&gt;</a> <a href="_200706.xhtml#_introducao_ao_debugging_tools_for_windows">&lt;</a><a href="toc_windbg.xhtml">windbg</a><a href="_200805.xhtml#_kernel_mode_user_mode">&gt;</a> <a href="_200710.xhtml#_protecao_dos_membros_protected">&lt;</a><a href="toc_blog.xhtml">blog</a><a href="_200711.xhtml#_ponteiros_de_metodo_conceito_fundamental">&gt;</a></p>

<p>Existem duas maneiras de depurar um programa localmente usando o WinDbg: inici√°-lo pelo pr√≥prio WinDbg ou conectar o depurador (attach) em um programa j√° em execu√ß√£o. Podemos especificar o que faremos direto na linha de comando ou pela sua interface. Pela linha de comando podemos usar os comandos windbg notepad.exe, windbg -pn notepad.exe e windbg -p pid. Pela interface s√£o os conhecidos itens do menu File: Open Executable e Attach to a Process.</p>
<p>Para variar, iremos depurar o Bloco de Notas, o maravilhoso editor de textos da Microsoft e plataforma de testes para servi√ßos, GINAs e drivers. Para come√ßar, poderemos usar quaisquer das op√ß√µes anteriores, o que nos levar√° para uma sa√≠da polu√≠da como a seguinte:</p>
<pre>
   
   Microsoft (R) Windows Debugger  Version 6.7.0005.1
   Copyright (c) Microsoft Corporation. All rights reserved.
   
   CommandLine: notepad.exe
   Symbol search path is: SRV*C:Symbols*http://msdl.microsoft.com/downloads/symbols
   Executable search path is:
   ModLoad: 01000000 01014000   notepad.exe
   ModLoad: 7c900000 7c9b0000   ntdll.dll
   ModLoad: 7c800000 7c8f5000   C:\WINDOWS\system32\kernel32.dll
   ModLoad: 763b0000 763f9000   C:\WINDOWS\system32\comdlg32.dll
   ModLoad: 77f60000 77fd6000   C:\WINDOWS\system32\SHLWAPI.dll
   ModLoad: 77dd0000 77e6b000   C:\WINDOWS\system32\ADVAPI32.dll
   ModLoad: 77e70000 77f01000   C:\WINDOWS\system32\RPCRT4.dll
   ModLoad: 77f10000 77f57000   C:\WINDOWS\system32\GDI32.dll
   ModLoad: 7e410000 7e4a0000   C:\WINDOWS\system32\USER32.dll
   ModLoad: 77c10000 77c68000   C:\WINDOWS\system32\msvcrt.dll
   ModLoad: 773d0000 774d3000   C:WINDOWS\WinSxSx86_Microsoft.Windows.Common-Controls_Sbrubles
   ModLoad: 7c9c0000 7d1d5000   C:\WINDOWS\system32\SHELL32.dll
   ModLoad: 73000000 73026000   C:\WINDOWS\system32\WINSPOOL.DRV
   (df8.e28): Break instruction exception - code 80000003 (first chance)
   eax=001a1eb4 ebx=7ffd5000 ecx=00000000 edx=00000001 esi=001a1f48 edi=001a1eb4
   eip=7c901230 esp=0007fb20 ebp=0007fc94 iopl=0         nv up ei pl nz na po nc
   cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
   ntdll!DbgBreakPoint:
   7c901230 cc              int     3
</pre>
<p>N√£o se preocupe, nada aconteceu de errado. Essa √© apenas a maneira do WinDbg de dizer "oi, estou aqui, positivo e operando". Vamos destrinchar as informa√ß√µes iniciais para evitar confus√£o:</p>
<ul><li>Version: vers√£o que est√° sendo executada do WinDbg (duh).</li>
<li>CommandLine: linha de comando que foi usada ao executar o depurador.</li>
<li>ModLoad: sempre que um m√≥dulo √© carregado no processo (DLLs ou o pr√≥prio execut√°vel) o WinDbg informa os endere√ßos inicial e final de carregamente e o nome do m√≥dulo. Para rever a lista de m√≥dulos carregados usa-se o comando lm.</li>
<li>(`&lt;pid&gt;.&lt;tid&gt;`): Break instruction exception - code 8000003 (first chance). Qualquer informa√ß√£o espec√≠fica de uma thread √© informada dessa maneira no WinDbg. No caso, foi a exce√ß√£o de breakpoint (parada na execu√ß√£o) acionada no come√ßo da depura√ß√£o (e √© por isso que o notepad ainda n√£o est√° aparecendo).</li></ul>
<p>Explicado o come√ßo o resto √© f√°cil. Para continuar a execu√ß√£o do bloco de notas basta usarmos o comando g (Go), ou pressionar F5, ou ir no menu "Debug, Go", ou ainda apertar um dos bot√µes de fluxo do depurador listado no seu toolbar:</p>
<img src="img/brincando_com_o_windbg_debug_windbg.png"/>
<p>Nos depuradores mais comums voc√™ ter√° todas essas op√ß√µes ao seu dispor e nos comandos mais incomuns tudo o que voc√™ ter√° ser√° o prompt de comando do WinDbg e a ajuda, acionada por F1 ou pelo comando .hh &lt;t√≥pico&gt;. Geralmente os comandos do WinDbg possuem milhares de par√¢metros e √© considerada atitude s√°bia olhar de vez em quando o que alguns desses par√¢metros significam para que, aos poucos, aprenda-se alguns truques at√© a chegada da ilumina√ß√£o completa, onde seu esp√≠rito ir√° fluir livremente pela mem√≥ria de todos os processos do sistema.</p>
<p>Por enquanto, basta apertar g seguido de ENTER.</p>
<p>A tempo: ap√≥s executar g mais um monte daquelas mensagens cheias de caracteres ir√£o aparecer. N√£o se preocupe. Elas realmente n√£o s√£o importantes no momento, mas √© importante saber o b√°sico, que √© "o WinDbg est√° avisando voc√™ de tudo o que ocorre". No momento certo saberemos usar as informa√ß√µes na tela quando houver necessidade.</p>
<p>Vamos fazer algo n√£o t√£o esperto para ver como o bloco de notas reage. Tente abrir um arquivo com um nome inexistente:</p>
<img src="img/brincando_com_o_windbg_orografia.jpg"/>
<p>Como podemos ver o Bloco de Notas exibe uma mensagem de erro indicando que o arquivo cujo nome voc√™ digitou n√£o existe, pede para voc√™ "verificar a orografia" e tudo o mais. O importante aqui n√£o √© que voc√™ n√£o sabe digitar nomes de arquivos, mas sim qual a fun√ß√£o que o notepad usa para exibir sua mensagem de erro.</p>
<p>Update 2021-03-07: na vers√£o original deste post esta fun√ß√£o era a MessageBox, e eu seguia explicando o prot√≥tipo da fun√ß√£o e seus argumentos. Hoje, no Windows 10, descubro que o MessageBox n√£o √© mais usado, dando lugar ao ShellMessageBoxW. Como eu descobri isso? Bom, eu segui os mesmos passos do post original e coloquei um breakpoint em MessageBox e executei novamente a abertura de um arquivo inv√°lido e... o breakpoint n√£o disparou. Nesse caso eu dei uma olhada na pilha de chamada de todas as threads para encontrar alguma thread que chamou fun√ß√µes de janela. Para isso voc√™ pode usar o comando ~*kvn (para todas as threads exiba a pilha de chamadas no modo verbose).</p>
<img src="img/brincando_com_o_windbg_notepad_file_not_found.png"/>
<p>Na sa√≠da abaixo voc√™ pode encontrar essa chamada na primeira thread, a 2b14.30f8, no stack frame 0x0e.</p>
<pre>
   0:003&gt; ~* kvn
   
      0  Id: 2b14.30f8 Suspend: 1 Teb: 000000b7`5be5b000 Unfrozen
    # Child-SP          RetAddr               : Args to Child                                                           : Call Site
   00 000000b7`5bdbd6f8 00007ff9`c74e078e     : 00000000`ffffffff 00007ff9`ae84cd4c 000000b7`00000000 00000000`00000001 : win32u!NtUserMsgWaitForMultipleObjectsEx+0x14
   01 000000b7`5bdbd700 00007ff9`ae85352b     : 00000211`41e83718 00007ff9`c87d0454 00000000`00000001 00000000`000000e5 : USER32!RealMsgWaitForMultipleObjectsEx+0x1e
   02 000000b7`5bdbd740 00007ff9`ae853422     : 00000000`ffffffff 00000000`00000000 00000000`008f06b6 00000000`00000410 : DUser!CoreSC::WaitMessage+0xeb
   03 000000b7`5bdbd7b0 00007ff9`c74edbe1     : 00000000`00000000 00000000`00000001 00000000`00000121 00007ff9`c74cde1b : DUser!MphWaitMessageEx+0x62
   04 000000b7`5bdbd7e0 00007ff9`c87d0454     : 00000000`00000001 00000002`00000001 00000000`0000412a 00000000`00000000 : USER32!_ClientWaitMessageExMPH+0x21
   ...
   0a 000000b7`5bdbd9e0 00007ff9`b14545e7     : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000187 : USER32!DialogBoxIndirectParamW+0x18
   0b 000000b7`5bdbda20 00007ff9`b145456e     : 15e684dc`00000800 00000000`00000000 00000000`00000000 000000b7`5bdbdb20 : COMCTL32!SHFusionDialogBoxIndirectParam+0x57
   0c 000000b7`5bdbda60 00007ff9`c748cf3e     : 00000211`479c00a0 00000000`00000000 000000b7`5bdbdbf0 000000b7`5bdbdb20 : COMCTL32!CTaskDialog::Show+0x122
   0d 000000b7`5bdbdab0 00007ff9`c747959e     : 00000000`00000000 00000000`00220a9c 00000000`00000000 00000000`00220a9c : shlwapi!TaskDialogIndirect+0x56
   0e 000000b7`5bdbdaf0 00007ff9`c68f92cd     : 00000000`00000000 00000211`47a57dd0 00000211`41e69208 00007ff9`c74cde1b : shlwapi!ShellMessageBoxW+0x18e
   0f 000000b7`5bdbdcc0 00007ff9`c68bf17c     : 00000000`80070002 000000b7`5bdbdda9 00000000`00000000 00000000`00000000 : comdlg32!_DisplayErrorMessage+0x291
   ...
   24 000000b7`5bdbeb30 00007ff9`c68b609a     : 00000000`00000000 000000b7`00000000 00000211`00000004 000000b7`5bdbed68 : USER32!DialogBoxIndirectParamW+0x18
   25 000000b7`5bdbeb70 00007ff9`c6893084     : 00000211`41e69090 00000211`00000000 00000211`41e69098 00000003`00000003 : comdlg32!&lt;lambda_3a7baec315efe719b0d1bc9a8eafe6df&gt;::operator()+0xee
   26 000000b7`5bdbebc0 00007ff6`2c3987ae     : 00000000`00000000 00000000`008e07ea 00000000`00000000 000000b7`5bdbf0a8 : comdlg32!CFileOpenSave::Show+0xa34
   27 000000b7`5bdbef80 00007ff6`2c398aff     : 00000000`00000000 00000000`00001808 00000000`008e07ea 00000000`00000000 : notepad!ShowOpenSaveDialog+0xfe
   ...
</pre>
<p>Essa √© uma fun√ß√£o equivalente √† antiga MessageBox, cujo prot√≥tipo √© int ShellMessageBoxW(HINSTANCE hAppInst, HWND hWnd, LPCWSTR lpcText, LPCWSTR lpcTitle, UINT fuStyle, ...), ou seja, uma fun√ß√£o que recebe cinco ou mais par√¢metros: o handle da inst√¢ncia caso a string passada esteja em um resource, o handle da janela pai, o texto da mensagem, o t√≠tulo e flags de exibi√ß√£o. As retic√™ncias ao final do prot√≥tipo indicam que ele pode conter mais argumentos.</p>
<p>Sabendo que o notepad n√£o usa mais MessageBox, vamos colocar um singelo breakpoint nessa outra fun√ß√£o API. Para parar a execu√ß√£o do notepad, podemos digitar "Ctrl + Break" ou ir no menu "Debug, break" ou ainda... bem, voc√™ pegou o esp√≠rito da coisa. Na linha de comando ap√≥s o break digite bp shlwapi!ShellMessageBoxW seguido de g e ENTER novamente.</p>
<p>Note que utilizei o prefixo shlwapi! para especificar que a fun√ß√£o est√° no m√≥dulo shlwapi.dll, mas n√£o seria necess√°rio j√° que o WinDbg procura por qualquer fun√ß√£o digitada na sua lista de fun√ß√µes exportadas e s√≠mbolos atuais. Contudo, fazer isso torna as coisas mais r√°pidas e evita perder tempo √† toa.</p>
<p>Agora podemos efetuar a mesma opera√ß√£o de abrir um arquivo inexistente no bloco de notas que a execu√ß√£o ir√° parar no in√≠cio da fun√ß√£o ShellMessageBoxW da API:</p>
<pre>
   Breakpoint 0 hit
   shlwapi!ShellMessageBoxW:
   00007ff9`c7479410 4055            push    rbp
   0:000&gt; r
   rax=00007ff9c6933000 rbx=0000000000000187 rcx=00007ff9c6880000
   rdx=0000000000220a9c rsi=0000000000000001 rdi=00000211479d6030
   rip=00007ff9c7479410 rsp=000000b75bdbd728 rbp=00000211479ba190
    r8=0000000000000187  r9=0000000000000000 r10=0000021148ed1ae0
   r11=000000b75bdbd2c8 r12=0000000000000000 r13=0000000000000000
   r14=0000000000220a9c r15=0000000000000000
   iopl=0         nv up ei pl zr na po nc
   cs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
   shlwapi!ShellMessageBoxW:
   00007ff9`c7479410 4055            push    rbp
   
</pre>
<p>Analisando pela conven√ß√£o de chamada x64 sabemos que o terceiro par√¢metro, lpcText, est√° em r8 e √© um ID do resource. O que valida essa an√°lise √© tamb√©m o primeiro par√¢metro, a inst√¢ncia do m√≥dulo que cont√©m os resources que ser√£o usados para carregar a mensagem, que fica em rcx e n√£o est√° zerado (ele aponta para o m√≥dulo commdlg32.dll). Dessa forma nossa tarefa se torna particularmente mais dif√≠cil, pois para encontrar a string usada na mensagem de erro seria necess√°rio buscar no meio dos resources dessa DLL.</p>
<p>No entanto, vou realizar aqui brincadeira semelhante ao post original, que √© alterar a mensagem de erro. Para isso precisamos alocar alguma mem√≥ria para escrever uma string UNICODE e alterar o registrador r8 para o endere√ßo dessa mem√≥ria. A aloca√ß√£o de mem√≥ria pelo WinDbg pode ser feita usando o comando .dvalloc e a edi√ß√£o de uma string UNICODE terminada em zero pelo comando ezu (edit zero terminated unicode string). Ap√≥s isso alteramos o valor do registrador com o comando r.</p>
<pre>
   0:000&gt; .dvalloc 10
   Allocated 1000 bytes starting at 00000211`43d60000
   0:000&gt; ezu 00000211`43d60000 &quot;Obrigado por utilizar o maravilhoso Bloco de Notas!&quot;
   0:000&gt; rr8 = 00000211`43d60000
   0:000&gt; g
   
</pre>
<p>Note que se estiv√©ssemos tentando exibir uma string Ansi ir√≠amos usar o comando eza (edit zero terminated ansi string). O WinDbg possui in√∫meros comandos parecidos que come√ßam com e, cuja lista pode ser consultada pelo comando .hh e. O equivalente para leitura √© o comando d (de dump).</p>
<img src="img/brincando_com_o_windbg_notepad_wonderful_file.png"/>
<p>Repare que colocamos esse breakpoint diretamente na fun√ß√£o API, ou seja, qualquer outro ponto do notepad em que ele tiver vontade de chamar a mesma API ir√° ativar o mesmo breakpoint e exibir a mesma mensagem, o que pode ser um pouco importuno da parte dele. Um bom exerc√≠cio p√≥s-leitura seria tratar as condi√ß√µes em que a mensagem ser√° trocada, talvez se baseando na mensagem recebida. Mas isso j√° √© li√ß√£o de casa, e paramos por aqui.</p>
</section>
<span epub:type="pagebreak" id="_tedio" title="T√©dio"/>
<section title="T√©dio" epub:type="bodymatter chapter">
<h1 class="chapter-subtitle"><strong>T√©dio</strong></h1>
<p class="note-title">2007-10-01 <a href="_200709.xhtml#_preconceito">&lt;</a><a href="toc_quotes.xhtml">quotes</a><a href="_200711.xhtml#_responsabilidade">&gt;</a> <a href="_200709.xhtml#_preconceito">&lt;</a><a href="toc_self.xhtml">self</a><a href="_200711.xhtml#_responsabilidade">&gt;</a> <a href="_200709.xhtml#_preconceito">&lt;</a><a href="toc_now.xhtml">now</a><a href="_200711.xhtml#_responsabilidade">&gt;</a></p>

<p>&gt; O t√©dio √© um movimento de energia condicionada dentro de voc√™.</p>
<p>&gt; Tolle, Eckhart (O Poder do Agora, 1997)</p>
</section>
</div>
</body>
</html>
