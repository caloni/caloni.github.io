<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Blogue do Caloni</title>
<meta name="author" content="Caloni" />
<meta name="generator" content="https://github.com/caloni/journal">
<meta property="og:title" content="Blogue do Caloni"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="http://www.caloni.com.br"/>
<meta property="og:image" content="/img/about-brand.png"/>
<meta property="og:description" content="Write for computers, people and food."/>
<link href="/index.xml" rel="feed" type="application/rss+xml" title="Blogue do Caloni"/>
<link rel="stylesheet" type="text/css" href="/css/custom.css"/>
<link rel="stylesheet" type="text/css" href="/css/jquery-ui.css"/>
<script src="/js/jquery-1.12.4.js"></script>
<script src="/js/jquery-ui.js"></script>
<script src="/js/copy_clipboard.js"></script>
<script>
var quick_search_posts = [ 
 ]; 
</script>
<script src="/js/quick_search.js"></script>
<script src="/js/list.js"></script>
<link rel="icon" href="/img/favicon.ico"/>
</head>
<body style="min-height:100vh;display:flex;flex-direction:column">
<nav class="navbar has-shadow is-white"
role="navigation" aria-label="main navigation">
<div class="container">
<div class="navbar-brand">
&nbsp;
<a class="navbar-item" href="index.html">
<div class="is-4"><b>caloni::ccpp</b></div>
</a>
</div>
</div>
</nav>
<div class="container">
<div class="column">
<div style="min-height:56vh">
<div style="padding-bottom: 1em;"></div>
<input type="text" name="filter" value="" id="filter" placeholder="enter to select" style="width: 100%; font-size: 1.5rem; margin-top: 1em; margin-bottom: 0.5em;" title=""/></br>
<button id="filterbutton" style="font-size: 1rem;" onclick="ApplyFilter($('#filter').val());">select</button>
<button id="removebutton" style="font-size: 1rem;" onclick="ApplyNotFilter($('#filter').val());">remove</button>
<button id="randombutton" style="font-size: 1rem;" onclick="window.location = randomPost;">random</button>
<div><big><b><span style="visibility: hidden; padding: 5px;" name="results" id="results">...</span></b></big></div>
<table class="sortable" style="width: 100%;">
<tr><td>
<b><a href="2024-07.html#se_nao_instanciou_o_template_nao_tem_nada_de_errado">Se não instanciou o template não tem nada de errado</a></b>
<small><i>2024-07-03 ccpp computer  Considere este código: struct Adapter1 { static const int Size = 10; }; struct Adapter2 { static const int NoSize = 10; }; template<typename Adapter> struct Size { int size() { return Adapter::Size; } };</small></i>
</td></tr>
<tr><td>
<b><a href="2022-11.html#passagem_de_parametros_c_vs_c++">Passagem de Parâmetros C vs C++</a></b>
<small><i>2022-11-20 ccpp computer  Em C não é necessário declarar os parâmetros que uma função recebe. Isso é implícito. A linguagem C foi criada para ser um amontoado de assembly descrito com um pouco de syntax sugar e juntado pelo linker através de uma tabela de nomes. O que importa são os nomes. Vamos exemplificar:</small></i>
</td></tr>
<tr><td>
<b><a href="2022-11.html#gerenciamento_de_memoria_em_c/c++">Gerenciamento de Memória em C/C++</a></b>
<small><i>2022-11-19 videos ccpp computer  Esta semana fiz uma passagem de conhecimento na firma sobre os smart pointers em C++, que era no fundo o que todo mundo queria entender. Mas para entender essas coisas nada como voltar aos fundamentos da linguagem C e ir subindo nos conceitos.</small></i>
</td></tr>
<tr><td>
<b><a href="2020-08.html#getargs_v_array">GetArgs v. Array</a></b>
<small><i>2020-08-04 ccpp computer  Algumas pessoas ficam chateadas quando não se programa usando Boost para tudo. E por isso eu continuo escrevendo código simples e funcional para meu blogue. Esse código vai continuar funcionando por mais cem anos e o código da Boost vai explodir antes que seus filhos nasçam.</small></i>
</td></tr>
<tr><td>
<b><a href="2020-06.html#c++_co_routines">C++ Co Routines</a></b>
<small><i>2020-06-21 blogging ccpp computer  Entre os gêneros mais famosos do cinema e da programação está o terror, esse estado mental que se caracteriza pelo medo ou pela aversão a uma situação que envolve a perda de controle. Nesse quesito se encaixam as novas corrotinas que serão adotadas pelo padrão C++.</small></i>
</td></tr>
<tr><td>
<b><a href="2020-06.html#printf">Printf</a></b>
<small><i>2020-06-18 ccpp computer  Entre os segredos escondidos das funções básicas da lib padrão da linguagem C o printf e o scanf lideram o ranking. O printf possui a capacidade de alinhamento de colunas das string impressas com tamanho variável. Sabia disso? Pois é, isso não se ensina nas escolas.</small></i>
</td></tr>
<tr><td>
<b><a href="2020-04.html#cast_operator">Cast Operator</a></b>
<small><i>2020-04-22 ccpp computer  O código abaixo não é C++ moderno. É 98. Porém, ele já demonstra alguns problemas na linguagem que foram aumentados desde então. Não se sabe exatamente qual a tradução semântica de construções tão parecidas quanto o operador-função e o operador-cast. Enquanto o primeiro serve para transformar objetos em funções chamáveis o segundo serve para extrair tipos de maneira educada.</small></i>
</td></tr>
<tr><td>
<b><a href="2019-08.html#some_things_i_learned_in_a_hacker_rank_exercise">Some things I learned in a Hacker Rank exercise</a></b>
<small><i>2019-08-08 english ccpp computer  A couple of days ago I subscribed to Hacker Hank, a website specialized in provide interview exercises. The site is as a better version of Code Jam, with the possibility to Compile & Run the code, as well as running several test cases.</small></i>
</td></tr>
<tr><td>
<b><a href="2018-08.html#meu_novo_parseador_de_argc_argv">Meu Novo Parseador de Argc Argv</a></b>
<small><i>2018-08-21 ccpp computer  Eis que me deparo com um projeto onde não posso usar STL. Ou seja, nada de map nem string. Isso quer dizer que minha função bonita e completa de parseamento de argumentos argc/argv não pode ser usado. Essa é uma má notícia. A boa notícia é que achei uma forma muito mais simples e à prova de falhas de fazer isso. Ele basicamente percorre o array argv em busca do nome do parâmetro enviado para a função. Uma vez que ele encontre ele retorna o próximo elemento. Na falta de próximo elemento ele simplesmente retorna uma string vazia que não é nulo, mas já indica que há o parâmetro na lista de argumento.</small></i>
</td></tr>
<tr><td>
<img src="img/cpp_arranca_os_cabelos_por_voce_zi5GJxE.png"/>
<b><a href="2017-09.html#c++_moderno_arranca_os_cabelos_por_voce_stdmove_e_classes_simples">C++ Moderno Arranca os Cabelos por Você (std::move e classes simples).</a></b>
<small><i>2017-09-26 ccpp  Um dos [últimos posts] no grupo CCPPBR do Thiago Adams chama mais uma vez a atenção para a complexidade infinita que linguagens como C++ estão preferindo tomar. Esta é a geração que irá sofrer as dores de compatibilidade com o passado mais que todas as outras que virão.</small></i>
</td></tr>
<tr><td>
<b><a href="2016-11.html#a_linguagem_de_programacao_cpp_o_inicio">A Linguagem de Programação C++: O Início</a></b>
<small><i>2016-11-29 ccpp computer  O livro-base sobre a linguagem C++ e como programar nela tem o nome pouco criativo "The C++ Programming Language", e é de Bjarne Stroustrup, o criador da linguagem. Ele começou a desenhá-la em 1979, quando ainda a chamava de "C com Classes". Havia um problema a ser resolvido na época em que Stroustrup estava fazendo sua tese de doutorado. Havia linguagens muito boas em abstração como Simula, como o novo conceito de Orientação a Objetos, que carecia do mais importante na época: velocidade (só na época?). Já linguagens mais antigas como BCPL eram bem rápidas, mas eram tão simples que pareciam mais um Assembly glorificado. Havia, portanto, a necessidade de preencher a área de computação com alguma coisa bem no meio.</small></i>
</td></tr>
<tr><td>
<img src="img/gabaritos_3TkGFkN.png"/>
<b><a href="2016-01.html#gabaritos">Gabaritos</a></b>
<small><i>2016-01-13 ccpp computer  Um __template__ -- ou, como é na tradução da primeira edição de The C++ Programming Language, de Bjarne Stroustrup, aqui no Brasil: __gabarito__ -- é um molde que pode ser usado por diferentes tipos para traduzir o mesmo algoritmo, ou pelo menos a mesma intenção de algoritmo (por pela sobrecarga de operadores é possível que o comportamento de tipos diferentes pode ser diferente).</small></i>
</td></tr>
<tr><td>
<img src="img/classe_objeto_contexto_metodo_polimorfismo_k20fqVJ.gif"/>
<b><a href="2016-01.html#classe_objeto_contexto_metodo_polimorfismo">Classe, objeto, contexto, método, polimorfismo</a></b>
<small><i>2016-01-12 ccpp computer  No [post anterior] implementamos "métodos" em C usando ponteiros de função dentro de structs que eram passadas como parâmetro. Tudo isso embutido por um compilador que gera o que chamamos de instância de uma classe, ou objeto, em C++. Isso é possível graças ao contexto que é passado para uma função (que no caso de C++ é o operador implícito __this__, que sempre existe dentro de um método não-estático).</small></i>
</td></tr>
<tr><td>
<img src="img/classe_objeto_contexto_metodo_JLJaAsB.png"/>
<b><a href="2016-01.html#classe_objeto_contexto_metodo">Classe, objeto, contexto, método</a></b>
<small><i>2016-01-11 ccpp computer  No [post anterior] falamos como a passagem de um endereço de uma struct consegue nos passar o contexto de um "objeto", seja em C (manualmente) ou em C++ (automagicamente pelo operador implícito __this__). Trocamos uma propriedade desse "objeto" em C, mas ainda não chamamos um método.</small></i>
</td></tr>
<tr><td>
<img src="img/classe_objeto_contexto_dilbert.context.gif"/>
<b><a href="2016-01.html#classe_objeto_contexto">Classe, objeto, contexto</a></b>
<small><i>2016-01-10 ccpp computer  Para entender conceitos simples em C++, como métodos de uma classe, ajuda muito seguir o raciocínio dos programadores C e como eles lidavam com o tipo de problema que C++ resolve elegantemente implementando um novo compilador com uma nova linguagem.</small></i>
</td></tr>
<tr><td>
<b><a href="2015-04.html#c_c++_engenharia_reversa_e_todo_o_resto">C, C++, Engenharia Reversa e Todo o Resto</a></b>
<small><i>2015-04-27 ccpp  "C++ é divertido, mas não paga minhas contas". Por diversas coincidências da natureza, e um bocado de empenho deste que vos fala, essa frase não precisa ser dita por mim. Tendo programado em casa por 2 ou 3 anos e lido The C Programming Language um bocado de vezes antes de me aventurar no mercado de trabalho, tive a oportunidade de começar na área já programando em C, C++, e com uma equipe peso-pesado. Programávamos para Windows, onde as coisas não são tão fáceis quanto no Linux (que é um SO de e para programadores), e onde precisa-se comer muita farinha com sintaxe para construir coisas decentes. Portabilidade às vezes é um objetivo, às vezes é deixado de lado. A API Win32 já é bruta demais, e o cliente sempre tem um prazo apertado demais.</small></i>
</td></tr>
<tr><td>
<b><a href="2015-01.html#origem_do_tipo_char">Origem do Tipo char</a></b>
<small><i>2015-01-26 ccpp computer  Programadores C e C++, preparem-se para explodir as cabeças! No princípio... não, não. Antes do princípio, quando C era considerada a terceira letra do alfabeto e o que tínhamos eram linguagens experimentais para todos os lados, dois famigerados srs. dos Laboratórios Bell, K. Thompson e [D. Ritchie], criaram uma linguagem chamada B. E B era bom.</small></i>
</td></tr>
<tr><td>
<b><a href="2015-01.html#entendendo_a_compilacao">Entendendo a Compilação</a></b>
<small><i>2015-01-04 ccpp computer  Fiz alguns slides a pedido dos organizadores do TDC 2014, já que a palestra que ministrei com esse tema foi para ajudar meu amigo-sócio Rodrigo Strauss que não havia preparado nenhum slide a respeito.Felizmente eu já havia explicado alguns conceitos-chave para quem programa em C/C++ e precisa -- eu disse: PRECISA -- conhecer todo o passo-a-passo que leva o seu código-fonte a gerar um executável com código de máquina pronto para rodar.</small></i>
</td></tr>
<tr><td>
<b><a href="2014-03.html#a_moda_agora_e_levar_lambda_na_funcao">A moda agora é levar lambda na função</a></b>
<small><i>2014-03-28 ccpp computer  A nova moda de programar C++ nos últimos anos com certeza é usar lambda. Mas, afinal, o que é lambda? Bom, pra começar, é um nome muito feio. O que esse nome quer dizer basicamente é que agora é possível criar função dentro de função. Não só isso, mas passar funções inteiras, com protótipo, corpo e retorno, como parâmetro de função.</small></i>
</td></tr>
<tr><td>
<b><a href="2013-12.html#uma_nova_linguagem">Uma nova linguagem</a></b>
<small><i>2013-12-04 ccpp  Tenho que me atualizar. Faz um tempo (anos) em que deixei de lado esse mundo "frescurento" de C++2030 e me foquei única e exclusivamente em resolver problemas da melhor forma possível com o que a linguagem já tinha a oferecer em uma implementação estável de compilador e bibliotecas.</small></i>
</td></tr>
<tr><td>
<b><a href="2012-05.html#sobrecarga_de_funcao_as_avessas">Sobrecarga de função às avessas</a></b>
<small><i>2012-05-20 ccpp computer  > Nota do autor: navegando pelo Archive.org, que possibilita viajar no tempo e encontrar coisas enterradas que seria melhor deixar por lá, consegui encontrar um post que se perdeu na dobra espaço-temporal entre o old-fashioned Caloni.com.br (com direito à velha joaninha psicodélica, desenho do meu amigo que uso até hoje no blogue) e um finado outro domínio meu, o CThings. No final, consegui matar a marmota, chegar a [80 milhas por hora] e voltar para o presente. Enjoy!</small></i>
</td></tr>
<tr><td>
<b><a href="2008-05.html#aquele_do_while_engracado">Aquele do-while engraçado</a></b>
<small><i>2008-05-15 ccpp computer  Nesses últimos dias andei conversando com um amigo que está estudando sistemas operacionais na faculdade. Melhor ainda, vendo o código real de um sistema operacional em funcionamento. A conseqüência é que, além de aprender um bocado de como as coisas funcionam de verdade debaixo dos panos, acaba-se aprendendo alguns truquezinhos básicos e tradicionais da linguagem C.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-04.html#ode_ao_c++">Ode ao C++</a></b>
<small><i>2008-04-21 ccpp computer  Strauss: lembra quando nós conversávamos sobre o assunto "Por que C++?", há muitas décadas atrás, e seu blogue era um dos primeiros no Brasil que não ficava relatando o que o autor comia no café da manhã, além de falar sobre programação? Pois é, eu estava reorganizando meus g-mails e reencontrei nossa conversa e, pior, seu artigo "derivado" dela, que irei republicar aqui pois, assim como antes, acredito em tudo que escrevi naquela época.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-04.html#try_catch_flutuante">Try-catch flutuante</a></b>
<small><i>2008-04-03 ccpp computer  Esse detalhe da linguagem quem me fez descobrir foi o Yorick, que costuma comentar no blogue e tive o prazer de conhecer no [4o. EPA-CCPP]. É possível, apesar de bizarro, colocar um bloco try-catch em torno da lista de inicialização de variáveis de um construtor. Essa característica da linguagem permite que possamos capturar alguma exceção lançada por algum construtor de algum membro da classe. A construção em código ficaria no estilo abaixo:</small></i>
</td></tr>
<tr><td>
<img src="img/os_diferentes_erros_na_linguagem_c_linker.gif"/>
<b><a href="2008-02.html#os_diferentes_erros_na_linguagem_c">Os diferentes erros na linguagem C</a></b>
<small><i>2008-02-15 ccpp computer  Uma coisa que me espanta de vez em quando é o total desconhecimento por programadores mais ou menos experientes dos níveis de erros que podem ocorrer em um fonte escrito em C ou C++. Desconheço o motivo, mas desconfio que o fato de outras linguagens não terem essa divisão de processos pode causar alguma nivelação entre as linguagens e fazer pensar que o processo de compilação em C é como em qualquer outra linguagem.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-10.html#protecao_dos_membros_protected">Proteção dos membros protected</a></b>
<small><i>2007-10-26 ccpp computer  Quando queremos que um membro de nossa classe seja visível apenas dentro dos métodos da classe e dentro dos métodos das classes derivadas dessa classe usamos o nível de proteção protected. Isso, é claro, não quer dizer que uma classe derivada vá ter acesso aos membros protegidos de outra:</small></i>
</td></tr>
<tr><td>
<b><a href="2007-10.html#typeid_e_os_perigos_do_nao_polimorfismo">Typeid e os perigos do não-polimorfismo</a></b>
<small><i>2007-10-24 ccpp computer  Quando usamos o operador typeid geralmente desejamos conhecer informações sobre o tipo exato do objeto que temos em mãos, independente da hierarquia de herança a qual seu tipo pertença. Só que por ignorar, assim como o [sizeof], que esse operador possui duas caras, às vezes damos com os burros n'água e compramos gato por lebre. Não é pra menos. Uma sutil diferença entre classes polimórficas e estáticas pode dar aquele susto que só C++ pode proporcionar.</small></i>
</td></tr>
<tr><td>
<img src="img/the_c_programming_language_binary_tree.gif"/>
<b><a href="2007-10.html#the_c_programming_language">A Linguagem de Programação C: O Livro</a></b>
<small><i>2007-10-12 computer books ccpp  O clássico de Ritchie e Kernighan, criadores da linguagem C, não foi meu primeiro livro de programação. E nem deveria ser. Não o recomendo para iniciantes, pois é necessário possuir algum conhecimento e prática para realmente aproveitar os conceitos desse livro.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-09.html#a_mobilidade_das_variaveis_no_printf">A mobilidade das variáveis no printf</a></b>
<small><i>2007-09-20 ccpp computer  O printf (e derivados) tem sérios problemas por conta de sua falta de tipagem. Não vou aqui dizer que cout é a alternativa óbvia e melhorada porque não é. Mas isso é uma discussão que eu não deveria começar aqui. E não começarei. Portanto, ignorem essa linha =).</small></i>
</td></tr>
<tr><td>
<b><a href="2007-09.html#aquisicao_de_recurso_e_inicializacao">Aquisição de recurso é inicialização</a></b>
<small><i>2007-09-14 ccpp computer  O título desse artigo é uma técnica presente no paradigma da programação em C++, razão pela qual não temos o operador finally. A idéia por trás dessa técnica é conseguirmos usar recursos representados por objetos locais de maneira que ao final da função esses objetos sejam destruídos e, junto com eles, os recursos que foram alocados. Podemos chamar de recursos aquele arquivo que necessita ser aberto para escrita, o bitmap que é exibido na tela, o ponteiro de uma interface COM, etc. O nosso exemplo é sobre arquivos:</small></i>
</td></tr>
<tr><td>
<img src="img/historia_da_linguagem_c_parte_2_kthompson_dritchie.jpg"/>
<b><a href="2007-08.html#historia_da_linguagem_c_parte_2">História da Linguagem C: Parte 2</a></b>
<small><i>2007-08-15 ccpp computer  No princípio... não, não, não. Antes do princípio, quando C era considerada a terceira letra do alfabeto e o que tínhamos eram linguagens experimentais para todos os lados, dois famigerados senhores dos Laboratórios Bell, K. Thompson e D. Ritchie, criaram uma linguagem chamada B. E B era bom.</small></i>
</td></tr>
<tr><td>
<img src="img/historia_da_linguagem_c_parte_1_ccpp_build_steps.gif"/>
<b><a href="2007-08.html#historia_da_linguagem_c_parte_1">História da Linguagem C: Parte 1</a></b>
<small><i>2007-08-01 ccpp computer  Confesso que adoro estudar sobre a história da linguagem C. Essa verdadeira adoração pela linguagem me fez estudar suas precursoras, como as linguagens BCPL e B. Posso dizer que todo esse conhecimento, no final das contas, valeu a pena. Hoje entendo muito melhor as decisões tomadas na criação da linguagem e, principalmente, a origem de algumas idiossincrasias e boas idéias que permaneceram até hoje.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-07.html#c_and_c++_operators_precedence_table">C and C++ Operators Precedence Table</a></b>
<small><i>2007-07-30 english ccpp computer  > Wanderley, your explanation about [why a program compiles in C++ and not in C] seems to me logic and correct, but gave me some doubts, because I always learned that the C and C++ operator precedence are the same thing. I checked out the Appendix A in the "C ++ - How To Program" (sixth edition) and the book table is equal to the C operators precedence table and it is different from the C++ precedence table presented by you in the article. I went to the internet and found out in two websites the table and both are equal to the book table:</small></i>
</td></tr>
<tr><td>
<b><a href="2007-07.html#c++0x_parcial_no_novo_gcc_43">C++0x parcial no novo GCC 4.3</a></b>
<small><i>2007-07-24 ccpp computer  A [nova versão do GCC] implementa em caráter de teste algumas novas características da nova versão da linguagem C++, que será lançada ainda nesta década (provavelmente em 2009). As novas funcionalidades são empolgantes e já fazem parte do imaginário dos programadores C++ já há algum tempo.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-07.html#what_happens_inside_the_sizeof_operator">What happens inside the sizeof operator</a></b>
<small><i>2007-07-16 english ccpp computer  The question: how to get the size of a struct member without declaring it as a variable in memory? In pseudocode:     static const size_t FIELD_SIZE_MSGID = 15;          struct FEEDER_RECORD_HEADER     {</small></i>
</td></tr>
<tr><td>
<b><a href="2007-07.html#precedence_difference">Precedence difference</a></b>
<small><i>2007-07-10 english ccpp computer  Once upon a time my old friend Kabloc wrote this little and "harmless" function in order to print the multiplication table:     #include <stdio.h>          int main()     {       int f1,f2,s=0;          for( f1 = 1; (f1 == 11 && s != 5) ? s=5, f1=0, putchar(10) : ( f1 <= 10 ) ? f1 = f1 : f1 = 12, f1 <= 11 ; f1++ )</small></i>
</td></tr>
<tr><td>
<b><a href="2007-06.html#disassembling_the_array_operator">Disassembling the array operator</a></b>
<small><i>2007-06-22 code english ccpp computer  Arrays are fascinating in C language because they are so simple and so powerful at the same time. When we start to really understand them and realize all its power we are very close to understand another awesome feature of the language: pointers.</small></i>
</td></tr>
</table>
<span style="float: left;">
</span>
</div>
</div>
</section>
<footer class="footer">
<div class="container">
</div>
<div class="intentionally-blank"></div>
</footer>
</body>
</html>
