<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Jornal do Caloni</title>
<meta name="author" content="Caloni" />
<meta name="generator" content="https://github.com/caloni/journal">
<meta property="og:title" content="Jornal do Caloni"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="http://www.caloni.com.br"/>
<meta property="og:image" content="/journal/img/about-brand.png"/>
<meta property="og:description" content="Write for computers, people and food."/>
<link href="/journal/index.xml" rel="feed" type="application/rss+xml" title="Jornal do Caloni"/>
<link rel="stylesheet" type="text/css" href="/journal/css/custom.css"/>
<link rel="stylesheet" type="text/css" href="/journal/css/jquery-ui.css"/>
<script src="/journal/js/jquery-1.12.4.js"></script>
<script src="/journal/js/jquery-ui.js"></script>
<script src="/journal/js/copy_clipboard.js"></script>
<script>
var quick_search_posts = [ 
 ]; 
</script>
<script src="/journal/js/quick_search.js"></script>
<script src="/journal/js/list.js"></script>
<link rel="icon" href="/journal/img/favicon.ico"/>
</head>
<body style="min-height:100vh;display:flex;flex-direction:column">
<nav class="navbar has-shadow is-white"
role="navigation" aria-label="main navigation">
<div class="container">
<div class="navbar-brand">
&nbsp;
<a class="navbar-item" href="index.html">
<div class="is-4"><b>Jornal do Caloni</b></div>
</a>
</div>
</div>
</nav>
<div class="container">
<div class="column">
<div style="min-height:56vh">
<div style="padding-bottom: 1em;"></div>
<input type="text" name="filter" value="" id="filter" placeholder="enter to select" style="width: 100%; font-size: 1.5rem; margin-top: 1em; margin-bottom: 0.5em;" title=""/></br>
<button id="filterbutton" style="font-size: 1rem;" onclick="ApplyFilter($('#filter').val());">select</button>
<button id="removebutton" style="font-size: 1rem;" onclick="ApplyNotFilter($('#filter').val());">remove</button>
<button id="randombutton" style="font-size: 1rem;" onclick="window.location = randomPost;">random</button>
<div><big><b><span style="visibility: hidden; padding: 5px;" name="results" id="results">...</span></b></big></div>
<table class="sortable" style="width: 100%;">
<tr><td>
<b><a href="2008-01.html#rmthread_rode_codigo_em_processo_vizinho">RmThread: rode código em processo vizinho</a></b>
<small><i>2008-01-28 blog computer  Aproveitando que utilizei a mesma técnica semana passada para desenvolver um vírus para Ethical Hacking, republico aqui este artigo que já está mofando no Code Project (update 2026-02-07: e pelo que vi ele nem existe mais), mas que espero que sirva de ajuda pra muita gente que gosta de fuçar nos internals do sistema. Boa leitura!</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/keychanger_de_crianca_russian_keyboard.png"/>
<b><a href="2008-01.html#keychanger_de_crianca">Keychanger de criança</a></b>
<small><i>2008-01-24 blog computer  Às vezes na vida a vontade de fazer alguma coisa besta acaba sendo mais forte do que o senso de ridículo. Então, resolvi ressuscitar o quase apodrecido [RusKey], um programa que fiz para trocar letras digitadas no teclado. A idéia é muito simples: o sujeito digita 'i' e sai um 'c', digita um 'f' e sai um 'u', e assim por diante. Se estiver programando e for criar um if, por exemplo, no lugar da palavra if vai aparecer... bom, não é exatamente um if que vai aparecer na tela =).</small></i>
</td></tr>
<tr><td>
<b><a href="2008-01.html#otimizacao_em_funcoes_recursivas">Otimização em funções recursivas</a></b>
<small><i>2008-01-18 blog computer  O livro que estou lendo, Dominando Algoritmo com C, como o próprio nome diz, fala sobre algoritmos em C. Os primeiros capítulos são praticamente uma revisão para quem já programou em C, pois tratam de coisas que programadores com mais de cinco anos de casa devem ter na memória cachê (listas, pilhas, recursão, etc). Porém, tive uma agradável surpresa de achar um truque muito sabido que não conhecia, chamado de [tail recursion]. Fiz questão de testar nos dois compiladores mais conhecidos e eis o resultado.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/encontrando_as_respostas_do_flash_pops_flash_pops.gif"/>
<b><a href="2008-01.html#encontrando_as_respostas_do_flash_pops">Encontrando as respostas do Flash Pops</a></b>
<small><i>2008-01-16 blog computer  Existia uma série de jogos no sítio da UOL chamado Flash Pops onde você deve acertar o nome de filmes, programas de televisão, entre outros, que vão da década de 40 até a atualidade. É divertido e viciante fazer pesquisa na internet para encontrar os resultados, ainda mais quando já se é viciado em cinema. Ficamos jogando, eu e minha namorada, por semanas a fio. Quase chegamos a preencher tudo, e por um bom tempo ficamos travados para terminar. Então começamos a apelar para o Google e o IMDB até os limites do razoável. Nesse fim de semana, por exemplo, chegamos a assistir um filme de madrugada onde tocou rapidamente um trecho de uma das músicas que faltava no jogo sobre televisão. No dia seguinte procuramos a trilha sonora do filme, ouvimos faixa a faixa e procuramos o nome da música no Google, para finalmente encontrar o resultado.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/driver-ida-01.png"/>
<b><a href="2008-01.html#analisando_dumps_com_windbg_e_ida">Analisando Dumps com WinDbg e IDA</a></b>
<small><i>2008-01-10 blog computer  Apesar de ser recomendado que 100% dos componentes de um software esteja configurado corretamente para gerar símbolos na versão release, possibilitando assim a visualização do nome das funções internas através de um arquivo de dump (despejo) gerado na ocorrência de um crash, essa verdade só ocorre em 80% das vezes. Quis Murphy que dessa vez a única parte não "simbolizada" fosse a que gerou a tela azul em um Intel Quad Core que estou analisando esses dias.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-12.html#curiosidades_inuteis_o_operador_de_subscrito_em_c">Curiosidades inúteis: o operador de subscrito em C++</a></b>
<small><i>2007-12-27 blog computer  Este artigo é uma reedição de meu blogue antigo, guardado para ser republicado durante minhas miniférias. Esteja à vontade para sugerir outros temas obscuros sobre a linguagem C ou C++ de sua preferência. Boa leitura!</small></i>
</td></tr>
<tr><td>
<b><a href="2007-12.html#o_que_acontece_quando_o_contador_estoura">O que acontece quando o contador estoura</a></b>
<small><i>2007-12-25 blog computer  Dois conceitos de programação relacionados a limites computacionais são bem conhecidos do programador: o famigerado overflow e o não-tão-famoso underflow (embora seja fácil imaginar que ele é o oposto do primeiro). O primeiro ocorre quando somamos a uma variável inteira não-nula um valor cujo resultado não consegue ser representado pelo tamanho de memória usado para armazenar esse tipo inteiro (que pode ser um caractere, um inteiro curto, inteiro longo e por aí vai). O underflow, por outro lado (outro lado mesmo), é o resultado de uma subtração que não pode ser representado pelo número de bits do seu tipo inteiro.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-12.html#sizeof_de_novo">Sizeof (de novo)</a></b>
<small><i>2007-12-17 blog computer  Algumas coisas em C parecem tão simples na programação do dia-a-dia que em alguns momentos podem existir situações confusas e misteriosas. O uso obscuro do operador sizeof, por exemplo, pode dar margem a interpretações erradas a respeito do que está acontecendo por debaixo dos panos. Apesar do padrão ter sido elaborado para tentar tornar a linguagem uma coisa intuitiva e de fácil dedução, isso não acontece todas as vezes.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-11.html#carregando_dlls_arbitrarias_pelo_windbg_parte_2">Carregando DLLs arbitrárias pelo WinDbg ou como escrever script para WinDbg</a></b>
<small><i>2007-11-27 blog computer  Um script no WinDbg nada mais é que uma execução em batch: um arquivo texto cheio de comandos que poderíamos digitar manualmente, mas que preferimos guardar para poupar nossos dedos. Existem quatro maneiras diferentes de chamar um script no WinDbg, todas muito parecidas, variando apenas se são permitidos espaços antes do nome do arquivo e se os comandos são condensados, isto é, as quebras de linhas substituídas por ponto-e-vírgula para executar tudo em uma linha só.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-11.html#carregando_dlls_arbitrarias_pelo_windbg">Carregando DLLs arbitrárias pelo WinDbg</a></b>
<small><i>2007-11-23 blog computer  Durante meus testes para a correção de um bug me deparei com a necessidade de carregar uma DLL desenvolvida por mim no processo depurado. O detalhe é que o processo depurado é de terceiros e não possuo o fonte. Portanto, as opções para mim mais simples são: 1) Usar o projeto [RmThread] para injetar a DLL (nesse caso iniciando o processo através dele), 2) Fazer um módulo wrapper para uma DLL qualquer e ser carregado de brinde, 3) Usar o WinDbg e brincar um pouco.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/detectando_hooks_globais_no_windbg_codigo_malicioso.gif"/>
<b><a href="2007-11.html#detectando_hooks_globais_no_windbg">Detectando hooks globais no WinDbg (SetWindowsHookEx)</a></b>
<small><i>2007-11-09 blog computer  Nada como um comando prático para aprender rapidamente uma técnica. Nesse caso, tive que usar o seguinte comando para localizar o momento em que um executável instala um hook global: bp user32!SetWindowsHookExA "j poi(esp+4*4) 'g' ; '.echo *** GLOBAL HOOK ***; g'".</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/ponteiro_de_metodo_qual_this_e_usado_fuzzycall.gif"/>
<b><a href="2007-11.html#ponteiro_de_metodo_qual_this_e_usado">Ponteiro de método: qual this é usado?</a></b>
<small><i>2007-11-07 blog computer  Depois de publicado o artigo anterior sobre ponteiros de métodos surgiu uma dúvida muito pertinente do autor do blogue [CodeBehind], um escovador de bits disfarçado de programador .NET: qual objeto que vale na hora de chamar um método pelo ponteiro?</small></i>
</td></tr>
<tr><td>
<b><a href="2007-11.html#ponteiros_de_metodo_conceito_fundamental">Ponteiros de método: conceito fundamental</a></b>
<small><i>2007-11-05 blog computer  Diferente de ponteiros de função globais ou estáticas, que são a grosso modo ponteiros como qualquer um, os ponteiros de método possuem uma semântica toda especial que costuma intimidar até quem está acostumado com a aritmética de ponteiros avançada. Não é pra menos: é praticamente uma definição à parte, com algumas limitações e que deixa a desejar os quase sempre criativos programadores da linguagem, que vira e mexe estão pedindo mudanças no C++0x.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/brincando_com_o_windbg_notepad_wonderful_file.png"/>
<b><a href="2007-10.html#alterando_mensagem_de_erro_no_notepad">Alterando mensagem de erro no Notepad</a></b>
<small><i>2007-10-30 blog windbg computer  Existem duas maneiras de depurar um programa localmente usando o WinDbg: iniciá-lo pelo próprio WinDbg ou conectar o depurador (attach) em um programa já em execução. Podemos especificar o que faremos direto na linha de comando ou pela sua interface. Pela linha de comando podemos usar os comandos windbg notepad.exe, windbg -pn notepad.exe e windbg -p pid. Pela interface são os conhecidos itens do menu File: Open Executable e Attach to a Process.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-10.html#protecao_dos_membros_protected">Proteção dos membros protected</a></b>
<small><i>2007-10-26 blog ccpp computer  Quando queremos que um membro de nossa classe seja visível apenas dentro dos métodos da classe e dentro dos métodos das classes derivadas dessa classe usamos o nível de proteção protected. Isso, é claro, não quer dizer que uma classe derivada vá ter acesso aos membros protegidos de outra:</small></i>
</td></tr>
<tr><td>
<b><a href="2007-10.html#typeid_e_os_perigos_do_nao_polimorfismo">Typeid e os perigos do não-polimorfismo</a></b>
<small><i>2007-10-24 blog ccpp computer  Quando usamos o operador typeid geralmente desejamos conhecer informações sobre o tipo exato do objeto que temos em mãos, independente da hierarquia de herança a qual seu tipo pertença. Só que por ignorar, assim como o [sizeof], que esse operador possui duas caras, às vezes damos com os burros n'água e compramos gato por lebre. Não é pra menos. Uma sutil diferença entre classes polimórficas e estáticas pode dar aquele susto que só C++ pode proporcionar.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/guia_basico_para_programadores_de_primeiro_breakpoint_debug.png"/>
<b><a href="2007-10.html#guia_basico_para_programadores_de_primeiro_breakpoint">Guia básico para programadores de primeiro breakpoint</a></b>
<small><i>2007-10-22 blog computer  Aproveitando um dos últimos artigos que fala sobre [conceitos básicos de programação], lembro que, tão importante quanto programar é possuir habilidades básicas de depuração, uma arte por muitos programadores ignorada.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/por_que_minha_dll_travou_loader_lock.gif"/>
<b><a href="2007-10.html#por_que_minha_dll_travou">Por que minha DLL travou?</a></b>
<small><i>2007-10-18 blog computer  O resumo da ópera é que o código do Windows chamador do DllMain das DLLs carregadas/descarregadas utiliza um objeto de acesso exclusivo (leia "mutex") para sincronizar as chamadas. O resultado é que, em um processo, apenas um DllMain é chamado em um dado momento. Esse objeto é chamado de loader lock na documentação da Microsoft.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/guia_basico_para_programadores_de_primeiro_int_main_for.gif"/>
<b><a href="2007-10.html#guia_basico_para_programadores_de_primeiro_int_main">Guia básico para programadores de primeiro int main</a></b>
<small><i>2007-10-16 blog computer  > Vou aproveitar que meu amigo DQ publicou um artigo muito bom sobre [como fazer programas fáceis de manter] (merece ser lido!) e vou republicar um artigo do blogue antigo sobre o básico do básico para quem deseja entender como os programas funcionam. Não é nada sofisticado, apenas alguns conceitos comuns que, se você deseja ser programador, deveria procurar saber.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/the_c_programming_language_binary_tree.gif"/>
<b><a href="2007-10.html#the_c_programming_language">A Linguagem de Programação C: O Livro</a></b>
<small><i>2007-10-12 blog computer books ccpp  O clássico de Ritchie e Kernighan, criadores da linguagem C, não foi meu primeiro livro de programação. E nem deveria ser. Não o recomendo para iniciantes, pois é necessário possuir algum conhecimento e prática para realmente aproveitar os conceitos desse livro.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/historia_do_windows_parte_50_windows_architecture.png"/>
<b><a href="2007-10.html#historia_do_windows_parte_50">História do Windows - parte 5.0</a></b>
<small><i>2007-10-08 blog computer  Em novembro de 1998 (apenas para parceiros Microsoft) é lançada a versão 5.0 do Windows NT, conhecida como Windows 2000. Melhorias significativas foram feitas no acesso à internet, intranet e extranet. Aplicações de gerenciamento se integram fortemente e a grande novidade em termos de estruturação de dados é o Active Directory, uma tecnologia compatível com o conceito de Distributed File System, que viabiliza uma nova forma das empresas organizarem seus dados de maneira mais transparente à rede. Assim começou a [História do Windows] para redes de gente grande.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/debug_da_bios_com_o_softice_16_bits_myos_start.png"/>
<b><a href="2007-10.html#debug_da_bios_com_o_softice_16_bits">Debug da BIOS com o SoftIce 16 bits</a></b>
<small><i>2007-10-02 blogging blog computer  Para quem acha que ainda não desceu demais o nível existe um [ótimo artigo] no Code Project de S. Z. Keller (aka ShalomZ) sobre como construir seu próprio sistema operacional. É simples, direta e empolgante a maneira com que ele explica e trata os detalhes básicos, desde quando o computador é ligado até quando o boot loader carrega e entrega o controle de execução. Eu mesmo fiz o teste com a imagem que foi disponibilizada para download e funcionou direitinho. Agora esse meu artigo se dispõe a explicar como você pode fazer para depurar o processo de load do seu primeiro sistema operacional.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-09.html#why_is_my_dll_locked">Why is my DLL locked?</a></b>
<small><i>2007-09-24 blog english computer  The Windows code responsible to call DllMain for each loaded and unloaded DLLs uses an exclusive access object, the so-called mutex, to synchronize its calls. The result is that inside a process just one DllMain can be called at a given moment. This object-mutex is called "loader lock" into the Microsoft documentation.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/hook_de_com_no_windbg_iunknown_breakpoint.png"/>
<b><a href="2007-09.html#hook_de_com_no_windbg">Hook de COM no WinDbg</a></b>
<small><i>2007-09-18 blog computer  Continuando com o tema hooks no WinDbg vamos aqui "hookear" e analisar as chamadas de métodos de um objeto COM. O que será feito aqui é o mesmo experimento feito para uma palestra de engenharia reversa que apresentei há um tempo atrás, mas com as opções de pause, rewind, replay e câmera lenta habilitadas.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-09.html#aquisicao_de_recurso_e_inicializacao">Aquisição de recurso é inicialização</a></b>
<small><i>2007-09-14 blog ccpp computer  O título desse artigo é uma técnica presente no paradigma da programação em C++, razão pela qual não temos o operador finally. A idéia por trás dessa técnica é conseguirmos usar recursos representados por objetos locais de maneira que ao final da função esses objetos sejam destruídos e, junto com eles, os recursos que foram alocados. Podemos chamar de recursos aquele arquivo que necessita ser aberto para escrita, o bitmap que é exibido na tela, o ponteiro de uma interface COM, etc. O nosso exemplo é sobre arquivos:</small></i>
</td></tr>
<tr><td>
<b><a href="2007-09.html#antidebug_detectando_attach">Antidebug: Detectando Attach</a></b>
<small><i>2007-09-10 blog antidebug projects computer  Hoje foi um belo dia para engenharia reversa e análise de proteções. Dois ótimos programas vieram ao meu conhecimento: um monitor de chamadas de API e um monitor de chamadas de COM (complementando o primeiro, que não monitora funções depois que CoCreateInstance foi chamado). Além de que no site do primeiro programa - de algum entusiasta do bom e velho Assembly Win32, diga-se de passagem - encontrei o código-fonte para mais uma técnica antidebugging, o que nos leva de volta para a já consagrada série de técnicas antidepuração.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-08.html#barata_eletrica_e_o_hacker_de_antigamente">Barata Elétrica e o hacker de antigamente</a></b>
<small><i>2007-08-31 blog essays  Os artigos escritos por ele estavam em português, mas sempre em suas edições ele disponibilizava artigos de outras partes do mundo em inglês. Praticamente li todos eles, e muitos fiz questão de ler mais de uma vez. A maioria falava de um mundo que existia antes de eu ter um computador, onde existiam vírus e pirataria de programas em disquetes, BBSs e a tal reserva de mercado. Além, é claro, de dicas de como ser um nerd e não perder a sociabilidade (se é que isso é possível quando se é um nerd adolescente). Existe uma página no zine onde estão listados os melhores artigos de todos os tempos da revista.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-08.html#hook_de_api_no_windbg">Hook de API no WinDbg</a></b>
<small><i>2007-08-29 blog computer  Basicamente existem duas maneiras de um executável obter o endereço de uma função API do Windows: ou ele usa uma lib de interface com a DLL (o chamado "link estático") ou ele chama a função GetProcAddress explicitamente (1).</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/antidebug_ocupando_a_debugport_debugport.gif"/>
<b><a href="2007-08.html#antidebug_ocupando_a_debugport">Antidebug: ocupando a DebugPort</a></b>
<small><i>2007-08-23 blog projects computer  Quando um depurador inicia um processo para ser depurado ou, o caso abordado por este artigo, se conecta em um processo já iniciado, as comunicações entre esses dois processos é feita através de um recurso interno do Windows chamado de LPC (Local Procedure Call). O sistema cria uma "porta mágica" de comunicação específica para a depuração e os eventos trafegam por meio dela.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/historia_da_linguagem_c_parte_2_kthompson_dritchie.jpg"/>
<b><a href="2007-08.html#historia_da_linguagem_c_parte_2">História da Linguagem C: Parte 2</a></b>
<small><i>2007-08-15 blog ccpp computer  No princípio... não, não, não. Antes do princípio, quando C era considerada a terceira letra do alfabeto e o que tínhamos eram linguagens experimentais para todos os lados, dois famigerados senhores dos Laboratórios Bell, K. Thompson e D. Ritchie, criaram uma linguagem chamada B. E B era bom.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-08.html#antidebug_interpretacao_baseada_em_excecao_parte_2">Antidebug: interpretação baseada em exceção (parte 2)</a></b>
<small><i>2007-08-09 blog projects computer  No [primeiro artigo] vimos como é possível "enganar" o depurador através de exceções e assim fazer o atacante perder um tempo considerável tentando se desvencilhar dos breakpoints de mentira. Porém, vimos também que essa é uma solução difícil de manter no código-fonte, além de possuir o ponto fraco de ser facilmente contornada se descoberta. Agora é a hora de tornar as coisas mais fáceis de manter e ao mesmo tempo garantir maior dificuldade mesmo que o atacante descubra o que está acontecendo debaixo do seu nariz.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/historia_do_windows_parte_30_windows_message_loop.gif"/>
<b><a href="2007-08.html#historia_do_windows_parte_30">História do Windows - parte 3.0</a></b>
<small><i>2007-08-03 blog computer  Em 22 de maio de 1990 a versão 3.0 do Windows foi lançada. Foi melhorado o gerenciador de programas e o sistema de ícones, além de um novo gerenciador de arquivos e suporte a 16 cores. Entre as mudanças internas podemos citar a velocidade e a confiabilidade. Como a partir dessa versão apareceram muitos desenvolvedores que passaram a suportar a plataforma, o número de programas disponíveis aumentou, o que conseqüentemente fez com que as vendas alavancassem. Três milhões de cópias foram vendidas apenas no primeiro ano, e assim o Windows se tornou padrão nos computadores domésticos. Quando a versão 3.1 foi lançada, em 6 de abril de 1992, mais três milhões de cópias foram vendidos em apenas dois meses.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/historia_da_linguagem_c_parte_1_ccpp_build_steps.gif"/>
<b><a href="2007-08.html#historia_da_linguagem_c_parte_1">História da Linguagem C: Parte 1</a></b>
<small><i>2007-08-01 blog ccpp computer  Confesso que adoro estudar sobre a história da linguagem C. Essa verdadeira adoração pela linguagem me fez estudar suas precursoras, como as linguagens BCPL e B. Posso dizer que todo esse conhecimento, no final das contas, valeu a pena. Hoje entendo muito melhor as decisões tomadas na criação da linguagem e, principalmente, a origem de algumas idiossincrasias e boas idéias que permaneceram até hoje.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-07.html#c_and_c++_operators_precedence_table">C and C++ Operators Precedence Table</a></b>
<small><i>2007-07-30 blog english ccpp computer  > Wanderley, your explanation about [why a program compiles in C++ and not in C] seems to me logic and correct, but gave me some doubts, because I always learned that the C and C++ operator precedence are the same thing. I checked out the Appendix A in the "C ++ - How To Program" (sixth edition) and the book table is equal to the C operators precedence table and it is different from the C++ precedence table presented by you in the article. I went to the internet and found out in two websites the table and both are equal to the book table.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/movendo_o_cursor_do_mouse_com_o_teclado_windows_loop_mensagens_input.gif"/>
<b><a href="2007-07.html#movendo_o_cursor_do_mouse_com_o_teclado">Movendo o cursor do mouse com o teclado</a></b>
<small><i>2007-07-26 blog projects computer  Bom, vamos deixar de papo furado e "codar". Para essa primeira tentativa iremos desenvolver um programa que move o cursor do mouse quando pressionada uma tecla de atalho e voltar à sua posição original quando pressionada outra tecla.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-07.html#antidebug_interpretacao_baseada_em_excecao_parte_1">Antidebug: interpretação baseada em exceção (parte 1)</a></b>
<small><i>2007-07-20 blog projects computer  Um depurador utiliza breakpoints para "paralisar" momentaneamente a execução do programa sendo depurado. Para isso ele se utiliza de uma bem conhecida instrução conhecida como int 3. Essa instrução gera uma exceção -- exceção de breakpoint -- que é capturada pelo sistema operacional e repassada para o código de tratamento dessa exceção. Em programas sendo depurados esse código está localizado no depurador. Em programas "livres" esse código normalmente não existe e ao acontecer essa exceção o aplicativo simplesmente "capota".</small></i>
</td></tr>
<tr><td>
<b><a href="2007-07.html#what_happens_inside_the_sizeof_operator">What happens inside the sizeof operator</a></b>
<small><i>2007-07-16 blog english ccpp computer  The question: how to get the size of a struct member without declaring it as a variable in memory? In pseudocode:     struct S     {        char field1[15];        char field2[10];     };          // error C2143: syntax error : missing ')' before '.'</small></i>
</td></tr>
<tr><td>
<b><a href="2007-07.html#precedence_difference">Precedence difference</a></b>
<small><i>2007-07-10 blog english ccpp computer  Once upon a time my old friend Kabloc wrote this little and "harmless" function in order to print the multiplication table:     #include <stdio.h>          int main()     {       int f1,f2,s=0;          for( f1 = 1; (f1 == 11 && s != 5) ? s=5, f1=0, putchar(10) : ( f1 <= 10 ) ? f1 = f1 : f1 = 12, f1 <= 11 ; f1++ )</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/softice.png"/>
<b><a href="2007-07.html#introducao_ao_softice">Introdução ao SoftICE</a></b>
<small><i>2007-07-02 blog computer  O que acontece quando você precisa depurar um programa e não tem o Visual Studio instalado na máquina onde o problema está ocorrendo? Ora, para isso que existe o Remote Debugging. Eu uso direto. Você só precisa rodar um pequeno programa na máquina que vai ser depurada e abrir uma porta ou duas. O resto o Visual Studio da máquina que vai depurar faz.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-06.html#a_inteligencia_do_if_parte_2">A Inteligência do if: Parte 2</a></b>
<small><i>2007-06-29 blog assembly philosophy programming computer  Vimos na [primeira parte] desse artigo como o if revolucionou o mundo da computação ao trazer um salto que depende de condições anteriores e, portanto, depende do estado do programa. A ele chamamos de salto condicional. Também vimos como o resto das construções lógicas de uma linguagem são apenas derivações montadas a partir de saltos condicionais e incondicionais. Nesta segunda parte veremos como implementar um saldo condicional baseando-se no fato de que o computador pode apenas realizar operações matemáticas. Afinal de contas, um computador não "pensa".</small></i>
</td></tr>
<tr><td>
<b><a href="2007-06.html#disassembling_the_array_operator">Disassembling the array operator</a></b>
<small><i>2007-06-22 blog code english ccpp computer  Arrays are fascinating in C language because they are so simple and so powerful at the same time. When we start to really understand them and realize all its power we are very close to understand another awesome feature of the language: pointers.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-06.html#a_inteligencia_do_if_parte_1">A Inteligência do if: Parte 1</a></b>
<small><i>2007-06-18 blog assembly philosophy programming computer  No nível mais baixo, podemos dizer que as instruções de um computador se baseiam simplesmente em cálculos matemáticos e manipulação de memória. E entre os tipos de manipulação existe aquela que muda o endereço da próxima instrução que será executada. A essa manipulação damos o nome de salto.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-06.html#hello_world">O bom filho à casa retorna</a></b>
<small><i>2007-06-15 blog  Depois de seis meses blogueando em um novo domínio, que seria totalmente focado em C++, descobri que não consigo viver escrevendo apenas sobre a linguagem em que programo. Não é que falte assunto. Simplesmente meu dia-a-dia nunca se resume apenas em regras de sintaxe e erros de compilação.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/about_brand.png"/>
<b><a href="2007-06.html#about">About</a></b>
<small><i>2007-06-14 blog  metadata_single_post_mode 0 Quer entrar em contato? Mande o bom e velho [email]. Quer um [resumo profissional]? ![Eu mesmo!](about_author.jpg) Wanderley Caloni é um [programador] C/C++ especializado em backend para Windows que decidiu ter seu próprio blogue técnico a pedidos insistentes do seu amigo Rodrigo Strauss, que estava blogando já fazia alguns anos no www.1bit.com.br. Busquei mantê-lo atualizado por esses longos anos de programação, depuração e transpiração com minhas peripécias do dia-a-dia. Eventualmente me tornei crítico de cinema e juntei aqui essas duas escovas de dentes, textos técnicos e cinematográficos, o que acabou tornando o saite gigante a ponto de eu precisar trocar meu static site generator duas vezes. Hoje uso AWK. Sim, os clássicos acabam quebrando um galho =).</small></i>
</td></tr>
</table>
<span style="float: left;">
</span>
</div>
</div>
</section>
<footer class="footer">
<div class="container">
</div>
<div class="intentionally-blank"></div>
</footer>
</body>
</html>
