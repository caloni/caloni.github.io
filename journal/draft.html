<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Jornal do Caloni</title>
<meta name="author" content="Caloni" />
<meta name="generator" content="https://github.com/caloni/journal">
<meta property="og:title" content="Jornal do Caloni"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="http://www.caloni.com.br"/>
<meta property="og:image" content="/journal/img/about-brand.png"/>
<meta property="og:description" content="Write for computers, people and food."/>
<link href="/journal/index.xml" rel="feed" type="application/rss+xml" title="Jornal do Caloni"/>
<link rel="stylesheet" type="text/css" href="/journal/css/custom.css"/>
<link rel="stylesheet" type="text/css" href="/journal/css/jquery-ui.css"/>
<script src="/journal/js/jquery-1.12.4.js"></script>
<script src="/journal/js/jquery-ui.js"></script>
<script src="/journal/js/copy_clipboard.js"></script>
<script>
var quick_search_posts = [ 
 ]; 
</script>
<script src="/journal/js/quick_search.js"></script>
<script src="/journal/js/list.js"></script>
<link rel="icon" href="/journal/img/favicon.ico"/>
</head>
<body style="min-height:100vh;display:flex;flex-direction:column">
<nav class="navbar has-shadow is-white"
role="navigation" aria-label="main navigation">
<div class="container">
<div class="navbar-brand">
&nbsp;
<a class="navbar-item" href="index.html">
<div class="is-4"><b>Jornal do Caloni</b></div>
</a>
</div>
</div>
</nav>
<div class="container">
<div class="column">
<div style="min-height:56vh">
<div style="padding-bottom: 1em;"></div>
<input type="text" name="filter" value="" id="filter" placeholder="enter to select" style="width: 100%; font-size: 1.5rem; margin-top: 1em; margin-bottom: 0.5em;" title=""/></br>
<button id="filterbutton" style="font-size: 1rem;" onclick="ApplyFilter($('#filter').val());">select</button>
<button id="removebutton" style="font-size: 1rem;" onclick="ApplyNotFilter($('#filter').val());">remove</button>
<button id="randombutton" style="font-size: 1rem;" onclick="window.location = randomPost;">random</button>
<div><big><b><span style="visibility: hidden; padding: 5px;" name="results" id="results">...</span></b></big></div>
<table class="sortable" style="width: 100%;">
<tr><td>
<b><a href="2025-10.html#textos_de_ia_nao_tem_alma">Textos de IA não têm alma?</a></b>
<small><i>2025-10-23 writing essays draft  Reflexões do meu amigo Tsar: > Será que NPCs -- pessoas que não relatam ter um diálogo interno -- vão ter um índice de erro em adivinhar se um determinado texto é feito por IA muito maior que não-NPCs?</small></i>
</td></tr>
<tr><td>
<b><a href="2025-10.html#como_fazer_exercicios">Como fazer exercícios</a></b>
<small><i>2025-10-02 draft body  > > Knowing is not enough, you must apply; willing is not enough, you must do. > > If you always put limits on everything you do, physical or anything else, it will spread into your work and into your life. There are no limits. There are only plateaus, and you must not stay there, you must go beyond them.</small></i>
</td></tr>
<tr><td>
<b><a href="2023-09.html#traffic">TRAFFIC</a></b>
<small><i>2023-09-07 blogging draft reversing debugging computer  Observei esta anotação em meu journal de muitos anos atrás (2009) e ela continua atual. Baseado em um powerpoint do cientista da computação Andreas Zeller, autor de Why Programs Fail, este acrônimo é um caminho fácil de lembrar quando precisamos encontrar um bug no sistema. Eu lembro que estava pensando até em escrever um artigo na época, mas ainda estava trabalhando a questão de como traduzir as siglas para o português.</small></i>
</td></tr>
<tr><td>
<b><a href="2023-07.html#boasvindas_ao_canal_de_reversing_do_telegrama">Boas-vindas ao canal de Reversing do Telegrama</a></b>
<small><i>2023-07-21 blogging draft reversing computer  Olá, pessoas do Telegrão que entraram [no canal]. Bora começar a fazer baixarias pra ver se anima? Bom, acho que a primeira coisa que todo reversing de computador precisa fazer é gerar sua primeira telinha azul com uma poesia. Vamos lá?</small></i>
</td></tr>
<tr><td>
<b><a href="2023-04.html#easter_egg">Easter Egg</a></b>
<small><i>2023-04-28 draft computer  Mexendo em um projeto legado encontro encontro [esta pérola]. Será que ainda fazem essas coisas hoje em dia? Eu sabia que existia um neste programa porque o código deste aplicativo foi 100% feito por mim, desde o começo até passar das dez mil linhas de código. No entanto, eu me lembro que a primeira versão deste cheat era no formato de créditos de filme, com os nomes da equipe descendo. Isso estamos falando de 20 anos atrás. Não me lembrava que ele foi readaptado para nossa minúscula equipe nessa fase do projeto, o que me gerou um saudosismo gostoso ao ver esta imagem.</small></i>
</td></tr>
<tr><td>
<b><a href="2022-11.html#passagem_de_parametros_c_vs_c++">Passagem de Parâmetros C vs C++</a></b>
<small><i>2022-11-20 blogging draft ccpp computer  Em C não é necessário declarar os parâmetros que uma função recebe. Isso é implícito. A linguagem C foi criada para ser um amontoado de assembly descrito com um pouco de syntax sugar e juntado pelo linker através de uma tabela de nomes. O que importa são os nomes. Vamos exemplificar:</small></i>
</td></tr>
<tr><td>
<b><a href="2022-09.html#como_ler_na_internet">Como ler na internet</a></b>
<small><i>2022-09-26 blogging draft  Lembra daquela época que todos os sites tinham aqueles banners de propaganda piscante no começo e no fim de um texto, muitas vezes em algumas partes do meio? Bons tempos, não? Hoje ao navegar a esmo somos bombardeados com perguntas se queremos assinar o conteúdo, com vídeos pulando a todo momento, com chamadas para outro conteúdo misturado como se fizesse parte do texto, com imagens sem qualquer conexão com o que está sendo lido. E, por fim, com a fatídica e inevitável pergunta: você aceita cookies?</small></i>
</td></tr>
<tr><td>
<b><a href="2022-05.html#meditacao_e_self_debugging">Meditação é self debugging</a></b>
<small><i>2022-05-31 draft essays debugging computer  Depois que a tempestade na cabeça chega em um nível insuportável há uma calmaria, ou deveria haver, onde o corpo percebe que está vivo, que não existe no tempo e espaço. Existe apenas agora, e tão somente agora, pois o passado é uma máquina de estado mantida pelo cérebro, e o futuro a projeção extrapolada dessa máquina.</small></i>
</td></tr>
<tr><td>
<b><a href="2022-05.html#programando_bash_script">Programando bash script</a></b>
<small><i>2022-05-20 draft computer  Programar scripts em bash é basicamente rodar os comandos já disponíveis no modo shell a partir de um arquivo texto. Além das construções de qualquer linguagem procedural como if e laços de repetição o que é mais usado é o controle de entrada e saída dos comandos executados (e manipulação de file descriptors), além do controle sobre os signals durante as execuções.</small></i>
</td></tr>
<tr><td>
<b><a href="2021-05.html#como_ordenar_tres_numeros_em_uma_entrevista">Como Ordenar Três Números em Uma Entrevista</a></b>
<small><i>2021-05-13 draft computer  O primeiro exercício pedido ao candidato para a vaga de programação na [Intelitrader] é fazer uma função que receba três números e informe entre eles qual o maior, o menor e a média dos três. Sim, eu sei, absurdamente fácil, não? Porém, mesmo assim, a grande maioria dos "programadores" que entrevisto perde mais de meia-hora em um exercício simples desse. O motivo, acredito eu, é que a lógica de programação está cada vez mais em baixa. Pensar se tornou tristemente um requisito opcional em uma vaga de programação.</small></i>
</td></tr>
<tr><td>
<b><a href="2021-02.html#lessons_from_online_poker_exploit">Lessons From Online Poker Exploit</a></b>
<small><i>2021-02-26 draft computer  Em 2014 eu palestrei na trilha de segurança do TDC em São Paulo um tema que me deixou muito animado: um exploit baseado em falhas de programação em um código de 10 linhas. O código era tão simples que achei válido traduzir para C e demonstrar como atacar uma simulação de cassino online.</small></i>
</td></tr>
<tr><td>
<b><a href="2020-09.html#flow">Flow: The Psychology of Optimal Experience (Mihaly Csikszentmihalyi, 1990)</a></b>
<small><i>2020-09-27 draft flow self books  Este é um dos livros mais importantes que já li e acredito que pode ser muito importante para você também. Por isso quero dedicar algumas linhas para argumentar por que você deve lê-lo, ainda que ele seja denso demais para a maioria das pessoas.</small></i>
</td></tr>
<tr><td>
<b><a href="2020-06.html#leak_de_memoria">Leak de Memória</a></b>
<small><i>2020-06-07 draft essays computer  Esse fim de semana vi um programa, sem leak de memória, que só de ficar alocando e desalocando apresentava um consumo crescente no Process Explorer. Imaginando que poderia ser alguma lib externa, como o redis, fui eliminando uma por uma as variáveis do sistema, até chegar em um loop em que a única coisa feita no corpo do código era alocar e desalocar memória. E ela apenas subia.</small></i>
</td></tr>
<tr><td>
<b><a href="2020-06.html#awk">Awk</a></b>
<small><i>2020-06-07 draft computer  ## Introduction Meu amigo sugeriu que aprender awk poderia ser útil de várias maneiras. Uma delas para organizar finanças pessoais. Dei uma lida em alguns tutoriais, sendo que o melhor custo benefício foi o [Awk in 20 Minutes], de Fred Hebert (ele é o mesmo autor de um livro sobre erlang). Gostei. É sobre tratamento de texto como sed, mas em uma versão estendida e criada na época com a mesma sintaxe de C.</small></i>
</td></tr>
<tr><td>
<b><a href="2020-05.html#o_bug_mais_bizarro_que_ja_resolvi">O Bug Mais Bizarro que já Resolvi</a></b>
<small><i>2020-05-10 draft crypto reversing assembly flow debugging computer  Máquina IBM velha e empoeirada. Criptografia blowfish. Assembly 16 bits. Programa residente. E nenhum depurador funcionando. Tudo o que eu tinha se resumia em dois itens de inventário: o conhecimento, adquirido aos poucos do sistema, e minha imaginação. Era uma amena semana de abril em 2008 isolado em uma sala. Tudo que havia em volta eram papéis com anotações feitas. Observava uma nova pista todo dia, embora sem ter muita certeza. Àquela altura qualquer coisa serviria.</small></i>
</td></tr>
<tr><td>
<b><a href="2019-09.html#do_bit_para_o_codigo">Do Bit para o Código</a></b>
<small><i>2019-09-03 draft computer  Olá. Esta é uma viagem para dentro do computador. Como funciona um computador? Você sabe? Pois é, nem eu. Mas vamos explorar alguns pontos onde nossa vã metafísica mal encosta na singularidade que é uma arquitetura Von Neumann.</small></i>
</td></tr>
<tr><td>
<b><a href="2019-05.html#c_resolve_tudo_goto">C Resolve Tudo: goto</a></b>
<small><i>2019-05-28 draft computer  Para quem decide usar a linguagem C para resolver tudo, a gota da água é o goto. Ele é flexível, cabe em (quase) qualquer ponto do código e tem 1001 utilidades. O goto é o bombril da engenharia de software.</small></i>
</td></tr>
<tr><td>
<b><a href="2019-05.html#c_resolve_tudo_orientacao_a_objetos_com_polimorfismo">C Resolve Tudo: Orientação a Objetos (com Polimorfismo)</a></b>
<small><i>2019-05-17 draft computer  Como programadores há um vício em nossas cabeças que é estar constantemente buscando a bala de prata, ou seja, a solução final e única para todos os nossos problemas de implementação. Com o tempo e alguma experiência descobrimos que tal coisa não existe, mas até lá nos encantamos com esse ou aquele framework, e claro, com essa ou aquela linguagem.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/bug_boost_asio_acceptex_winsock_FUrSKg2.png"/>
<b><a href="2019-01.html#bug_no_boost_asio_usando_funcao_acceptex_do_winsock">Bug no Boost Asio usando função AcceptEx do Winsock</a></b>
<small><i>2019-01-06 draft computer  Depois de um mês de correção e mais um ou dois meses preparando um compilado do que ocorreu no software que estamos mantendo, foi descoberta uma situação muito peculiar que ocorre tanto em Windows XP quanto no Windows 10, mas que no 10 tem uma correção bem-educada e no XP... bom, nem tanto.</small></i>
</td></tr>
<tr><td>
<b><a href="2018-04.html#lista_ligada_ta_ligado">Lista Ligada; tá Ligado?</a></b>
<small><i>2018-04-24 draft lists computer  Uma lista ligada é uma lista de alguma coisa onde os elementos se ligam um no outro, ou seja, um elemento tem a referência do próximo. O tipo dos elementos de uma lista ligada pode ser inteiros, strings ou estruturas inteiras. Independente do que for, você vai precisar de uma estrutura. Sabe por quê? Porque existe além dos dados em si mais uma informação que você precisará guardar em cada elemento de sua lista: o próximo elemento. E é daí que surge a ligação da lista ligada.</small></i>
</td></tr>
<tr><td>
<b><a href="2018-03.html#contra_o_array_de_100_bytes_e_suficiente">Contra o 'Array de 100 bytes é suficiente'</a></b>
<small><i>2018-03-11 draft computer  Desde o C++ moderno (pós-03) o uso de arrays de tamanho fixo estão se tornando depreciados. E por um bom motivo: você nunca sabe realmente qual o tamanho que você precisa para um array de bytes até você saber. Daí a próxima grande questão é: "como gerenciar essa memória dinâmica de forma efetiva?". E a resposta moderna sempre é: "não faça isso você mesmo". Eis o porquê:</small></i>
</td></tr>
<tr><td>
<b><a href="2018-02.html#variaveis_static_local_nunca_sao_inicializadas_se_voce_nao_chama_sua_funcao">Variáveis static local Nunca São Inicializadas Se Você Não Chama Sua Função</a></b>
<small><i>2018-02-20 draft computer  Uma dúvida muito comum dos programadores iniciantes em C/C++ diz respeito às variáveis static que são declaradas dentro de um escopo, como uma função. Sabemos que se ela fosse declarada global, fora de qualquer escopo, ela seria inicializada antes do main ser chamado, como diz este trecho de alguém que pesquisou a respeito:</small></i>
</td></tr>
<tr><td>
<b><a href="2016-08.html#depurando_codigo_c++_no_visual_studio">Depurando código C++ no Visual Studio</a></b>
<small><i>2016-08-12 blogging draft videos computer  Olá de novo. Este é o segundo vídeo da série "o que que eu tô fazendo no YouTube?". Dessa vez abri o Visual Studio para depurar um código de 10 linhas com um bug absurdamente absurdo, mas que pode enganar muita gente. Há quem acredite que esse bug foi proposital, mas não foi. O importante é que ficou muito legal. Vamos ver?</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/templates_em_c_no_lugar_de_macros_865mgsu.jpg"/>
<b><a href="2016-01.html#templates_em_c_no_lugar_de_macros">Templates em C no lugar de macros</a></b>
<small><i>2016-01-14 draft computer  A grande vantagem dos templates é manter o tipo de seus argumentos. Infelizmente, eles não existem na linguagem C, mas podem ser usados em construções C feitas com a linguagem C++, como ocorre com quem desenvolve device drivers para Windows.</small></i>
</td></tr>
<tr><td>
<b><a href="2015-05.html#analisando_erros_pelo_filtro_do_file_monitor">Analisando Erros Pelo Filtro do File Monitor</a></b>
<small><i>2015-05-06 draft computer  As ferramentas da SysInternals fazem a gente economizar um tempo considerável na resolução de problemas. Não que elas sejam indispensáveis. Tudo que elas fazem é encurtar o caminho entre a análise de um bug e sua resolução, o que acaba sendo muito se considerarmos que programação é 20% codificação e 80% transpiração. Ela é um atalho para muitas coisas, desde achar uma ordem errada de includes no header durante a compilação ou descobrir que por que um processo morreu durante o login.</small></i>
</td></tr>
<tr><td>
<b><a href="2015-04.html#convencao_de_chamada">Convenção de Chamada</a></b>
<small><i>2015-04-20 draft computer  Pergunta de um leitor: #### Leitor: Olhe essa bizarrice em C: void func() { } int main() {    func("sbrubles");    return 0; } #### Leitor: Embora isso seja permitido, caso você coloque "void func(void)" já não funciona mais. Por quê?</small></i>
</td></tr>
<tr><td>
<b><a href="2015-01.html#origem_do_tipo_char">Origem do Tipo char</a></b>
<small><i>2015-01-26 draft ccpp computer  Programadores C e C++, preparem-se para explodir as cabeças! No princípio... não, não. Antes do princípio, quando C era considerada a terceira letra do alfabeto e o que tínhamos eram linguagens experimentais para todos os lados, dois famigerados srs. dos Laboratórios Bell, K. Thompson e [D. Ritchie], criaram uma linguagem chamada B. E B era bom.</small></i>
</td></tr>
<tr><td>
<b><a href="2014-09.html#shareando_ponteiros">Shareando Ponteiros</a></b>
<small><i>2014-09-03 draft computer  Apesar de já ter palestrado algumas vezes sobre Boost e STL, acho que eu nunca escrevi muito sobre esses assuntos no blogue. Acho que o tamanho dessas bibliotecas assusta um pouco. Mas temos que começar de algum lugar, certo? E já que é pra começar, eu gostaria muito de saber de você, programador miserável, que passou poucas e boas nesses 10 anos de padrão 98 brincando com templates quando eles ainda estavam em beta: se fosse para melhorar um aspecto da sua vida de código, qual seria? Qual é aquela coisa que te atormenta como insetos vidrados no seu monitor noite adentro?</small></i>
</td></tr>
<tr><td>
<b><a href="2014-07.html#introducao_a_introducao_a_computacao">Introdução à Introdução à Computação</a></b>
<small><i>2014-07-01 draft computer books  O livro começa lá nos primórdios da informação, antes mesmo da humanidade. Sim, pois informação não necessita sequer de um ser sensciente para ser transmitida e utilizada, como já foi comprovado através de nosso código genético, o agora-popular-por-causa-do-ratinho DNA. Uma informação codificada intrinsecamente no processo de reprodução das células de um ser vivo. Um computador orgânico!</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/se_iterando_com_os_pseudo_ponteiros_uma_breve_introducao_GmNutkz.jpg"/>
<b><a href="2014-06.html#se_iterando_com_os_pseudo_ponteiros_uma_breve_introducao">Se iterando com os pseudo-ponteiros: uma breve introdução</a></b>
<small><i>2014-06-24 draft computer  Como [já vimos algumas vezes], a STL não prima por interfaces intuitivas, preferindo abstrações que criem um leque de ferramentas genéricas para tratamento uniformizado de coleções de dados através de algoritmos. O problema disso é que novos programadores da linguagem terão que aprender uma maneira nova de lidar com problemas baseada na percepção dos criadores do padrão na época em que foi lançado de como seria a evolução da ciência da computação nos próximos anos. Muitos dos conceitos ali abordados realmente se tornaram padrão _de facto_, mas na briga pela expansão da linguagem quem perdeu por muito tempo foi o próprio desenvolvedor, que teve que se contentar com uma lista de algoritmos genéricos parcialmente compilado.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/estruturas_vs_classes_fight_np4trf9.jpg"/>
<b><a href="2014-05.html#estruturas_vs_classes_fight">Estruturas VS Classes: fight!</a></b>
<small><i>2014-05-20 draft computer  Uma dúvida besta e importante ao mesmo tempo que muitos iniciantes em C++ possuem é saber qual a diferença entre um objeto declarado como _class_ e um objeto declarado como _struct_. A causa dessa dúvida é uma linguagem que se derivou de outra (C) que não possuía classes, e portanto criou a palavra-chave _class_ para "ficar bonito", pois, na prática, não muda muita coisa. Tomemos como exemplo o código mais simples de todos:</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/lambda_o_retorno_Hrbu1ue.jpg"/>
<b><a href="2014-04.html#lambda_o_retorno">Lambda: o Retorno!</a></b>
<small><i>2014-04-08 draft computer  Na última vez que foi abordado o tema "lambda na ferida" falamos brevemente sobre como C++ agora permite criar funções dentro de funções. Hoje vamos apenas falar que aquela construção bizarra que criamos fica ainda mais bizarra se precisarmos retornar alguma coisa dessa função ou usá-la mais de uma vez.</small></i>
</td></tr>
<tr><td>
<b><a href="2014-03.html#a_moda_agora_e_levar_lambda_na_funcao">A moda agora é levar lambda na função</a></b>
<small><i>2014-03-28 draft ccpp computer  A nova moda de programar C++ nos últimos anos com certeza é usar lambda. Mas, afinal, o que é lambda? Bom, pra começar, é um nome muito feio. O que esse nome quer dizer basicamente é que agora é possível criar função dentro de função. Não só isso, mas passar funções inteiras, com protótipo, corpo e retorno, como parâmetro de função.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/remove_if_ate_remove_so_que_diferente_Q7f2N1G.png"/>
<b><a href="2014-01.html#remove_if_ate_remove_so_que_diferente">remove_if até remove, só que diferente</a></b>
<small><i>2014-01-21 draft computer  A surpresa de hoje foi descobrir (vejam só) que o remove_if, como todo algoritmo da STL, deve ser olhado de perto antes de usado. Nesse caso em específico porque, apesar do nome, a função NÃO remove elementos, mas os sobrescreve.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/ponto_flutuante_afundando_mqHh0wA.png"/>
<b><a href="2013-11.html#ponto_flutuante_afundando">Ponto Flutuante Afundando</a></b>
<small><i>2013-11-07 draft computer  Quando armazenamos valores monetários em doubles seus cálculos conseguem manter a precisão e na maioria das vezes o ajuste de precisão funciona. Porém, encontrei alguns casos onde a subtração de dois valores fazia "perder" um centavo (ou comparações exatas) justamente pela limitação da precisão do ponto flutuante. Nesse exemplo os valores são 2.358,93 - 1.386,93, que em uma conta de padaria (mas correta) dá 972,00 ([até a Calc do Windows] e [o Excel] funcionam), mas pelo Visual Studio 2010 chega perto, mas erra o alvo:</small></i>
</td></tr>
<tr><td>
<b><a href="2012-05.html#sobrecarga_de_funcao_as_avessas">Sobrecarga de função às avessas</a></b>
<small><i>2012-05-20 draft ccpp computer  > Nota do autor: navegando pelo Archive.org, que possibilita viajar no tempo e encontrar coisas enterradas que seria melhor deixar por lá, consegui encontrar um post que se perdeu na dobra espaço-temporal entre o old-fashioned Caloni.com.br (com direito à velha joaninha psicodélica, desenho do meu amigo que uso até hoje no blogue) e um finado outro domínio meu, o CThings. No final, consegui matar a marmota, chegar a [80 milhas por hora] e voltar para o presente. Enjoy!</small></i>
</td></tr>
<tr><td>
<b><a href="2012-01.html#rvalue_e_o_novo_lvalue">RValue é o novo LValue</a></b>
<small><i>2012-01-11 draft ccppbr computer  As grandes discussões filosóficas que participei durante meu estudo da linguagem C, e mais tarde de C++, muitas vezes convergiam para o significado místico daquela figura que nós da gramática da linguagem conhecemos como lvalue, ou l-value, ou left-value. Enfim, a definição de uma expressão que representa um lugar na memória e, portanto, pode ocupar o lado esquerdo de uma atribuição/cópia/passagem de argumentos qualquer. Porém, os "grandes" embates daquela época hoje parecem brincadeira de criança, como a diferença sutil entre ++x e x++ ou convergência de tipos em templates.</small></i>
</td></tr>
<tr><td>
<b><a href="2011-05.html#comparando_strings_no_windbg">Comparando strings no WinDbg</a></b>
<small><i>2011-05-22 draft computer  O WinDbg fornece aos programadores diversos meios (muitos redundantes) de comparar valores inteiros em quaquer lugar da memória, em qualquer tamanho (8, 16, 32, 64 bits). Porém, quando precisamos comparar strings, que todos sabem ser uma sequência de bytes de tamanho arbitrário (se for em C, até o zero terminador).</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/vtable_vtable2.png"/>
<b><a href="2011-03.html#vtable">VTable</a></b>
<small><i>2011-03-01 draft computer  Acho que na breve história desse blogue nunca contei a história do vtable. No máximo fizemos um [hookzinho nos métodos de um componente COM]. Mas só. Não encontro uma analogia simples, assim, de cabeça. Então vou contar no cru, mesmo. Talvez seja até mais divertido.</small></i>
</td></tr>
<tr><td>
<b><a href="2010-11.html#patch_de_emergencia_2">Patch de emergência 2</a></b>
<small><i>2010-11-09 draft computer  No [artigo anterior] fizemos um patch rapidinho na memória se aproveitando de um Sleep nojento que o código nos forneceu. E se não houvesse Sleep? As chances de estarmos escrevendo no momento em que a função está sendo executada são tremendas, de forma que não poderíamos sobrescrevê-la sem correr o risco de um crash.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/patch_de_emergencia_bMI63Ka.png"/>
<b><a href="2010-11.html#patch_de_emergencia">Patch de emergência</a></b>
<small><i>2010-11-08 draft computer  Após um projeto muito bem sucedido, entregue no prazo e homologado em tempo recorde, você e sua equipe estão aproveitando suas devidas férias nas Bahamas, tomando água de coco na sombra de uma palmeira e apreciando a beleza natural da região. Ambas as belezas. =)</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/como_achar_o_codigo_fonte_sem_simbolos_gUfPM5Q.jpg"/>
<b><a href="2010-08.html#como_achar_o_codigofonte_sem_simbolos">Como achar o código-fonte sem símbolos</a></b>
<small><i>2010-08-03 draft computer  Continuo escovando bits. Dessa vez de forma mais nervosa. Se trata de um serviço que trava durante seu stop. Um colega muito esperto do suporte gerou um dump para mim, tornando as coisas mais fáceis. O problema era que não havia símbolos nem código-fonte que batessem exatamente com aquela compilação de 2004. Solução? Analisar as pilhas das threads restantes.</small></i>
</td></tr>
<tr><td>
<b><a href="2010-05.html#modificadores_e_qualificadores_de_tipo">Modificadores e qualificadores de tipo</a></b>
<small><i>2010-05-28 draft computer  "@caloni poderia pensar em fazer um artigo sobre os modificadores de tipo em c? os mais complexo, acho eu: volatile, enum, union, extern, etc" Uma coisa de cada vez: existem **modificadores** (ou qualificadores) de tipo e **especificadores** de tipo. _Volatile_ e _extern_ se encaixam na primeira categoria, _enum_ e _union_ na segunda. Veremos um pouco desses dois lados da linguagem em doses paliativas.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/por_que_long_pointer_getting_lost_on_streets.png"/>
<b><a href="2010-04.html#por_que_long_pointer">Por que Long Pointer</a></b>
<small><i>2010-04-21 draft computer  Esse artigo continua a explicação sobre [os typedefs arcaicos], já que ainda falta explicar por que diabos os ponteiros da Microsoft começam com LP. Tentei explicar para [minha pupila] que, por ser código dos anos 80, as pessoas usavam LP para tudo, pois os CDs ainda não estavam tão difundidos.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/typedef_arcaico_gFNalqB.png"/>
<b><a href="2010-04.html#typedef_arcaico">Typedef arcaico</a></b>
<small><i>2010-04-20 draft computer  A [API do Windows] geralmente prima pela excelência em maus exemplos. A [Notação Húngara] e o Typedef Arcaico são duas técnicas que, por motivos históricos, são usados a torto e a direito pelos códigos de exemplo.</small></i>
</td></tr>
<tr><td>
<b><a href="2010-04.html#antigo_bemvindo_do_cine_tenis_verde">Antigo bem-vindo do Cine Tênis Verde</a></b>
<small><i>2010-04-01 draft cinema  > Atualização (2026-01-24): a partir da data original deste artigo comecei a escrever sobre cinema em um domínio próprio, que nos anos recentes acabou se juntando ao meu blogue técnico em uma massa de milhares de textos. Assim como estou fazendo a curadoria dos textos técnicos, muito menos dos mais de 1300 e lá vai cacetada textos das críticas que fiz estarão aqui no blogue. Irei poupá-los desta poluição nessa versão mais enxuta. O texto abaixo está disponível como um aviso de mudança de fase do autor que vos escreve.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/importando_tipos_de_outros_projetos_l4oLJHR.png"/>
<b><a href="2010-01.html#importando_tipos_de_outros_projetos">Importando tipos de outros projetos</a></b>
<small><i>2010-01-11 draft computer  A engenharia reversa das entranhas do kernel não tem limites se você sabe o que está fazendo. No entanto, algumas facilidades do depurador podem ajudar a minimizar o tempo que gastamos para analisar uma simples estrutura. Por exemplo, o [Process Environment Block] de um processo específico.</small></i>
</td></tr>
<tr><td>
<b><a href="2009-12.html#o_boot_no_windows_kernel">O boot no Windows: Kernel</a></b>
<small><i>2009-12-04 draft computer  Finalmente chegamos em um ponto onde podemos usar o WinDbg. Podemos espetar o depurador e fazê-lo parar assim que conectado. Se estiver rodando antes do próprio sistema operacional, teremos um sistema sem processos e sem threads, pois ele irá parar assim que o executivo puder enviar o sinal de início pela porta serial, após carregar na memória os módulos básicos.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/o_boot_no_windows_ntldr_2ewkFhs.png"/>
<b><a href="2009-11.html#o_boot_no_windows_ntldr">O boot no Windows: NTLDR</a></b>
<small><i>2009-11-26 draft computer  Minhas análises estão demorando muito para ser feitas. Talvez seja a hora de revelar o pouco que sei (e pesquisei) sobre o próximo processo de boot do Windows: o NTLDR. ![Galinha Preta](o_boot_no_windows_ntldr_galinha_preta.jpg)</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/o_boot_no_windows_pre_ntldr_7dZZZag.png"/>
<b><a href="2009-09.html#o_boot_no_windows_prentldr">O boot no Windows: pré-NTLDR</a></b>
<small><i>2009-09-09 draft computer  Conforme fui estudando para recordar os momentos sublimes do boot do Windows me deparei com o artigo mais "espetaculoso" de todos os tempos sobre esse assunto, parte integrante do livro [Windows Internals] e escrito pelo nada mais nada menos Mark Russinovich: **Boot Process**, no capítulo 5, "Startup and Shutdown".</small></i>
</td></tr>
<tr><td>
<b><a href="2009-08.html#o_boot_no_windows_sem_windows">O boot no Windows: sem Windows</a></b>
<small><i>2009-08-18 draft computer  Desde quando o usuário liga o computador até o momento em que ele vê a barra de tarefas e aqueles fundos lindos de papel de parede existem diversas coisas sendo feitas por debaixo do pano. Essa série de artigos irá explicar essas diversas coisas, ou seja, como funciona e quais as fases do boot de uma máquina que possui Windows instalado (plataforma NT).</small></i>
</td></tr>
<tr><td>
<b><a href="2009-07.html#static_polymorphism">Static Polymorphism</a></b>
<small><i>2009-07-10 draft english computer  To explain the polymorphism nothing is better than see how stuff used to be. If you were a twenty old C programmer in the past and created the following functions: int soma(int x, int y); double soma(double x, double y);</small></i>
</td></tr>
<tr><td>
<b><a href="2009-07.html#polimorfismo_estatico">Polimorfismo estático</a></b>
<small><i>2009-07-10 draft computer  Para explicar polimorfismo, nada como ver as coisas como elas eram. Se você fosse um programador C de vinte anos atrás e criasse as seguintes funções: int soma(int x, int y); double soma(double x, double y);</small></i>
</td></tr>
<tr><td>
<b><a href="2009-06.html#programadores_de_verdade_nao_usam_java">Programadores de verdade não usam Java</a></b>
<small><i>2009-06-18 blogging draft essays  Quando era um newbie (e um wanna-be) gostava de ler o "Real Programmers Don't Use Pascal", um texto humorístico que mais me influenciou e encorajou a caminho da iluminação C/C++ do que o livro de K&R. A partir dele, supunha eu, ser um "programador de verdade" era ser tudo. Ser um Quiche Eater (Comedor de Torta) não era nada. Programadores de verdade é que resolvem os problemas de verdade! Quiche Eaters são os losers que estudam os conceitos acadêmicos da ciência da computação e nunca fazem um maldito programa que preste (conhece alguém assim?).</small></i>
</td></tr>
<tr><td>
<b><a href="2009-06.html#bugs_dificeis_de_achar">Bugs Difíceis de Achar</a></b>
<small><i>2009-06-18 draft computer  Saiu um artigo na Wired News sobre [os piores bugs da história]. Entre eles estão a explosão de um oleoduto soviético em plena guerra-fria (como se não bastasse chernobyl), o primeiro worm da Internet (que se aproveita de um buffer overflow da função gets) e o famoso erro de divisão em ponto flutuante do Pentium; um erro de cálculo de cerca de 0,006% que causou um prejuízo de 457 milhões de dólares para a Intel.</small></i>
</td></tr>
<tr><td>
<b><a href="2009-04.html#a_sala_da_fila_das_threads">A sala da fila das threads</a></b>
<small><i>2009-04-17 draft computer  Quando falei sobre [a fila das threads], e como cada thread espera pacientemente em uma fila até chegar sua vez de ser atendida no guichê das CPUs, também vimos como é fácil fazer caquinhas em um programa que roda paralelamente duas threads ou mais.</small></i>
</td></tr>
<tr><td>
<b><a href="2009-04.html#a_fila_das_threads">A fila das threads</a></b>
<small><i>2009-04-07 draft computer  Em um ambiente multithreading diversas threads disputam "a tapas" a atenção do processador (CPU). Certo? Podemos dizer que, em um ambiente com muito processamento a realizar, de certa forma é isso que acontece. São threads e mais threads rodando um pedacinho de código cada vez que passam pelo processador.</small></i>
</td></tr>
<tr><td>
<b><a href="2009-03.html#provas_de_conceito_yes">Provas de conceito... yes</a></b>
<small><i>2009-03-19 draft essays  Uma prova de conceito bem feita segue todos os passos em uma forma micro para entender e provar como as coisas irão funcionar no código de produção: a forma macro. A consequência interessante disso é que, uma vez que a prova de conceito deva ser um miniprojeto das principais partes de um software, desenvolvê-la significa programar todas as partes que realmente importam, ou seja, centrais para o funcionamento.</small></i>
</td></tr>
<tr><td>
<b><a href="2009-03.html#os_problemas_mais_cabeludos">Os problemas mais cabeludos</a></b>
<small><i>2009-03-05 draft essays  Quase todos os problemas do Universo são resolvidos depois de um belo dia de depuração, código comentado, descomentado, recomentado e umas muitas e boas doses de café. Alguns outros problemas mais cabeludos precisam de uma boa noitada na frente do computador, e mais café. E, finalmente, existem aqueles que nem tomando o estoque inteiro de café a coisa anda.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/basico_do_basico_assembly_wZ6kKs8.jpg"/>
<b><a href="2009-01.html#basico_do_basico_assembly">Básico do básico: assembly</a></b>
<small><i>2009-01-26 draft computer  É lógico que não poderia faltar no cinto de utilidades de todo bom programador C conhecimentos **básicos** da linguagem assembly, sua mãe espiritual. São tantos conceitos em comum que, uma vez aprendido seu funcionamento, fica difícil não pensar no código-assembly gerado pelo compilador C. E é nesse ponto que as coisas começam a ficar mais claras.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/basico_do_basico_binario_jQTGnH6.gif"/>
<b><a href="2008-12.html#basico_do_basico_binario">Básico do básico: binário</a></b>
<small><i>2008-12-18 draft computer  Apesar do tema binário, o assunto de hoje no fundo remete-nos a todo e qualquer tipo de **representação**. É o faz-de-conta um pouco mais intenso, vindo das profundezas da matemática e dominado com maestria pela nossa mente e sua capacidade lógica de abstrair.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/basico_do_basico_tipos_interpretacao_de_memoria_texto_e_numeros.png"/>
<b><a href="2008-12.html#basico_do_basico_tipos">Básico do básico: tipos</a></b>
<small><i>2008-12-12 draft computer  Um tipo nada mais é que do que uma forma (ô) de bolo, que **molda a memória** como acharmos melhor moldá-la. Bom, para isso fazer sentido é necessário explicar memória, que é um conceito **mais básico ainda**.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/basico_do_basico_ponteiros_draft_pointers_strings_arrays.jpg"/>
<b><a href="2008-12.html#basico_do_basico_ponteiros">Básico do básico: ponteiros</a></b>
<small><i>2008-12-06 draft computer  Nessas últimas semanas tenho gastado meu tempo junto da mais nova pupila da SCUA, aspirante a programadora em C e Install Shield Script. Minha tarefa? Explicar tudo, desde o mais simples, como **variáveis**, até as coisas não tão triviais, como **símbolos de depuração**.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/como_funciona_o_psexec_vBGHXoC.png"/>
<b><a href="2008-10.html#como_funciona_o_psexec">Como funciona o PsExec</a></b>
<small><i>2008-10-29 draft computer  Semana passada precisei reproduzir o comportamento da ferramenta PsExec em um projeto, o que me fez sentir alguma nostalgia dos tempos em que eu fazia [engenharia reversa] todo dia. Este breve relato (espero) reproduz os passos que segui para descobrir o que esse programa tão útil quanto perigoso faz.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-10.html#a_alca_dentro_do_fio_gerou_um_bloqueio_da_morte">A Alça Dentro do Fio Gerou um Bloqueio da Morte</a></b>
<small><i>2008-10-21 draft essays  Estava folheando um livro fenomenal que meu amigo havia pedido emprestado para ler quando me deparei com algumas traduções no mínimo curiosas. O exemplar em questão era o primeiro Windows Internals, publicado após o lançamento da primeira versão do Windows NT, uma plataforma escrita (quase) inteiramente do zero para suplantar as versões 9x (Windows 95 e 98), que herdaram do DOS algumas partes indesejáveis em sistemas operacionais modernos.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/windows_jobs_com_completion_port_job.gif"/>
<b><a href="2008-09.html#windows_jobs_com_completion_port">Windows Jobs com Completion Port</a></b>
<small><i>2008-09-23 draft computer  Ou "Como esperar o término de todos os processos-filho criados a partir de um conjunto de processos". Dessa vez confesso que esperava um pouco mais de documentação do MSDN, ou pelo menos um sistema de referências cruzadas eficiente. Outro dia demorei cerca de duas horas para conseguir [criar um _**job**_], anexar o processo desejado e, a pior parte, esperar que todos os processos (o principal e seus filhos e netos) terminassem.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-09.html#todo_programador_e_um_filosofo_em_potencial">Todo programador é um filósofo em potencial</a></b>
<small><i>2008-09-12 draft essays  Tivemos uma conversa muito frutífera hoje durante o almoço ao conhecer uma professora que sentava ao nosso lado, exímia conhecedora da mente humana e amante das artes nobres como a filosofia e a lógica. O importante dessa colóquio foi ter encontrado um motivo muito mais forte para gostar de programação do que qualquer outro que já me surgira na cabeça desde que mexo com essas coisas: O computador não deve dar ordens ao homem e este repeti-las como uma máquina. O homem, como ser pensante, deve dizer ao computador o que fazer, e este responder-lhe diligentemente.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-08.html#processleaker">ProcessLeaker</a></b>
<small><i>2008-08-21 draft computer  O artigo anterior mostrava como detectar o leak de um processo gerado pela retenção e não-liberação de handles para o Windows Explorer. O problema fora causado por um serviço malcriado. No entanto, a título de demonstração, criei um pequeno programinha sem-vergonha para fazer as coisas parecerem difíceis. No entanto o programa é bem fácil:</small></i>
</td></tr>
<tr><td>
<b><a href="2008-08.html#os_processosfantasma">Os processos-fantasma</a></b>
<small><i>2008-08-20 draft computer  Estava eu outro belo dia tentando achar um problema em um driver que controla criação de processos quando, por acaso, listo os processos na máquina pelo depurador de kernel, após ter dado alguns logons e logoffs, quando me vem a seguinte lista de processos do Windows Explorer:</small></i>
</td></tr>
<tr><td>
<b><a href="2008-08.html#quando_o_navegador_nao_quer_largar_um_arquivo">Quando o navegador não quer largar um arquivo</a></b>
<small><i>2008-08-13 draft  De vez em quando gosto muito de um vídeo que estou assistindo. Gosto tanto que faço questão de guardar para assistir mais vezes depois. O problema é que o meu Firefox ou, para ser mais técnico, o plugin de vídeo que roda em cima do meu navegador, não permite isso. Ele simplesmente cria um arquivo temporário para exibir o vídeo e logo depois o apaga, utilizando uma técnica muito útil da função CreateFile, que bloqueia o acesso do arquivo temporário e apaga-o logo após o uso:</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/antidebugging_during_the_process_attach_espertinho.png"/>
<b><a href="2008-08.html#antidebugging_during_the_process_attach">Antidebugging during the process attach</a></b>
<small><i>2008-08-05 draft antidebug english projects computer  Today was a great day for reverse engineering and protection analysis. I've found two great programs to to these things: a API call monitor (update: does not exist anymore) and a COM call monitor (update: either). Besides that, in the first program site - from a enthusiastic of the good for all Win32 Assembly - I've found the source code for one more antidebugging technique, what bring us back to our series of antidebugging techniques.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/antidebugging_using_the_debugport_debug_port2.gif"/>
<b><a href="2008-08.html#antidebugging_using_the_debugport">Antidebugging using the DebugPort</a></b>
<small><i>2008-08-01 draft antidebug english projects computer  When a debugger starts a process to be debugged or, the article case, connects to a already created process, the communication between these processes is made through an internal resource inside Windows called LPC (Local Procedure Call). The system creates a "magic" communication port for debugging and the debugging events pass throw it.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-07.html#antidebugging_using_exceptions_part_two">Antidebugging using exceptions (part two)</a></b>
<small><i>2008-07-30 draft antidebug english projects computer  In the first article we saw how it's possible to spoof the debugger through exceptions and let the attacker lose some considerable time trying to unbind the program from the fake breakpoints. However, we saw also that this is a difficult solution to keep in the source code, besides its main weakness to be easily bypassed if discovered. Now it's time to put things easier to support and at the same time to guarantee tough times even if the attacker discover what is going on.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-07.html#antidebugging_using_exceptions_part_one">Antidebugging using exceptions (part one)</a></b>
<small><i>2008-07-28 draft antidebug english projects computer  A debugger puts breakpoints to stop for a moment the debuggee execution. In order to do this it makes use of a well known instruction: int 3. This instruction throws an exception - the breakpoint exception - that is caught by the operating system and bypassed to the handling code for this exception. For debuggee processes this code is inside the debugger. For free processes this code normally doesn't exist and the application simply crashs.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-07.html#entrevista_com_o_caloni_no_do_zero_ao_mestre">Entrevista com o Caloni no 'Do ZERO ao MESTRE'</a></b>
<small><i>2008-07-24 draft  Há muito pouco tempo atrás surgiu um blogue de um programador com o desejo de aprender C++ em seis meses. Ele entrou em contato comigo para divulgar seu trabalho, e lhe disse que na internet seu trabalho se divulga por si só. E é verdade. No entanto, não contente, ele me pediu para responder um questionário no estilo entrevista. Não sei se o resultado foi satisfatório, mas pelo menos foi curioso. Foram perguntas simples e respostas mais simples ainda.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-07.html#o_conhecido_unresolved_external">O conhecido unresolved external</a></b>
<small><i>2008-07-18 draft computer  O artigo anterior mostrou que nem sempre as coisas são simples de resolver, mas que sempre existe um caminho a seguir e que, eventualmente, todos os problemas se solucionarão. Porém, resolver um problema por si só não basta: é preciso rapidez. E como conseguimos rapidez para resolver problemas? Um jeito que eu, meu cérebro e o Dmitry Vostokov conhecem é montando padrões.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/o_caso_da_funcao_de_delay_load_desaparecida_delayimpprocmon.png"/>
<b><a href="2008-07.html#o_caso_da_funcao_de_delay_load_desaparecida">O caso da função de Delay Load desaparecida</a></b>
<small><i>2008-07-16 draft computer  Todos os projetos do Visual Studio 6 estavam compilando normalmente com a nova modificação do código-fonte, uma singela chamada a uma função da DLL iphlpapi.dll. No entanto, ainda restava a compilação para Windows 95, um legado que não era permitido esquecer devido ao parque antigo de máquinas e sistemas operacionais de nossos clientes.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-06.html#reflexao_em_c">Reflexão em C++</a></b>
<small><i>2008-06-30 draft computer  O termo e conceito de reflection, muito usado em linguagens modernas, é a capacidade de um programa de observar e até de alterar sua própria estrutura. Bom, isso você pode ler na Wikipédia. O interessante é o que podemos usar desse conceito na linguagem C++.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-06.html#e_possivel_carregar_duas_dlls_gemeas_no_mesmo_processo">É possível carregar duas DLLs gêmeas no mesmo processo?</a></b>
<small><i>2008-06-21 draft computer  Um [dos últimos artigos] de Dmitry Vostokov, e tenho que falar assim porque o cara escreve muito em pouco tempo, fala sobre os perigos de termos uma mesma DLL carregada duas vezes em um único processo, muitas vezes em versões diferentes. Para os observadores atentos como Dmitry esse é um perigo que muitas vezes temos que estar preparados. Para os espertinhos de plantão, a resposta padrão seria: "não vou me preocupar, porque o contador de instâncias cuida disso".</small></i>
</td></tr>
<tr><td>
<b><a href="2008-06.html#alinhamento_de_memoria_portavel">Alinhamento de Memória Portável</a></b>
<small><i>2008-06-18 draft computer  Como vimos durante o seminário CCPP, o alinhamento de memória pode ser problemático durante momentos críticos, como migração de plataforma (16 para 32 bits) e de ambiente (compilador novo). A forma como a memória é alinhada influi diretamente em algoritmos de criptografia ou de rede, para citar dois exemplos bem comuns, fazendo com que o que funcionava antes não funcione mais sem mexer uma única linha de código. Eu já vi isso. E isso não é bom.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/declaracao_x_definicao_cdepends.gif"/>
<b><a href="2008-06.html#declaracao_x_definicao">Declaração x definição</a></b>
<small><i>2008-06-06 draft computer  Uma diferença que eu considero crucial na linguagem C/C++ é a questão da declaração/definição (em inglês, declaration/definition). É a diferença entre esses dois conceitos que permite, por exemplo, que sejam criadas estruturas prontas para serem conectadas a listas ligadas:</small></i>
</td></tr>
<tr><td>
<b><a href="2008-05.html#aquele_do_while_engracado">Aquele do-while engraçado</a></b>
<small><i>2008-05-15 draft ccpp computer  Nesses últimos dias andei conversando com um amigo que está estudando sistemas operacionais na faculdade. Melhor ainda, vendo o código real de um sistema operacional em funcionamento. A conseqüência é que, além de aprender um bocado de como as coisas funcionam de verdade debaixo dos panos, acaba-se aprendendo alguns truquezinhos básicos e tradicionais da linguagem C.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/kernel_mode_user_mode_windbg_user_kernel2.png"/>
<b><a href="2008-05.html#kernel_mode_user_mode">Kernel Mode &gt;&gt; User Mode, ou Como Fazer Debug de User Mode pelo Kernel Mode</a></b>
<small><i>2008-05-13 blogging draft windbg computer  Existem algumas situações onde um depurador WYSIWYG é artigo de luxo. Imagine o seguinte: temos um serviço que inicia automagicamente antes do login do Windows, e possivelmente antes mesmo do ambiente gráfico. Esse serviço tem algum problema que impede que ele funcione sob as circunstâncias de inicialização do sistema. O que fazer?  Atachar o WinDbg no processo?</small></i>
</td></tr>
<tr><td>
<b><a href="2008-05.html#read_the_functional_manual">Read The Functional Manual</a></b>
<small><i>2008-05-07 draft essays  Percebi essa semana que talvez boa parte da população informática que não progride em suas habilidades, mas gostaria muito, pode ser impedida pela falta de hábito em ler a ajuda do programa | da linguagem | do sistema com calma para encontrar o que procura. Independente do que você é, e para onde quer chegar, saiba que nem tudo na vida pode ser perguntado ao seu colega de baia. Senão você não evolui!</small></i>
</td></tr>
<tr><td>
<b><a href="2008-05.html#acessando_memoria_fisica_no_windbg">Acessando memória física no WinDbg</a></b>
<small><i>2008-05-01 draft computer  Como muitos devem saber, acessar memória virtual no WinDbg é coisa de criança, assim como em todo depurador decente. Se estamos falando de kernel mode então, nem se fala! A memória virtual é parte integrante do sistema operacional. Podemos saber mais sobre isso na apresentação do Strauss sobre [gerenciamento de memória no Windows].</small></i>
</td></tr>
<tr><td>
<b><a href="2008-04.html#csi_crashed_server_investigation">CSI: Crashed Server Investigation?</a></b>
<small><i>2008-04-23 draft essays  O artigo de Jeff Dailey, The Digital DNA of Bugs Dump Analysis as Forensic Science, em que ele compara a nossa atividade de "cientistas do debugging" com a atividade dos profissionais da análise forense, é exatamente o que eu penso sobre nossa profissão. Freqüentemente assisto à série CSI: Las Vegas e mais freqüentemente ainda uso os métodos científicos empregados pela equipe de Gil Grissom para resolver os problemas mais escabrosos que podem ocorrer em um sistema.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-04.html#ode_ao_c++">Ode ao C++</a></b>
<small><i>2008-04-21 draft ccpp computer  Strauss: lembra quando nós conversávamos sobre o assunto "Por que C++?", há muitas décadas atrás, e seu blogue era um dos primeiros no Brasil que não ficava relatando o que o autor comia no café da manhã, além de falar sobre programação? Pois é, eu estava reorganizando meus g-mails e reencontrei nossa conversa e, pior, seu artigo "derivado" dela, que irei republicar aqui pois, assim como antes, acredito em tudo que escrevi naquela época.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/aprendendo_assembly_com_o_depurador_windbgxnotepad.png"/>
<b><a href="2008-04.html#aprendendo_assembly_com_o_depurador">Aprendendo assembly com o depurador</a></b>
<small><i>2008-04-11 draft computer  Além de servir para corrigir alguns [bugs escabrosos] o nosso bom e fiel amigo depurador também possui uma utilidade inusitada: ensinar assembly! A pessoa interessada em aprender alguns conceitos básicos da arquitetura do 8086 pode se exercitar na frente de um depurador 16 ou 32 bits sem ter medo de ser feliz.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/conversor_de_houaiss_para_babylon_parte_2_houaiss_babylon.png"/>
<b><a href="2008-04.html#conversor_de_houaiss_para_babylon_parte_2">Conversor de Houaiss para Babylon - parte 2</a></b>
<small><i>2008-04-08 draft projects computer  Após algumas semanas de suspense, chegamos finalmente à nossa segunda e última parte da saga do dicionário Houaiss. Como devem [estar lembrados], a primeira parte se dispôs a desmontar a ofuscação usada nos arquivos do dicionário para permitir nossa posterior análise, com o simples e justo objetivo de importá-lo para o Babylon, cujas funcionalidades de busca são bem superiores.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-04.html#try_catch_flutuante">Try-catch flutuante</a></b>
<small><i>2008-04-03 draft ccpp computer  Esse detalhe da linguagem quem me fez descobrir foi o Yorick, que costuma comentar no blogue e tive o prazer de conhecer no [4o. EPA-CCPP]. É possível, apesar de bizarro, colocar um bloco try-catch em torno da lista de inicialização de variáveis de um construtor. Essa característica da linguagem permite que possamos capturar alguma exceção lançada por algum construtor de algum membro da classe. A construção em código ficaria no estilo abaixo:</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/windbg_a_distancia_windbg_remote2.gif"/>
<b><a href="2008-03.html#windbg_a_distancia">WinDbg a distância</a></b>
<small><i>2008-03-26 draft computer  Acho que o que mais me impressionou até hoje a respeito do WinDbg é a sua capacidade de depuração remota. Não há nada como depurar problemas sentado confortavelmente na sua cadeira de programador em frente à sua mesa de programador.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/depuracao_da_mbr_debug_debug.png"/>
<b><a href="2008-03.html#depuracao_da_mbr">Depuração da MBR</a></b>
<small><i>2008-03-24 draft computer  Dando continuidade a um artigo bem antigo sobre [depuração da BIOS usando SoftIce], como já vimos, podemos igualmente depurar a MBR após a chamada da INT13. Porém, devo atentar para o fato que, em algumas VMs, e sob determinadas condições do tempo e quantidade de ectoplasma na atmosfera, é possível que a máquina trave após o hot boot iniciado pelo depurador. Isso provavelmente tem cura usando o espaço de endereçamento alto da memória com a ajuda de aplicativos como LH e UMB.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/o_misterio_das_pilhas_diferentes_windbg_nerd.gif"/>
<b><a href="2008-03.html#o_misterio_das_pilhas_diferentes">O mistério das pilhas diferentes</a></b>
<small><i>2008-03-12 draft computer  Mal comecei a leitura do meu mais novo ["mother-fucker" livro] e já encontrei a solução para nunca mais viver o terror que vivi quando tive que testar minha engenharia reversa do artigo sobre o Houaiss. Se trata de uma simples questão que não sei por que não sigo todas as vezes religiosamente: configure seus símbolos corretamente.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-03.html#iteradores_nao_sao_constantes">Iteradores não são constantes</a></b>
<small><i>2008-03-04 draft computer  Um bug que já encontrei uma dúzia de vezes entre os novatos da STL é a utilização de iteradores como se eles não fossem mudar nunca. Porém, a verdade é bem diferente: iteradores se tornam inválidos sim, e com muito mais freqüência do que normalmente se imagina. Entre as situações em que iteradores podem mudar estão as seguintes:</small></i>
</td></tr>
<tr><td>
<b><a href="2008-02.html#quando_o_ponteiro_nulo_nao_e_invalido">Quando o ponteiro nulo não é inválido</a></b>
<small><i>2008-02-29 draft computer  Existe coisa mais prazerosa do que admitir um erro que foi cometido na mesma semana? Existe: quando você sabia que estava certo, mas resolveu usar o senso comum por falta de provas. Pois bem. O mesmo amigo que me recomendou que escrevesse sobre o assunto do ponteiro nulo achou um livro sobre [armadilhas em C] com um exemplo que demonstra exatamente o contrário: dependendo da plataforma, ponteiros nulos são sim válidos.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/conversor_de_houaiss_para_babylon_parte_1_cmd.gif"/>
<b><a href="2008-02.html#conversor_de_houaiss_para_babylon_parte_1">Conversor de Houaiss para Babylon - parte 1</a></b>
<small><i>2008-02-27 draft projects computer  Este artigo é sobre desmontar e montar novamente. Iremos descobrir como as entradas do dicionário Houaiss eletrônico estão gravadas em um primeiro momento, para depois remontarmos essa informação de maneira que ela possa ser usada em outro dicionário de uso mais flexível, o Babylon. Ou seja, este não é um guia de vandalismo. Estava apenas querendo usar um dicionário de qualidade excelente em outro dicionário cuja interface é muito boa.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-02.html#codigos_de_entrevista_o_ponteiro_nulo">Códigos de entrevista - o ponteiro nulo</a></b>
<small><i>2008-02-25 draft computer  Bom, parece que o "mother-fucker" wordpress ferrou com meu artigo sobre o Houaiss. Enquanto eu choro as pitangas aqui vai um outro artigo um pouco mais simples, mas igualmente interessante. > "Wanderley, tenho umas sugestões para teu blog.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/os_diferentes_erros_na_linguagem_c_linker.gif"/>
<b><a href="2008-02.html#os_diferentes_erros_na_linguagem_c">Os diferentes erros na linguagem C</a></b>
<small><i>2008-02-15 draft ccpp computer  Uma coisa que me espanta de vez em quando é o total desconhecimento por programadores mais ou menos experientes dos níveis de erros que podem ocorrer em um fonte escrito em C ou C++. Desconheço o motivo, mas desconfio que o fato de outras linguagens não terem essa divisão de processos pode causar alguma nivelação entre as linguagens e fazer pensar que o processo de compilação em C é como em qualquer outra linguagem.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-02.html#funky_dowhile">Funky do-while</a></b>
<small><i>2008-02-13 draft english computer  It's a known habit to use do-while constructions when there's a need to define a macro that has more than one command instead of using the { simple multicommand brackets }. What was never clear is why this is so.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-02.html#desconstruindo_ioccc">Desconstruindo IOCCC</a></b>
<small><i>2008-02-11 draft computer  Como alguns devem saber, e outros não (ou não deveriam), existe uma competição internacional para escolher quem escreve o código em C mais ofuscado. Isso mesmo. O evento se chama [The International Obfuscated C Code Contest] (IOCCC resumidamente) e costuma premiar anualmente os melhores "do ramo" com a chamada "menção desonrosa".</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/process_monitor_e_o_monopolio_malcriado_monopoly_procmon_find2.png"/>
<b><a href="2008-02.html#process_monitor_e_o_monopolio_malcriado">Process Monitor e o monopólio malcriado</a></b>
<small><i>2008-02-05 draft computer  Uma das primeiras regras que aprendemos para manter a integridade do Windows é utilizá-lo somente com a conta de usuários restritos, o que evitaria, por exemplo, que um programa mal-intencionado instale um serviço ou driver, que teriam acesso às partes íntimas do sistema operacional.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-01.html#rmthread_rode_codigo_em_processo_vizinho">RmThread: rode código em processo vizinho</a></b>
<small><i>2008-01-28 draft computer  Aproveitando que utilizei a mesma técnica semana passada para desenvolver um vírus para Ethical Hacking, republico aqui este [artigo que já está mofando no Code Projet], mas que espero que sirva de ajuda pra muita gente que gosta de fuçar nos internals do sistema. Boa leitura!</small></i>
</td></tr>
<tr><td>
<b><a href="2008-01.html#otimizacao_em_funcoes_recursivas">Otimização em funções recursivas</a></b>
<small><i>2008-01-18 draft computer  O livro que estou lendo, Dominando Algoritmo com C, como o próprio nome diz, fala sobre algoritmos em C. Os primeiros capítulos são praticamente uma revisão para quem já programou em C, pois tratam de coisas que programadores com mais de cinco anos de casa devem ter na memória cachê (listas, pilhas, recursão, etc). Porém, tive uma agradável surpresa de achar um truque muito sabido que não conhecia, chamado de [tail recursion]. Fiz questão de testar nos dois compiladores mais conhecidos e eis o resultado.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/encontrando_as_respostas_do_flash_pops_flash_pops.gif"/>
<b><a href="2008-01.html#encontrando_as_respostas_do_flash_pops">Encontrando as respostas do Flash Pops</a></b>
<small><i>2008-01-16 draft computer  Existia uma série de jogos no sítio da UOL chamado Flash Pops onde você deve acertar o nome de filmes, programas de televisão, entre outros, que vão da década de 40 até a atualidade. É divertido e viciante fazer pesquisa na internet para encontrar os resultados, ainda mais quando já se é viciado em cinema. Ficamos jogando, eu e minha namorada, por semanas a fio. Quase chegamos a preencher tudo, e por um bom tempo ficamos travados para terminar. Então começamos a apelar para o Google e o IMDB até os limites do razoável. Nesse fim de semana, por exemplo, chegamos a assistir um filme de madrugada onde tocou rapidamente um trecho de uma das músicas que faltava no jogo sobre televisão. No dia seguinte procuramos a trilha sonora do filme, ouvimos faixa a faixa e procuramos o nome da música no Google, para finalmente encontrar o resultado.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-01.html#analisando_dumps_com_windbg_e_ida">Analisando Dumps com WinDbg e IDA</a></b>
<small><i>2008-01-10 draft computer  Apesar de ser recomendado que 100% dos componentes de um software esteja configurado corretamente para gerar símbolos na versão release, possibilitando assim a visualização do nome das funções internas através de um arquivo de dump (despejo) gerado na ocorrência de um crash, essa verdade só ocorre em 80% das vezes. Quis Murphy que dessa vez a única parte não "simbolizada" fosse a que gerou a tela azul em um Intel Quad Core que estou analisando esses dias.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-12.html#curiosidades_inuteis_o_operador_de_subscrito_em_c">Curiosidades inúteis: o operador de subscrito em C++</a></b>
<small><i>2007-12-27 draft computer  Este artigo é uma reedição de meu blogue antigo, guardado para ser republicado durante minhas miniférias. Esteja à vontade para sugerir outros temas obscuros sobre a linguagem C ou C++ de sua preferência. Boa leitura!</small></i>
</td></tr>
<tr><td>
<b><a href="2007-12.html#o_que_acontece_quando_o_contador_estoura">O que acontece quando o contador estoura</a></b>
<small><i>2007-12-25 draft computer  Dois conceitos de programação relacionados a limites computacionais são bem conhecidos do programador: o famigerado overflow e o não-tão-famoso underflow (embora seja fácil imaginar que ele é o oposto do primeiro). O primeiro ocorre quando somamos a uma variável inteira não-nula um valor cujo resultado não consegue ser representado pelo tamanho de memória usado para armazenar esse tipo inteiro (que pode ser um caractere, um inteiro curto, inteiro longo e por aí vai). O underflow, por outro lado (outro lado mesmo), é o resultado de uma subtração que não pode ser representado pelo número de bits do seu tipo inteiro.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-12.html#sizeof_de_novo">Sizeof (de novo)</a></b>
<small><i>2007-12-17 draft computer  Algumas coisas em C parecem tão simples na programação do dia-a-dia que em alguns momentos podem existir situações confusas e misteriosas. O uso obscuro do operador sizeof, por exemplo, pode dar margem a interpretações erradas a respeito do que está acontecendo por debaixo dos panos. Apesar do padrão ter sido elaborado para tentar tornar a linguagem uma coisa intuitiva e de fácil dedução, isso não acontece todas as vezes.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-11.html#carregando_dlls_arbitrarias_pelo_windbg_parte_2">Carregando DLLs arbitrárias pelo WinDbg ou como escrever script para WinDbg</a></b>
<small><i>2007-11-27 draft computer  Como pudemos ver no [artigo anterior] o processo para carregar uma DLL pelo WinDbg é muito extenso, enfadonho e sujeito a erros. Além de desatualizado (com comandos de assembly 32 bits). Por esse motivo, e para tornar as coisas mais divertidas, resolvi transformar tudo aquilo em um simples script que pode ser executado digitando apenas uma linha. Tenha em mente que este artigo continua desatualizado usando assembly 32 bits e hoje é uma mera curiosidade para aprendizado do passado. E se trata do meu primeiro script grande para o WinDbg, por isso, peço que tenham dó de mim =).</small></i>
</td></tr>
<tr><td>
<b><a href="2007-11.html#carregando_dlls_arbitrarias_pelo_windbg">Carregando DLLs arbitrárias pelo WinDbg</a></b>
<small><i>2007-11-23 draft computer  Durante meus testes para a correção de um bug me deparei com a necessidade de carregar uma DLL desenvolvida por mim no processo depurado. O detalhe é que o processo depurado é de terceiros e não possuo o fonte. Portanto, as opções para mim mais simples são:</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/detectando_hooks_globais_no_windbg_codigo_malicioso.gif"/>
<b><a href="2007-11.html#detectando_hooks_globais_no_windbg">Detectando hooks globais no WinDbg (SetWindowsHookEx)</a></b>
<small><i>2007-11-09 draft computer  Nada como um comando prático para aprender rapidamente uma técnica. Nesse caso, tive que usar o seguinte comando para localizar o momento em que um executável instala um hook global: bp user32!SetWindowsHookExA "j poi(esp+4*4) 'g' ; '.echo *** GLOBAL HOOK ***; g'".</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/ponteiro_de_metodo_qual_this_e_usado_fuzzycall.gif"/>
<b><a href="2007-11.html#ponteiro_de_metodo_qual_this_e_usado">Ponteiro de método: qual this é usado?</a></b>
<small><i>2007-11-07 draft computer  Depois de publicado o artigo anterior sobre ponteiros de métodos surgiu uma dúvida muito pertinente do autor do blogue [CodeBehind], um escovador de bits disfarçado de programador .NET: qual objeto que vale na hora de chamar um método pelo ponteiro?</small></i>
</td></tr>
<tr><td>
<b><a href="2007-11.html#ponteiros_de_metodo_conceito_fundamental">Ponteiros de método: conceito fundamental</a></b>
<small><i>2007-11-05 draft computer  Diferente de ponteiros de função globais ou estáticas, que são a grosso modo ponteiros como qualquer um, os ponteiros de método possuem uma semântica toda especial que costuma intimidar até quem está acostumado com a aritmética de ponteiros avançada. Não é pra menos: é praticamente uma definição à parte, com algumas limitações e que deixa a desejar os quase sempre criativos programadores da linguagem, que vira e mexe estão pedindo mudanças no C++0x.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/brincando_com_o_windbg_notepad_wonderful_file.png"/>
<b><a href="2007-10.html#brincando_com_o_windbg">Brincando com o WinDbg (alterando mensagem de erro no Bloco de Notas / Notepad)</a></b>
<small><i>2007-10-30 draft computer  No [primeiro artigo sobre o WinDbg] usamos o aplicativo Logger para verificar as funções APIs que são chamadas por um determinado programa. Agora iremos dar um passo adiante e depurar de fato um aplicativo qualquer, com o detalhe que não teremos o código-fonte.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-10.html#protecao_dos_membros_protected">Proteção dos membros protected</a></b>
<small><i>2007-10-26 draft ccpp computer  Quando queremos que um membro de nossa classe seja visível apenas dentro dos métodos da classe e dentro dos métodos das classes derivadas dessa classe usamos o nível de proteção protected. Isso, é claro, não quer dizer que uma classe derivada vá ter acesso aos membros protegidos de outra:</small></i>
</td></tr>
<tr><td>
<b><a href="2007-10.html#typeid_e_os_perigos_do_nao_polimorfismo">Typeid e os perigos do não-polimorfismo</a></b>
<small><i>2007-10-24 draft ccpp computer  Quando usamos o operador typeid geralmente desejamos conhecer informações sobre o tipo exato do objeto que temos em mãos, independente da hierarquia de herança a qual seu tipo pertença. Só que por ignorar, assim como o [sizeof], que esse operador possui duas caras, às vezes damos com os burros n'água e compramos gato por lebre. Não é pra menos. Uma sutil diferença entre classes polimórficas e estáticas pode dar aquele susto que só C++ pode proporcionar.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/guia_basico_para_programadores_de_primeiro_breakpoint_debug.png"/>
<b><a href="2007-10.html#guia_basico_para_programadores_de_primeiro_breakpoint">Guia básico para programadores de primeiro breakpoint</a></b>
<small><i>2007-10-22 draft computer  Aproveitando um dos últimos artigos que fala sobre [conceitos básicos de programação], lembro que, tão importante quanto programar é possuir habilidades básicas de depuração, uma arte por muitos programadores ignorada.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/por_que_minha_dll_travou_loader_lock.gif"/>
<b><a href="2007-10.html#por_que_minha_dll_travou">Por que minha DLL travou?</a></b>
<small><i>2007-10-18 draft computer  O resumo da ópera é que o código do Windows chamador do DllMain das DLLs carregadas/descarregadas utiliza um objeto de acesso exclusivo (leia "mutex") para sincronizar as chamadas. O resultado é que, em um processo, apenas um DllMain é chamado em um dado momento. Esse objeto é chamado de loader lock na documentação da Microsoft.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/guia_basico_para_programadores_de_primeiro_int_main_for.gif"/>
<b><a href="2007-10.html#guia_basico_para_programadores_de_primeiro_int_main">Guia básico para programadores de primeiro int main</a></b>
<small><i>2007-10-16 draft computer  > Vou aproveitar que meu amigo DQ publicou um artigo muito bom sobre [como fazer programas fáceis de manter] (merece ser lido!) e vou republicar um artigo do blogue antigo sobre o básico do básico para quem deseja entender como os programas funcionam. Não é nada sofisticado, apenas alguns conceitos comuns que, se você deseja ser programador, deveria procurar saber.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/the_c_programming_language_binary_tree.gif"/>
<b><a href="2007-10.html#the_c_programming_language">A Linguagem de Programação C: O Livro</a></b>
<small><i>2007-10-12 draft computer books ccpp  O clássico de Ritchie e Kernighan, criadores da linguagem C, não foi meu primeiro livro de programação. E nem deveria ser. Não o recomendo para iniciantes, pois é necessário possuir algum conhecimento e prática para realmente aproveitar os conceitos desse livro.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/debug_da_bios_com_o_softice_16_bits_myos_start.png"/>
<b><a href="2007-10.html#debug_da_bios_com_o_softice_16_bits">Debug da BIOS com o SoftIce 16 bits</a></b>
<small><i>2007-10-02 blogging draft computer  Para quem acha que ainda não desceu demais o nível existe um [ótimo artigo] no Code Project de S. Z. Keller (aka ShalomZ) sobre como construir seu próprio sistema operacional. É simples, direta e empolgante a maneira com que ele explica e trata os detalhes básicos, desde quando o computador é ligado até quando o boot loader carrega e entrega o controle de execução. Eu mesmo fiz o teste com a imagem que foi disponibilizada para download e funcionou direitinho. Agora esse meu artigo se dispõe a explicar como você pode fazer para depurar o processo de load do seu primeiro sistema operacional.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-09.html#why_is_my_dll_locked">Why is my DLL locked?</a></b>
<small><i>2007-09-24 draft english computer  The Windows code responsible to call DllMain for each loaded and unloaded DLLs uses an exclusive access object, the so-called mutex, to synchronize its calls. The result is that inside a process just one DllMain can be called at a given moment. This object-mutex is called "loader lock" into the Microsoft documentation.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/hook_de_com_no_windbg_iunknown_breakpoint.png"/>
<b><a href="2007-09.html#hook_de_com_no_windbg">Hook de COM no WinDbg</a></b>
<small><i>2007-09-18 draft computer  Continuando com o tema hooks no WinDbg vamos aqui "hookear" e analisar as chamadas de métodos de um objeto COM. O que será feito aqui é o mesmo experimento feito para uma palestra de engenharia reversa que apresentei há um tempo atrás, mas com as opções de pause, rewind, replay e câmera lenta habilitadas.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-09.html#aquisicao_de_recurso_e_inicializacao">Aquisição de recurso é inicialização</a></b>
<small><i>2007-09-14 draft ccpp computer  O título desse artigo é uma técnica presente no paradigma da programação em C++, razão pela qual não temos o operador finally. A idéia por trás dessa técnica é conseguirmos usar recursos representados por objetos locais de maneira que ao final da função esses objetos sejam destruídos e, junto com eles, os recursos que foram alocados. Podemos chamar de recursos aquele arquivo que necessita ser aberto para escrita, o bitmap que é exibido na tela, o ponteiro de uma interface COM, etc. O nosso exemplo é sobre arquivos:</small></i>
</td></tr>
<tr><td>
<b><a href="2007-08.html#hook_de_api_no_windbg">Hook de API no WinDbg</a></b>
<small><i>2007-08-29 draft computer  Basicamente existem duas maneiras de um executável obter o endereço de uma função API do Windows: ou ele usa uma lib de interface com a DLL (o chamado "link estático") ou ele chama a função GetProcAddress explicitamente (1).</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/antidebug_ocupando_a_debugport_debugport.gif"/>
<b><a href="2007-08.html#antidebug_ocupando_a_debugport">Antidebug: ocupando a DebugPort</a></b>
<small><i>2007-08-23 draft projects computer  Quando um depurador inicia um processo para ser depurado ou, o caso abordado por este artigo, se conecta em um processo já iniciado, as comunicações entre esses dois processos é feita através de um recurso interno do Windows chamado de LPC (Local Procedure Call). O sistema cria uma "porta mágica" de comunicação específica para a depuração e os eventos trafegam por meio dela.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/historia_da_linguagem_c_parte_2_kthompson_dritchie.jpg"/>
<b><a href="2007-08.html#historia_da_linguagem_c_parte_2">História da Linguagem C: Parte 2</a></b>
<small><i>2007-08-15 draft ccpp computer  No princípio... não, não, não. Antes do princípio, quando C era considerada a terceira letra do alfabeto e o que tínhamos eram linguagens experimentais para todos os lados, dois famigerados senhores dos Laboratórios Bell, K. Thompson e D. Ritchie, criaram uma linguagem chamada B. E B era bom.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-08.html#antidebug_interpretacao_baseada_em_excecao_parte_2">Antidebug: interpretação baseada em exceção (parte 2)</a></b>
<small><i>2007-08-09 draft projects computer  No [primeiro artigo] vimos como é possível "enganar" o depurador através de exceções e assim fazer o atacante perder um tempo considerável tentando se desvencilhar dos breakpoints de mentira. Porém, vimos também que essa é uma solução difícil de manter no código-fonte, além de possuir o ponto fraco de ser facilmente contornada se descoberta. Agora é a hora de tornar as coisas mais fáceis de manter e ao mesmo tempo garantir maior dificuldade mesmo que o atacante descubra o que está acontecendo debaixo do seu nariz.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/historia_da_linguagem_c_parte_1_ccpp_build_steps.gif"/>
<b><a href="2007-08.html#historia_da_linguagem_c_parte_1">História da Linguagem C: Parte 1</a></b>
<small><i>2007-08-01 draft ccpp computer  Confesso que adoro estudar sobre a história da linguagem C. Essa verdadeira adoração pela linguagem me fez estudar suas precursoras, como as linguagens BCPL e B. Posso dizer que todo esse conhecimento, no final das contas, valeu a pena. Hoje entendo muito melhor as decisões tomadas na criação da linguagem e, principalmente, a origem de algumas idiossincrasias e boas idéias que permaneceram até hoje.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-07.html#c_and_c++_operators_precedence_table">C and C++ Operators Precedence Table</a></b>
<small><i>2007-07-30 draft english ccpp computer  > Wanderley, your explanation about [why a program compiles in C++ and not in C] seems to me logic and correct, but gave me some doubts, because I always learned that the C and C++ operator precedence are the same thing. I checked out the Appendix A in the "C ++ - How To Program" (sixth edition) and the book table is equal to the C operators precedence table and it is different from the C++ precedence table presented by you in the article. I went to the internet and found out in two websites the table and both are equal to the book table:</small></i>
</td></tr>
</table>
<span style="float: left;">
</span>
</div>
</div>
</section>
<footer class="footer">
<div class="container">
</div>
<div class="intentionally-blank"></div>
</footer>
</body>
</html>
