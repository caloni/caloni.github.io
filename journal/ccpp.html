<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Jornal do Caloni</title>
<meta name="author" content="Caloni" />
<meta name="generator" content="https://github.com/caloni/journal">
<meta property="og:title" content="Jornal do Caloni"/>
<meta property="og:type" content="website"/>
<meta property="og:url" content="http://www.caloni.com.br"/>
<meta property="og:image" content="/journal/img/about-brand.png"/>
<meta property="og:description" content="Write for computers, people and food."/>
<link href="/journal/index.xml" rel="feed" type="application/rss+xml" title="Jornal do Caloni"/>
<link rel="stylesheet" type="text/css" href="/journal/css/custom.css"/>
<link rel="stylesheet" type="text/css" href="/journal/css/jquery-ui.css"/>
<script src="/journal/js/jquery-1.12.4.js"></script>
<script src="/journal/js/jquery-ui.js"></script>
<script src="/journal/js/copy_clipboard.js"></script>
<script src="/journal/js/list.js"></script>
<link rel="icon" href="/journal/img/favicon.ico"/>
</head>
<body style="min-height:100vh;display:flex;flex-direction:column">
<nav class="navbar has-shadow is-white"
role="navigation" aria-label="main navigation">
<div class="container">
<div class="navbar-brand">
&nbsp;
<a class="navbar-item" href="index.html">
<div class="is-4"><b>Jornal do Caloni</b></div>
</a>
</div>
</div>
</nav>
<div class="container">
<div class="column">
<div style="min-height:56vh">
<div style="padding-bottom: 1em;"></div>
<input type="text" name="filter" value="" id="filter" placeholder="enter to select" style="width: 100%; font-size: 1.5rem; margin-top: 1em; margin-bottom: 0.5em;" title=""/></br>
<button id="filterbutton" style="font-size: 1rem;" onclick="ApplyFilter($('#filter').val());">select</button>
<button id="removebutton" style="font-size: 1rem;" onclick="ApplyNotFilter($('#filter').val());">remove</button>
<button id="randombutton" style="font-size: 1rem;" onclick="window.location = randomPost;">random</button>
<div><big><b><span style="visibility: hidden; padding: 5px;" name="results" id="results">...</span></b></big></div>
<table class="sortable" style="width: 100%;">
<tr><td>
<b><a href="2024-07.html#[se_nao_instanciou_o_template_nao_tem_nada_de_errado, se_nao_instanciou_o_template_nao_tem_nada_de_errado]">Se não instanciou o template não tem nada de errado</a></b>
<small><i>2024-07-03 computer ccpp  Considere este código: Vai quebrar em que linha? Resposta: nenhuma. Isso porque não há uma instanciação de nenhum template Size e o compilador não tem código algum para validar. Tudo que ele sabe é que, uma vez instanciado Size seu tipo Adapter precisa ter um membro chamado Size compatível com um inteiro para que o método size() seja um código válido.</small></i>
</td></tr>
<tr><td>
<b><a href="2022-11.html#[passagem_de_parametros_c_vs_c++, passagem_de_parametros_c_vs_c++]">Passagem de Parâmetros C vs C++</a></b>
<small><i>2022-11-20 computer ccpp blogging  Em C não é necessário declarar os parâmetros que uma função recebe. Isso é implícito. A linguagem C foi criada para ser um amontoado de assembly descrito com um pouco de syntax sugar e juntado pelo linker através de uma tabela de nomes. O que importa são os nomes. Vamos exemplificar:</small></i>
</td></tr>
<tr><td>
<b><a href="2022-11.html#[gerenciamento_de_memoria_em_cc++, gerenciamento_de_memoria_em_cc++]">Gerenciamento de Memória em C/C++</a></b>
<small><i>2022-11-19 computer ccpp videos  Esta semana fiz uma passagem de conhecimento na firma sobre os smart pointers em C++, que era no fundo o que todo mundo queria entender. Mas para entender essas coisas nada como voltar aos fundamentos da linguagem C e ir subindo nos conceitos.</small></i>
</td></tr>
<tr><td>
<b><a href="2020-08.html#[getargs_v_array, getargs_v_array]">GetArgs v. Array</a></b>
<small><i>2020-08-04 computer ccpp  Algumas pessoas ficam chateadas quando não se programa usando Boost para tudo. E por isso eu continuo escrevendo código simples e funcional para meu blogue. Esse código vai continuar funcionando por mais cem anos e o código da Boost vai explodir antes que seus filhos nasçam.</small></i>
</td></tr>
<tr><td>
<b><a href="2020-06.html#[c++_co_routines, c++_co_routines]">C++ Co Routines</a></b>
<small><i>2020-06-21 computer ccpp blogging  Entre os gêneros mais famosos do cinema e da programação está o terror, esse estado mental que se caracteriza pelo medo ou pela aversão a uma situação que envolve a perda de controle. Nesse quesito se encaixam as novas corrotinas que serão adotadas pelo padrão C++.</small></i>
</td></tr>
<tr><td>
<b><a href="2020-06.html#[printf, printf]">Printf</a></b>
<small><i>2020-06-18 computer ccpp  Entre os segredos escondidos das funções básicas da lib padrão da linguagem C o printf e o scanf lideram o ranking. O printf possui a capacidade de alinhamento de colunas das string impressas com tamanho variável. Sabia disso? Pois é, isso não se ensina nas escolas.</small></i>
</td></tr>
<tr><td>
<b><a href="2020-04.html#[cast_operator, cast_operator]">Cast Operator</a></b>
<small><i>2020-04-22 computer ccpp  O código abaixo não é C++ moderno. É 98. Porém, ele já demonstra alguns problemas na linguagem que foram aumentados desde então. Não se sabe exatamente qual a tradução semântica de construções tão parecidas quanto o operador-função e o operador-cast. Enquanto o primeiro serve para transformar objetos em funções chamáveis o segundo serve para extrair tipos de maneira educada.</small></i>
</td></tr>
<tr><td>
<b><a href="2019-08.html#[some_things_i_learned_in_a_hacker_rank_exercise, some_things_i_learned_in_a_hacker_rank_exercise]">Some things I learned in a Hacker Rank exercise</a></b>
<small><i>2019-08-08 computer ccpp english  A couple of days ago I subscribed to Hacker Hank, a website specialized in provide interview exercises. The site is as a better version of Code Jam, with the possibility to Compile &amp; Run the code, as well as running several test cases.</small></i>
</td></tr>
<tr><td>
<b><a href="2018-08.html#[meu_novo_parseador_de_argc_argv, meu_novo_parseador_de_argc_argv]">Meu Novo Parseador de Argc Argv</a></b>
<small><i>2018-08-21 computer ccpp  Eis que me deparo com um projeto onde não posso usar STL. Ou seja, nada de map nem string. Isso quer dizer que minha função bonita e completa de parseamento de argumentos argc/argv não pode ser usado. Essa é uma má notícia. A boa notícia é que achei uma forma muito mais simples e à prova de falhas de fazer isso. Ele basicamente percorre o array argv em busca do nome do parâmetro enviado para a função. Uma vez que ele encontre ele retorna o próximo elemento. Na falta de próximo elemento ele simplesmente retorna uma string vazia que não é nulo, mas já indica que há o parâmetro na lista de argumento.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/cpp_arranca_os_cabelos_por_voce_zi5GJxE.png"/>
<b><a href="2017-09.html#[c++_moderno_arranca_os_cabelos_por_voce_stdmove_e_classes_simples, c++_moderno_arranca_os_cabelos_por_voce_stdmove_e_classes_simples]">C++ Moderno Arranca os Cabelos por Você (std::move e classes simples).</a></b>
<small><i>2017-09-26 ccpp  Um dos <a href="https://groups.google.com/forum/#!topic/ccppbrasil/-AC9U7J-0Zg">últimos posts</a> no grupo CCPPBR do Thiago Adams chama mais uma vez a atenção para a complexidade infinita que linguagens como C++ estão preferindo tomar. Esta é a geração que irá sofrer as dores de compatibilidade com o passado mais que todas as outras que virão.</small></i>
</td></tr>
<tr><td>
<b><a href="2016-11.html#[a_linguagem_de_programacao_cpp_o_inicio, a_linguagem_de_programacao_cpp_o_inicio]">A Linguagem de Programação C++: O Início</a></b>
<small><i>2016-11-29 computer ccpp  O livro-base sobre a linguagem C++ e como programar nela tem o nome pouco criativo "The C++ Programming Language", e é de Bjarne Stroustrup, o criador da linguagem. Ele começou a desenhá-la em 1979, quando ainda a chamava de "C com Classes". Havia um problema a ser resolvido na época em que Stroustrup estava fazendo sua tese de doutorado. Havia linguagens muito boas em abstração como Simula, como o novo conceito de Orientação a Objetos, que carecia do mais importante na época: velocidade (só na época?). Já linguagens mais antigas como BCPL eram bem rápidas, mas eram tão simples que pareciam mais um Assembly glorificado. Havia, portanto, a necessidade de preencher a área de computação com alguma coisa bem no meio.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/gabaritos_84Ptrvk.png"/>
<b><a href="2016-01.html#[gabaritos, gabaritos]">Gabaritos</a></b>
<small><i>2016-01-13 computer ccpp  Um template -- ou, como é na tradução da primeira edição de The C++ Programming Language, de Bjarne Stroustrup, aqui no Brasil: gabarito -- é um molde que pode ser usado por diferentes tipos para traduzir o mesmo algoritmo, ou pelo menos a mesma intenção de algoritmo (por pela sobrecarga de operadores é possível que o comportamento de tipos diferentes pode ser diferente).</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/classe_objeto_contexto_metodo_polimorfismo_Ye5mA8L.png"/>
<b><a href="2016-01.html#[classe_objeto_contexto_metodo_polimorfismo, classe_objeto_contexto_metodo_polimorfismo]">Classe, objeto, contexto, método, polimorfismo</a></b>
<small><i>2016-01-12 computer ccpp  No [post anterior] implementamos "métodos" em C usando ponteiros de função dentro de structs que eram passadas como parâmetro. Tudo isso embutido por um compilador que gera o que chamamos de instância de uma classe, ou objeto, em C++. Isso é possível graças ao contexto que é passado para uma função (que no caso de C++ é o operador implícito this, que sempre existe dentro de um método não-estático).</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/classe_objeto_contexto_metodo_uzfJuTC.png"/>
<b><a href="2016-01.html#[classe_objeto_contexto_metodo, classe_objeto_contexto_metodo]">Classe, objeto, contexto, método</a></b>
<small><i>2016-01-11 computer ccpp  No [post anterior] falamos como a passagem de um endereço de uma struct consegue nos passar o contexto de um "objeto", seja em C (manualmente) ou em C++ (automagicamente pelo operador implícito this). Trocamos uma propriedade desse "objeto" em C, mas ainda não chamamos um método.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/classe_objeto_contexto_dilbert.context.gif"/>
<b><a href="2016-01.html#[classe_objeto_contexto, classe_objeto_contexto]">Classe, objeto, contexto</a></b>
<small><i>2016-01-10 computer ccpp  Para entender conceitos simples em C++, como métodos de uma classe, ajuda muito seguir o raciocínio dos programadores C e como eles lidavam com o tipo de problema que C++ resolve elegantemente implementando um novo compilador com uma nova linguagem.</small></i>
</td></tr>
<tr><td>
<b><a href="2015-04.html#[c_c++_engenharia_reversa_e_todo_o_resto, c_c++_engenharia_reversa_e_todo_o_resto]">C, C++, Engenharia Reversa e Todo o Resto</a></b>
<small><i>2015-04-27 ccpp  "C++ é divertido, mas não paga minhas contas". Por diversas coincidências da natureza, e um bocado de empenho deste que vos fala, essa frase não precisa ser dita por mim. Tendo programado em casa por 2 ou 3 anos e lido The C Programming Language um bocado de vezes antes de me aventurar no mercado de trabalho, tive a oportunidade de começar na área já programando em C, C++, e com uma equipe peso-pesado. Programávamos para Windows, onde as coisas não são tão fáceis quanto no Linux (que é um SO de e para programadores), e onde precisa-se comer muita farinha com sintaxe para construir coisas decentes. Portabilidade às vezes é um objetivo, às vezes é deixado de lado. A API Win32 já é bruta demais, e o cliente sempre tem um prazo apertado demais.</small></i>
</td></tr>
<tr><td>
<b><a href="2015-01.html#[origem_do_tipo_char, origem_do_tipo_char]">Origem do Tipo char</a></b>
<small><i>2015-01-26 computer ccpp  Programadores C e C++, preparem-se para explodir as cabeças! No princípio... não, não. Antes do princípio, quando C era considerada a terceira letra do alfabeto e o que tínhamos eram linguagens experimentais para todos os lados, dois famigerados srs. dos Laboratórios Bell, K. Thompson e <a href="https://www.bell-labs.com/usr/dmr/www/">D. Ritchie</a>, criaram uma linguagem chamada B. E B era bom.</small></i>
</td></tr>
<tr><td>
<b><a href="2015-01.html#[entendendo_a_compilacao, entendendo_a_compilacao]">Entendendo a Compilação</a></b>
<small><i>2015-01-04 computer ccpp  Fiz alguns slides a pedido dos organizadores do TDC 2014, já que a palestra que ministrei com esse tema foi para ajudar meu amigo-sócio Rodrigo Strauss que não havia preparado nenhum slide a respeito.Felizmente eu já havia explicado alguns conceitos-chave para quem programa em C/C++ e precisa -- eu disse: PRECISA -- conhecer todo o passo-a-passo que leva o seu código-fonte a gerar um executável com código de máquina pronto para rodar.</small></i>
</td></tr>
<tr><td>
<b><a href="2014-03.html#[a_moda_agora_e_levar_lambda_na_funcao, a_moda_agora_e_levar_lambda_na_funcao]">A moda agora é levar lambda na função</a></b>
<small><i>2014-03-28 computer ccpp  A nova moda de programar C++ nos últimos anos com certeza é usar lambda. Mas, afinal, o que é lambda? Bom, pra começar, é um nome muito feio. O que esse nome quer dizer basicamente é que agora é possível criar função dentro de função. Não só isso, mas passar funções inteiras, com protótipo, corpo e retorno, como parâmetro de função.</small></i>
</td></tr>
<tr><td>
<b><a href="2013-12.html#[uma_nova_linguagem, uma_nova_linguagem]">Uma nova linguagem</a></b>
<small><i>2013-12-04 ccpp  Tenho que me atualizar. Faz um tempo (anos) em que deixei de lado esse mundo "frescurento" de C++2030 e me foquei única e exclusivamente em resolver problemas da melhor forma possível com o que a linguagem já tinha a oferecer em uma implementação estável de compilador e bibliotecas.</small></i>
</td></tr>
<tr><td>
<b><a href="2012-05.html#[sobrecarga_de_funcao_as_avessas, sobrecarga_de_funcao_as_avessas]">Sobrecarga de função às avessas</a></b>
<small><i>2012-05-20 computer ccpp  Alguém já se perguntou se é possível usar sobrecarga de função quando a diferença não está nos parâmetros recebidos, mas no tipo de retorno? Melhor dizendo, imagine que eu tenha o seguinte código: É um uso sensato de sobrecarga. Mas vamos supor que eu queira uma sintaxe mais intuitiva, com o retorno sendo atribuído à variável:</small></i>
</td></tr>
<tr><td>
<b><a href="2008-05.html#[aquele_do_while_engracado, aquele_do_while_engracado]">Aquele do-while engraçado</a></b>
<small><i>2008-05-15 computer ccpp blog  Nesses últimos dias andei conversando com um amigo que está estudando sistemas operacionais na faculdade. Melhor ainda, vendo o código real de um sistema operacional em funcionamento. A conseqüência é que, além de aprender um bocado de como as coisas funcionam de verdade debaixo dos panos, acaba-se aprendendo alguns truquezinhos básicos e tradicionais da linguagem C.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-04.html#[ode_ao_c++, ode_ao_c++]">Ode ao C++</a></b>
<small><i>2008-04-21 computer ccpp blog  Era uma vez em uma troca de emails: Strauss: Lembra quando nós conversávamos sobre o assunto "Por que C++?", há muitas décadas atrás, e seu blogue era um dos primeiros no Brasil que não ficava relatando o que o autor comia no café da manhã, além de falar sobre programação? Pois é, eu estava reorganizando meus g-mails e reencontrei nossa conversa e, pior, seu artigo "derivado" dela, que irei republicar aqui pois, assim como antes, acredito em tudo que escrevi naquela época.</small></i>
</td></tr>
<tr><td>
<b><a href="2008-04.html#[try_catch_flutuante, try_catch_flutuante]">Try-catch flutuante</a></b>
<small><i>2008-04-03 computer ccpp blog  Esse detalhe da linguagem quem me fez descobrir foi o Yorick, que costuma comentar no blogue e tive o prazer de conhecer no [4o. EPA-CCPP]. É possível, apesar de bizarro, colocar um bloco try-catch em torno da lista de inicialização de variáveis de um construtor. Essa característica da linguagem permite que possamos capturar alguma exceção lançada por algum construtor de algum membro da classe. A construção em código ficaria no estilo abaixo:</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/os_diferentes_erros_na_linguagem_c_preprocessor.gif"/>
<b><a href="2008-02.html#[os_diferentes_erros_na_linguagem_c, os_diferentes_erros_na_linguagem_c]">Os diferentes erros na linguagem C</a></b>
<small><i>2008-02-15 computer ccpp blog  Uma coisa que me espanta de vez em quando é o total desconhecimento por programadores mais ou menos experientes dos níveis de erros que podem ocorrer em um fonte escrito em C ou C++. Desconheço o motivo, mas desconfio que o fato de outras linguagens não terem essa divisão de processos pode causar alguma nivelação entre as linguagens e fazer pensar que o processo de compilação em C é como em qualquer outra linguagem.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-10.html#[protecao_dos_membros_protected, protecao_dos_membros_protected]">Proteção dos membros protected</a></b>
<small><i>2007-10-26 computer ccpp blog  Quando queremos que um membro de nossa classe seja visível apenas dentro dos métodos da classe e dentro dos métodos das classes derivadas dessa classe usamos o nível de proteção protected. Isso, é claro, não quer dizer que uma classe derivada vá ter acesso aos membros protegidos de outra:</small></i>
</td></tr>
<tr><td>
<b><a href="2007-10.html#[typeid_e_os_perigos_do_nao_polimorfismo, typeid_e_os_perigos_do_nao_polimorfismo]">Typeid e os perigos do não-polimorfismo</a></b>
<small><i>2007-10-24 computer ccpp blog  Quando usamos o operador typeid geralmente desejamos conhecer informações sobre o tipo exato do objeto que temos em mãos, independente da hierarquia de herança a qual seu tipo pertença. Só que por ignorar, assim como o [sizeof], que esse operador possui duas caras, às vezes damos com os burros n'água e compramos gato por lebre. Não é pra menos. Uma sutil diferença entre classes polimórficas e estáticas pode dar aquele susto que só C++ pode proporcionar.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/the_c_programming_language_binary_tree.gif"/>
<b><a href="2007-10.html#[the_c_programming_language, the_c_programming_language]">A Linguagem de Programação C: O Livro</a></b>
<small><i>2007-10-12 ccpp books computer blog  O clássico de Ritchie e Kernighan, criadores da linguagem C, não foi meu primeiro livro de programação. E nem deveria ser. Não o recomendo para iniciantes, pois é necessário possuir algum conhecimento e prática para realmente aproveitar os conceitos desse livro.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-09.html#[a_mobilidade_das_variaveis_no_printf, a_mobilidade_das_variaveis_no_printf]">A mobilidade das variáveis no printf</a></b>
<small><i>2007-09-20 computer ccpp  O printf (e derivados) tem sérios problemas por conta de sua falta de tipagem. Não vou aqui dizer que cout é a alternativa óbvia e melhorada porque não é. Mas isso é uma discussão que eu não deveria começar aqui. E não começarei. Portanto, ignorem essa linha =).</small></i>
</td></tr>
<tr><td>
<b><a href="2007-09.html#[aquisicao_de_recurso_e_inicializacao, aquisicao_de_recurso_e_inicializacao]">Aquisição de recurso é inicialização</a></b>
<small><i>2007-09-14 computer ccpp blog  O título desse artigo é uma técnica presente no paradigma da programação em C++, razão pela qual não temos o operador finally. A idéia por trás dessa técnica é conseguirmos usar recursos representados por objetos locais de maneira que ao final da função esses objetos sejam destruídos e, junto com eles, os recursos que foram alocados. Podemos chamar de recursos aquele arquivo que necessita ser aberto para escrita, o bitmap que é exibido na tela, o ponteiro de uma interface COM, etc. O nosso exemplo é sobre arquivos:</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/historia_da_linguagem_c_parte_2_kthompson_dritchie.jpg"/>
<b><a href="2007-08.html#[historia_da_linguagem_c_parte_2, historia_da_linguagem_c_parte_2]">História da Linguagem C: Parte 2</a></b>
<small><i>2007-08-15 computer ccpp blog  No princípio... não, não, não. Antes do princípio, quando C era considerada a terceira letra do alfabeto e o que tínhamos eram linguagens experimentais para todos os lados, dois famigerados senhores dos Laboratórios Bell, K. Thompson e D. Ritchie, criaram uma linguagem chamada B. E B era bom.</small></i>
</td></tr>
<tr><td>
<img src="/journal/img/historia_da_linguagem_c_parte_1_martin_richards.gif"/>
<b><a href="2007-08.html#[historia_da_linguagem_c_parte_1, historia_da_linguagem_c_parte_1]">História da Linguagem C: Parte 1</a></b>
<small><i>2007-08-01 computer ccpp blog  Confesso que adoro estudar sobre a história da linguagem C. Essa verdadeira adoração pela linguagem me fez estudar suas precursoras, como as linguagens BCPL e B. Posso dizer que todo esse conhecimento, no final das contas, valeu a pena. Hoje entendo muito melhor as decisões tomadas na criação da linguagem e, principalmente, a origem de algumas idiossincrasias e boas idéias que permaneceram até hoje.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-07.html#[c_and_c++_operators_precedence_table, c_and_c++_operators_precedence_table]">C and C++ Operators Precedence Table</a></b>
<small><i>2007-07-30 computer ccpp english blog  These are the two websites where Márcio found the new tables: Dear Márcio, You have been my most productive reader ever. Besides having found the portability fail using static variables inside ifs, now you put in check the precedence table comparison between these two languages. In fact, some things were not so clear in that post. Let's clarify everything now (or at least try) using trustworthy sources, including the Wikipedia link sent to me.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-07.html#[what_happens_inside_the_sizeof_operator, what_happens_inside_the_sizeof_operator]">What happens inside the sizeof operator</a></b>
<small><i>2007-07-16 computer ccpp english blog  The question: how to get the size of a struct member without declaring it as a variable in memory? In pseudocode: In this first try (even being a nice one) we can clearly see by instinct that the construction is not supposed to work. The compiler error is not even clear. The member access operator (the point sign) needs to have as its left some variable or constant of the same type of the struct. Since the operand is the type itself, there is no deal.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-07.html#[precedence_difference, precedence_difference]">Precedence difference</a></b>
<small><i>2007-07-10 computer ccpp english blog  Once upon a time my old friend Kabloc wrote this little and "harmless" function in order to print the multiplication table: Despite the fact the result is a strong candidate to <a href="http://www.ioccc.org">The International Obfuscated C Code Contest</a> the Linux guys told him the code was not successful on GCC, and somewhere inside those four lines there was a non-standard piece of code.</small></i>
</td></tr>
<tr><td>
<b><a href="2007-06.html#[disassembling_the_array_operator, disassembling_the_array_operator]">Disassembling the array operator</a></b>
<small><i>2007-06-22 computer ccpp english code blog  Arrays are fascinating in C language because they are so simple and so powerful at the same time. When we start to really understand them and realize all its power we are very close to understand another awesome feature of the language: pointers.</small></i>
</td></tr>
</table>
<span style="float: left;">
</span>
</div>
</div>
</section>
<footer class="footer">
<div class="container">
</div>
<div class="intentionally-blank"></div>
</footer>
</body>
</html>
